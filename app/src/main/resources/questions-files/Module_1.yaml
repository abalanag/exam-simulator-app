questions:
  - description: "What is the Classpath used for in JVM?"
    answers:
      - option: "It is used by the JVM to identify the location of imported classes."
        correct: true
      - option: "It defines the version of the JVM."
        correct: false
      - option: "It is used to set the security level of applications."
        correct: false
      - option: "It specifies the main class to execute."
        correct: false

  - description: "Which access modifier allows a class to access methods or parameters only within the same package?"
    answers:
      - option: "Default (package)"
        correct: true
      - option: "Private (class)"
        correct: false
      - option: "Protected (subclass or package)"
        correct: false
      - option: "Public"
        correct: false
  - description: "What does the Bean definition contain?"
    answers:
      - option: "Information about the class to be initialized, constructor arguments, property values, and everything Spring needs to manage the bean's lifecycle."
        correct: true
      - option: "Only the properties of the class to be managed by Spring."
        correct: false
      - option: "Java code necessary to instantiate the class manually."
        correct: false
      - option: "Annotations required for Spring's component scan."
        correct: false

  - description: "What is essential for Spring to manage the lifecycle of a bean?"
    answers:
      - option: "Class initialization, constructor arguments, property values."
        correct: true
      - option: "Defining the bean in a configuration XML file only."
        correct: false
      - option: "Manual instantiation of beans within the application code."
        correct: false
      - option: "Ensuring all beans are annotated with @Autowired."
        correct: false
  - description: "What is a Servlet in Java EE?"
    answers:
      - option: "A component that processes and responds to HTTP requests."
        correct: true
      - option: "A JavaScript function for handling requests."
        correct: false
      - option: "A database management tool."
        correct: false
      - option: "A tool for version control."
        correct: false

  - description: "Which interface extends ServletRegistration for dynamic servlet configuration?"
    answers:
      - option: "ServletRegistration.Dynamic"
        correct: true
      - option: "HttpServlet"
        correct: false
      - option: "GenericServlet"
        correct: false
      - option: "ServletConfig"
        correct: false
  - description: "What is the purpose of the ServletRegistration interface?"
    answers:
      - option: "To create a read-only view of a servlet configuration."
        correct: true
      - option: "To dynamically create new servlet instances."
        correct: false
      - option: "To configure servlet initialization parameters only."
        correct: false
      - option: "To register servlets with the JavaScript engine."
        correct: false
  - description: "How can you obtain information about a servlet that is already registered?"
    answers:
      - option: "Using ServletRegistration to get a read-only view of the servlet configuration."
        correct: true
      - option: "By directly modifying the servlet's configuration files."
        correct: false
      - option: "Through direct access to the servlet's source code."
        correct: false
      - option: "Using an SQL query on the server's database."
        correct: false

  - description: "What can you do with the ServletRegistration.Dynamic interface?"
    answers:
      - option: "Dynamically configure a servlet, such as setting URL mappings and servlet parameters."
        correct: true
      - option: "Change the servlet's source code at runtime."
        correct: false
      - option: "Directly modify the HTTP response headers."
        correct: false
      - option: "Create new servlet instances on demand."
        correct: false
  - description: "What is the main use of ServletRegistration and ServletRegistration.Dynamic?"
    answers:
      - option: "To obtain servlet information and to dynamically configure servlets."
        correct: true
      - option: "For compiling servlets and generating Java code."
        correct: false
      - option: "To monitor the performance of servlets in real-time."
        correct: false
      - option: "To encrypt and decrypt servlet communication."
        correct: false
  - description: "What initiates the bean lifecycle in a Spring context?"
    answers:
      - option: "Creating the context."
        correct: true
      - option: "Instantiating the bean definition."
        correct: false
      - option: "Destroying the bean."
        correct: false
      - option: "Post-processing the bean."
        correct: false

  - description: "Which method is called after the bean definition is created but before the bean is instantiated?"
    answers:
      - option: "BeanFactoryPostProcessor method."
        correct: true
      - option: "@PostConstruct method."
        correct: false
      - option: "InitializingBean's afterPropertiesSet method."
        correct: false
      - option: "@Bean(initMethod) defined in the bean's configuration."
        correct: false

  - description: "Which method is not part of the bean initialization process?"
    answers:
      - option: "Bean destruction method."
        correct: true
      - option: "postProcessBeforeInitialization method of BeanPostProcessor."
        correct: false
      - option: "@PostConstruct."
        correct: false
      - option: "afterPropertiesSet from InitializingBean."
        correct: false

  - description: "What is the correct sequence of methods called during bean initialization?"
    answers:
      - option: "BeanFactoryPostProcessor, postProcessBeforeInitialization, @PostConstruct, afterPropertiesSet."
        correct: false
      - option: "postProcessBeforeInitialization, @PostConstruct, afterPropertiesSet, @Bean(initMethod)."
        correct: true
      - option: "@PostConstruct, afterPropertiesSet, BeanFactoryPostProcessor, postProcessBeforeInitialization."
        correct: false
      - option: "afterPropertiesSet, @Bean(initMethod), postProcessBeforeInitialization, @PostConstruct."
        correct: false

  - description: "When are beans destroyed in the Spring context lifecycle?"
    answers:
      - option: "After the context is closed."
        correct: true
      - option: "Before the context is fully initialized."
        correct: false
      - option: "Immediately after instantiation."
        correct: false
      - option: "During the post-processing phase."
        correct: false

  - description: "Which annotations are used to capture bean lifecycle events?"
    answers:
      - option: "@PostConstruct and @PreDestroy."
        correct: true
      - option: "@Autowired and @Qualifier."
        correct: false
      - option: "@Bean and @Component."
        correct: false
      - option: "@Service and @Repository."
        correct: false

  - description: "What is the role of the BeanPostProcessor in the bean lifecycle?"
    answers:
      - option: "It allows for custom modification of new bean instances, e.g., checking or wrapping them."
        correct: true
      - option: "It is responsible for creating bean instances."
        correct: false
      - option: "It defines the scope of beans."
        correct: false
      - option: "It destroys bean instances."
        correct: false

  - description: "Which interface is implemented for a bean to react after its properties are set?"
    answers:
      - option: "InitializingBean."
        correct: true
      - option: "DisposableBean."
        correct: false
      - option: "BeanFactoryPostProcessor."
        correct: false
      - option: "BeanPostProcessor."
        correct: false

  - description: "What does the @PreDestroy annotation do?"
    answers:
      - option: "Specifies a method to be called just before a bean is removed from the context."
        correct: true
      - option: "Initializes bean properties after construction."
        correct: false
      - option: "Creates a proxy for the bean to add additional behaviors."
        correct: false
      - option: "Marks a bean to be autowired by Spring's dependency injection facilities."
        correct: false

  - description: "What method is specifically designated for custom initialization logic in the bean's configuration?"
    answers:
      - option: "@Bean(initMethod)."
        correct: true
      - option: "@PostConstruct."
        correct: false
      - option: "afterPropertiesSet from InitializingBean."
        correct: false
      - option: "postProcessBeforeInitialization from BeanPostProcessor."
        correct: false
  - description: "What is the first step in the initialization of a bean?"
    answers:
      - option: "Creating the bean instance using the constructor or a factory method."
        correct: true
      - option: "Setting properties in the bean."
        correct: false
      - option: "Calling the initialization methods of the bean."
        correct: false
      - option: "Destroying the bean."
        correct: false

  - description: "What does Spring do after creating the bean instance?"
    answers:
      - option: "Sets the property values in the bean."
        correct: true
      - option: "Destroys the bean."
        correct: false
      - option: "Calls the BeanFactoryPostProcessor method."
        correct: false
      - option: "Initializes the web context."
        correct: false

  - description: "How does Spring initialize a bean?"
    answers:
      - option: "By calling the bean's initialization methods."
        correct: true
      - option: "By using the @Autowired annotation."
        correct: false
      - option: "By setting the ApplicationContext."
        correct: false
      - option: "By calling the @Bean annotation."
        correct: false

  - description: "Which of the following is NOT a step in the bean initialization process?"
    answers:
      - option: "Scanning the classpath for components."
        correct: true
      - option: "Creating the bean instance."
        correct: false
      - option: "Setting property values in the bean."
        correct: false
      - option: "Calling initialization methods of the bean."
        correct: false

  - description: "What marks the completion of a bean's preparation for use in the Spring context?"
    answers:
      - option: "The calling of the bean's initialization methods."
        correct: true
      - option: "The destruction of the bean."
        correct: false
      - option: "The scanning of @Component annotations."
        correct: false
      - option: "The application of @Autowired on bean properties."
        correct: false
  - description: "What is the correct order of steps for initializing a bean in Spring?"
    answers:
      - option: "Create bean instance, set property values, call initialization methods."
        correct: true
      - option: "Call initialization methods, create bean instance, set property values."
        correct: false
      - option: "Set property values, create bean instance, call initialization methods."
        correct: false
      - option: "Create bean instance, call initialization methods, set property values."
        correct: false
  - description: "What are meta-annotations in Spring?"
    answers:
      - option: "Annotations that are composed of other annotations, such as @RestController."
        correct: true
      - option: "Annotations used to inject beans into Spring contexts."
        correct: false
      - option: "Annotations that are used to directly access database entities."
        correct: false
      - option: "Annotations used for validation purposes only."
        correct: false

  - description: "Which annotation is an example of a meta-annotation in Spring?"
    answers:
      - option: "@Retention"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Entity"
        correct: false
      - option: "@Service"
        correct: false
      - option: "@Target"
        correct: false
      - option: "@Documented"
        correct: false
  - description: "Which annotations are considered stereotype annotations in Spring?"
    answers:
      - option: "@Component, @Controller, @Repository, @Service"
        correct: true
      - option: "@Autowired, @Qualifier, @Primary, @Bean"
        correct: false
      - option: "@Configuration, @Profile, @Bean"
        correct: false
      - option: "@Entity, @Table, @Column"
        correct: false

  - description: "What is the root stereotype annotation in Spring that all other stereotype annotations extend?"
    answers:
      - option: "@Component"
        correct: true
      - option: "@Service"
        correct: false
      - option: "@Controller"
        correct: false
      - option: "@Repository"
        correct: false

  - description: "What is the purpose of stereotype annotations in Spring?"
    answers:
      - option: "To assist Spring in discovering beans."
        correct: true
      - option: "To configure bean lifecycle methods."
        correct: false
      - option: "To inject bean dependencies."
        correct: false
      - option: "To create AOP proxies."
        correct: false
  - description: "What is the result of casting in the context of Java?"
    answers:
      - option: "Treating a result of a certain type differently, such as casting a result from Proxy.newProxyInstance to a specific type like PersonDao."
        correct: true
      - option: "Converting primitive data types to their corresponding wrapper classes automatically."
        correct: false
      - option: "Changing the value of a variable from one type to another incompatible type without errors."
        correct: false
      - option: "Encrypting a string value for security purposes."
        correct: false

  - description: "In which scenario is casting necessary in Java?"
    answers:
      - option: "When the result of Proxy.newProxyInstance needs to be treated as a specific type other than Object."
        correct: true
      - option: "When assigning values of one primitive type to another without changing the data type."
        correct: false
      - option: "When using generics and collections without specifying the type."
        correct: false
      - option: "When performing arithmetic operations on integer and string types."
        correct: false

  - description: "What does casting accomplish in the given Java scenario?"
    answers:
      - option: "It specifies that the result from Proxy.newProxyInstance will be treated as a specific type, like PersonDao, instead of Object."
        correct: true
      - option: "It automatically converts integer values to strings when concatenating with string values."
        correct: false
      - option: "It allows for the invocation of methods that are not present in the Object class on the resulting instance."
        correct: true
      - option: "It provides a mechanism for encrypting the data returned by Proxy.newProxyInstance for secure transmission."
        correct: false
  - description: "When is it necessary to annotate a @Bean method with @Autowired?"
    answers:
      - option: "When Spring needs to inject beans into the method and the method has parameters that require beans."
        correct: true
      - option: "When the method does not receive any parameters."
        correct: false
      - option: "For all bean definitions, regardless of method parameters."
        correct: false
      - option: "Only when the method is static."
        correct: false

  - description: "What happens if a method defined with @Bean is not annotated with @Autowired and has parameters?"
    answers:
      - option: "Spring will not inject the dependencies into the method."
        correct: true
      - option: "Spring automatically detects and injects the dependencies without needing @Autowired."
        correct: false
      - option: "The application will fail to start."
        correct: false
      - option: "Spring ignores the method and does not create the bean."
        correct: false

  - description: "Is @Autowired mandatory for methods annotated with @Bean to receive parameter dependencies?"
    answers:
      - option: "Yes, if the method has parameters and you want Spring to inject dependencies."
        correct: true
      - option: "No, Spring automatically injects dependencies without needing @Autowired for any method."
        correct: false
      - option: "Yes, for all @Bean methods regardless of whether they have parameters."
        correct: false
      - option: "No, @Autowired is only needed for constructor injection."
        correct: false

  - description: "Under what condition is @Autowired not required for a @Bean method to function correctly?"
    answers:
      - option: "When the method does not have any parameters."
        correct: true
      - option: "When the method is private."
        correct: false
      - option: "When the method is static."
        correct: false
      - option: "When the method returns void."
        correct: false

  - description: "What is the effect of omitting @Autowired on a @Bean method with parameters?"
    answers:
      - option: "Spring will not inject the required dependencies into the method."
        correct: true
      - option: "The method will still function correctly without any dependencies."
        correct: false
      - option: "Spring injects dependencies based on the type of parameters automatically."
        correct: false
      - option: "The application context fails to load."
        correct: false
  - description: "What does it mean when a class is annotated with @Component in Spring?"
    answers:
      - option: "It indicates that the class is a Spring bean."
        correct: true
      - option: "It is used for automatic database entity mapping."
        correct: false
      - option: "It specifies that the class should be ignored by the Spring container."
        correct: false
      - option: "It makes the class eligible for Spring's auto-configuration features."
        correct: false

  - description: "What is the function of a method annotated with @Bean in a Spring configuration class?"
    answers:
      - option: "It declares a bean to be managed by the Spring container."
        correct: true
      - option: "It automatically injects dependencies into the bean."
        correct: false
      - option: "It excludes the bean from Spring's component scanning."
        correct: false
      - option: "It marks the method as a transactional operation."
        correct: false

  - description: "What is the purpose of the DAO (Data Access Object) pattern in Spring?"
    answers:
      - option: "To provide an abstract interface to some type of database or other persistence mechanism."
        correct: true
      - option: "To automatically configure Spring beans based on the application context."
        correct: false
      - option: "To enable component scanning across the application."
        correct: false
      - option: "To manage the lifecycle of Spring beans from creation to destruction."
        correct: false
  - description: "Which types of dependency injection does Spring support?"
    answers:
      - option: "Constructor injection"
        correct: true
      - option: "Setter injection"
        correct: true
      - option: "Interface injection"
        correct: false
      - option: "Field injection"
        correct: true

  - description: "What is the purpose of @ComponentScan in Spring?"
    answers:
      - option: "It scans for Spring beans and automatically configures them."
        correct: true
      - option: "It is used to define SQL queries."
        correct: false
      - option: "It encrypts bean properties for security."
        correct: false
      - option: "It manually configures beans defined in XML."
        correct: false

  - description: "How can @Profile annotation change the behavior of a Spring application?"
    answers:
      - option: "By allowing different beans to be registered based on the active profile."
        correct: true
      - option: "It changes the database connection settings."
        correct: false
      - option: "It encrypts properties file based on the profile."
        correct: false
      - option: "It scans different packages based on the profile."
        correct: false

  - description: "Which annotations indicate a Spring bean should be scanned and configured?"
    answers:
      - option: "@Component"
        correct: true
      - option: "@Service"
        correct: true
      - option: "@Repository"
        correct: true
      - option: "@Entity"
        correct: false

  - description: "What enables easy switching between beans implementing the same interface in Spring?"
    answers:
      - option: "Using @Profile on bean definitions"
        correct: true
      - option: "Directly modifying bean source code"
        correct: false
      - option: "Using @Autowired without @Qualifier"
        correct: false
      - option: "Applying @Primary on all competing beans"
        correct: false

  - description: "What is true about constructor injection in Spring? (Select 2)"
    answers:
      - option: "It requires a class to declare a constructor with dependencies as parameters."
        correct: true
      - option: "It makes the dependency injection process explicit and error-proof."
        correct: true
      - option: "It is the only injection type that supports circular dependencies."
        correct: false
      - option: "It cannot be used alongside other types of injection."
        correct: false

  - description: "What benefits does dependency injection provide in Spring? (Select 2)"
    answers:
      - option: "Increases code reusability."
        correct: true
      - option: "Automatically generates bean implementations."
        correct: false
      - option: "Facilitates easy unit testing."
        correct: true
      - option: "Encrypts bean properties for security."
        correct: false

  - description: "What does field injection in Spring imply?"
    answers:
      - option: "Injecting dependencies by marking a class field with @Autowired."
        correct: true
      - option: "Automatically initializing all fields with default values."
        correct: false
      - option: "Injecting fields into the database directly."
        correct: false
      - option: "Securing fields with encryption annotations."
        correct: false

  - description: "Why is field injection not recommended in Spring?"
    answers:
      - option: "It can lead to issues with dependency circularity and testing."
        correct: true
      - option: "Because it is deprecated in the latest Spring version."
        correct: false
      - option: "It doesn't support XML configuration."
        correct: false
      - option: "Field values cannot be overridden once injected."
        correct: false

  - description: "Which Spring annotation is not directly related to the dependency injection?"
    answers:
      - option: "@Profile"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Qualifier"
        correct: false
      - option: "@Inject"
        correct: false

  - description: "How does @Profile annotation influence Spring bean registration?"
    answers:
      - option: "It conditions bean registration on the specified profiles being active."
        correct: true
      - option: "It registers a bean as a data source profile."
        correct: false
      - option: "It enhances the profile of a bean for better performance."
        correct: false
      - option: "It profiles bean instantiation time for optimization."
        correct: false

  - description: "What is required to use dependency injection in Spring? (Select 2)"
    answers:
      - option: "Declaring dependencies in a class that Spring manages."
        correct: true
      - option: "Ensuring that the class is annotated with @Injectable."
        correct: false
      - option: "Configuring beans in the Spring application context."
        correct: true
      - option: "Using the @Dependency annotation on all fields."
        correct: false

  - description: "Which statement accurately describes the role of @ComponentScan?"
    answers:
      - option: "It instructs Spring where to look for annotated components."
        correct: true
      - option: "It scans and modifies bean properties for performance optimization."
        correct: false
      - option: "It is used to scan and inject dependencies into components."
        correct: false
      - option: "It encrypts component information for secure bean instantiation."
        correct: false

  - description: "In Spring, what does the @Autowired annotation do?"
    answers:
      - option: "It marks a constructor, field, or setter method to be autowired by Spring's dependency injection facilities."
        correct: true
      - option: "It automatically configures your Spring application based on the classpath settings."
        correct: false
      - option: "It is used to create asynchronous methods within Spring applications."
        correct: false
      - option: "It specifies the profiles under which a bean will be registered."
        correct: false

  - description: "What aspect of dependency injection is managed by Spring's @Autowired annotation?"
    answers:
      - option: "Resolving and injecting beans by type."
        correct: true
      - option: "Scanning packages for new beans to register."
        correct: false
      - option: "Encrypting property values for security purposes."
        correct: false
      - option: "Automatically generating bean definitions based on the classpath."
        correct: false
  - description: "What is a design pattern in the context of software engineering? (select 2)"
    answers:
      - option: "A general reusable solution to a commonly occurring problem within a given context."
        correct: true
      - option: "A formalized best practice that a programmer can use to solve common problems when designing an application or system."
        correct: true
      - option: "A specific coding technique applied to improve the performance of a program."
        correct: false
      - option: "A software framework that provides ready-made functionality for a specific aspect of a software application."
        correct: false
      - option: "A debugging method used to identify the source of program errors."
        correct: false

  - description: "What characterizes an anti-pattern? (select 2)"
    answers:
      - option: "A commonly used practice that is counterproductive and potentially harmful to the project."
        correct: true
      - option: "A solution that initially appears to be an appropriate response to a problem but can lead to detrimental outcomes."
        correct: true
      - option: "A programming error that typically goes unnoticed during the initial stages of software development."
        correct: false
      - option: "An undocumented feature of a software language that provides a shortcut for common coding tasks."
        correct: false
      - option: "A design principle intended to increase the efficiency and flexibility of a software architecture."
        correct: false

  - description: "Which of the following best describes a 'pattern' in software development?"
    answers:
      - option: "A repeatable solution to a problem that occurs in a specific context."
        correct: true
      - option: "An inefficient coding practice that leads to more problems than it solves."
        correct: false
      - option: "A programming technique that solely relies on the use of external libraries."
        correct: false
      - option: "A workaround applied to bypass a limitation or defect in a programming language."
        correct: false
      - option: "A deprecated feature of a software framework that should be avoided."
        correct: false

  - description: "In the context of software design, what is NOT true about anti-patterns?"
    answers:
      - option: "They represent the best practices to be followed to ensure code quality."
        correct: true
      - option: "They are commonly used solutions that are ineffective and can negatively impact software development."
        correct: false
      - option: "They can lead to a decrease in productivity and increase in the cost of maintenance."
        correct: false
      - option: "They might seem like an appropriate solution initially but have bad consequences in the long term."
        correct: false
      - option: "They are practices that were once considered beneficial but have been found to be harmful as technology has advanced."
        correct: false

  - description: "What does the concept of 'pattern' emphasize in software engineering? (select 2)"
    answers:
      - option: "The importance of reusing solutions that have been proven effective."
        correct: true
      - option: "The application of well-understood design structures to improve software architecture."
        correct: true
      - option: "The reliance on automated tools to generate code based on pre-defined templates."
        correct: false
      - option: "The practice of copying code from one project to another without modification."
        correct: false
      - option: "The use of deprecated programming methodologies for backward compatibility."
        correct: false

  - description: "Which statement accurately reflects the nature of an anti-pattern?"
    answers:
      - option: "A practice that seems to be a good solution but has more disadvantages than benefits."
        correct: true
      - option: "A coding standard enforced by modern integrated development environments (IDEs)."
        correct: false
      - option: "A software development methodology that emphasizes rapid prototyping and iterative delivery."
        correct: false
      - option: "A set of guidelines for enhancing user interface design and user experience."
        correct: false
      - option: "A template for achieving scalability and performance in large-scale software systems."
        correct: false

  - description: "How do patterns and anti-patterns differ fundamentally? (select 2)"
    answers:
      - option: "Patterns offer solutions that facilitate effective software design, while anti-patterns describe common mistakes to avoid."
        correct: true
      - option: "Patterns are about best practices in coding and architecture; anti-patterns represent problematic solutions with negative outcomes."
        correct: true
      - option: "Patterns are outdated programming practices; anti-patterns are emerging trends in software development."
        correct: false
      - option: "Patterns apply only to object-oriented programming, whereas anti-patterns apply to all types of programming paradigms."
        correct: false
      - option: "Patterns cannot be applied to modern software development, whereas anti-patterns are more relevant to current technologies."
        correct: false

  - description: "Which of the following is considered an anti-pattern?"
    answers:
      - option: "Using global variables to manage state across the application."
        correct: true
      - option: "Applying the Singleton pattern to ensure a class has only one instance."
        correct: false
      - option: "Utilizing the Model-View-Controller (MVC) architecture for web applications."
        correct: false
      - option: "Implementing the Observer pattern to enable a subscription mechanism."
        correct: false
      - option: "Employing the Factory method pattern to create objects without specifying their concrete classes."
        correct: false

  - description: "What role do patterns play in software development?"
    answers:
      - option: "They serve as a guide for solving problems based on proven practices."
        correct: true
      - option: "They prescribe specific technologies to be used in all software projects."
        correct: false
      - option: "They enforce a strict set of coding standards and conventions."
        correct: false
      - option: "They mandate the use of certain software development methodologies."
        correct: false
      - option: "They are rigid rules that cannot be adapted to fit the needs of individual projects."
        correct: false

  - description: "Which statement best captures the essence of an anti-pattern?"
    answers:
      - option: "A solution that initially seems correct but is ultimately counterproductive."
        correct: true
      - option: "A universally accepted principle in software engineering."
        correct: false
      - option: "A technique that guarantees optimal performance across all systems."
        correct: false
      - option: "A method for ensuring compatibility with all possible user scenarios."
        correct: false
      - option: "A programming practice that guarantees code reusability and modularity."
        correct: false

  - description: "Why is it important to recognize anti-patterns in software development?"
    answers:
      - option: "To avoid common pitfalls that can lead to project failure."
        correct: true
      - option: "Because they represent the most modern programming techniques."
        correct: false
      - option: "To ensure that a project uses the latest software frameworks."
        correct: false
      - option: "Because they are recommended practices by all major software development methodologies."
        correct: false

  - description: "What distinguishes a pattern from an anti-pattern? (select 2)"
    answers:
      - option: "Patterns provide a solution to a problem, while anti-patterns offer a misleading solution that results in a negative outcome."
        correct: true
      - option: "Patterns are proven practices that improve software design, whereas anti-patterns are commonly used practices that are ineffective and harmful."
        correct: true
      - option: "Anti-patterns are more efficient and reliable than patterns."
        correct: false
      - option: "Patterns are only applicable to software development, while anti-patterns can be applied in any field."
        correct: false
      - option: "Patterns and anti-patterns are essentially the same and can be used interchangeably in software design."
        correct: false

  - description: "What is the significance of identifying anti-patterns in code reviews?"
    answers:
      - option: "It helps in recognizing and correcting practices that can degrade code quality and maintainability."
        correct: true
      - option: "It is a process to determine the developer's adherence to coding standards."
        correct: false
      - option: "Identifying anti-patterns is solely for the purpose of optimizing performance."
        correct: false
      - option: "It serves to identify the most efficient algorithms used in the application."
        correct: false
  - description: "Which of the following is an example of an anti-pattern related to software development process?"
    answers:
      - option: "Gold plating, where unnecessary features are added to the system without corresponding benefits."
        correct: true
      - option: "Singleton pattern, which restricts a class to a single instance."
        correct: false
      - option: "Observer pattern, used for subscribing to and notifying changes in state."
        correct: false
      - option: "Decorator pattern, which allows behavior to be added to an individual object, either statically or dynamically."
        correct: false

  - description: "What anti-pattern describes a situation where a project team continues with a solution that is clearly not working?"
    answers:
      - option: "Escalation of commitment"
        correct: true
      - option: "Bikeshedding, focusing on trivial details while important matters are inadequately attended."
        correct: false
      - option: "Cargo cult programming, using patterns without understanding why."
        correct: false
      - option: "Spaghetti code, where systems become complex and tangled as they are modified over time."
        correct: false

  - description: "Which anti-pattern involves using patterns and methods without understanding their purpose or relevance?"
    answers:
      - option: "Cargo cult programming"
        correct: true
      - option: "Lava flow, where obsolete and redundant code is not removed from the system."
        correct: false
      - option: "Magic push-button, where complex processes are hidden behind a simple interface without understanding the complexity."
        correct: false
      - option: "God object, where a single object holds a large number of functions and data."
        correct: false

  - description: "What is 'lava flow' in the context of software anti-patterns?"
    answers:
      - option: "A phenomenon where code or designs are retained even after they are no longer useful or relevant."
        correct: true
      - option: "A practice of continuously adding features to a product without increasing its value to users."
        correct: false
      - option: "A pattern where a team adopts new technologies without critical evaluation."
        correct: false
      - option: "A situation where the complexity of a system is hidden behind a simple interface."
        correct: false

  - description: "In software development, what does the 'God object' anti-pattern refer to?"
    answers:
      - option: "An object that knows too much or does too much, becoming a bottleneck in the application architecture."
        correct: true
      - option: "A foundational class from which all other classes in an application inherit."
        correct: false
      - option: "A singleton object that is overused in an application's codebase."
        correct: false
      - option: "An object that uses multiple inheritance to aggregate functionalities from different classes."
        correct: false
  - description: "What is an interface in Java? (select 2)"
    answers:
      - option: "A template that defines a set of actions an object can do."
        correct: true
      - option: "A reference type that can contain a collection of abstract methods."
        correct: true
      - option: "A specific implementation of a class."
        correct: false
      - option: "A tool for managing database connections."
        correct: false
      - option: "A class that implements all methods defined in another class."
        correct: false

  - description: "What are the benefits of using interfaces in Java? (select 2)"
    answers:
      - option: "They help to achieve decoupling between the contract and its implementation."
        correct: true
      - option: "They allow for multiple inheritance of type."
        correct: true
      - option: "They automatically implement all methods for efficiency."
        correct: false
      - option: "They reduce the need for testing and validation."
        correct: false
      - option: "They ensure that classes are directly accessible without interfaces."
        correct: false

  - description: "How do interfaces increase testability in Java applications?"
    answers:
      - option: "By allowing for easy creation of mock implementations for testing."
        correct: true
      - option: "By automatically generating test cases for each method."
        correct: false
      - option: "By eliminating the need for writing any tests."
        correct: false
      - option: "By integrating with external testing frameworks."
        correct: false

  - description: "What is the role of interfaces in implementation hiding within Spring?"
    answers:
      - option: "Interfaces allow for hiding the implementation details and exposing functionality through well-defined contracts."
        correct: true
      - option: "Interfaces automatically encrypt source code to protect implementation details."
        correct: false
      - option: "Interfaces are used to dynamically generate code at runtime."
        correct: false
      - option: "Interfaces prevent any form of dependency injection."
        correct: false

  - description: "In Spring, how can interfaces facilitate easy swapping of implementations?"
    answers:
      - option: "By defining a contract that can be implemented by multiple classes, allowing for easy substitution."
        correct: true
      - option: "By using proprietary Spring technologies to automatically swap implementations at runtime."
        correct: false
      - option: "By forcing all implementations to extend a base class."
        correct: false
      - option: "By locking down the application architecture to a single implementation path."
        correct: false

  - description: "Which Java feature allows interfaces to contain implementation code? (select 2)"
    answers:
      - option: "Default methods"
        correct: true
      - option: "Static methods"
        correct: true
      - option: "Private methods"
        correct: false
      - option: "Protected methods"
        correct: false
      - option: "Final methods"
        correct: false

  - description: "What advantage do interfaces provide in a Spring application regarding proxies? (select 2)"
    answers:
      - option: "They enable the use of JDK Dynamic Proxies when interfaces are used."
        correct: true
      - option: "They allow for more flexible proxy creation compared to class-based proxies."
        correct: true
      - option: "They automatically optimize the proxy at compile time."
        correct: false
      - option: "They increase the complexity of the proxy mechanism."
        correct: false
      - option: "They restrict the use of proxies to only interface methods."
        correct: false

  - description: "What Spring annotation is commonly used with interfaces to inject implementations?"
    answers:
      - option: "@Autowired"
        correct: true
      - option: "@Interface"
        correct: false
      - option: "@Implementation"
        correct: false
      - option: "@InjectInterface"
        correct: false

  - description: "Why are interfaces important for testing in Spring applications?"
    answers:
      - option: "They allow for the easy substitution of mock implementations during testing."
        correct: true
      - option: "They automatically generate test suites for all implemented methods."
        correct: false
      - option: "They provide built-in support for integration testing."
        correct: false
      - option: "They eliminate the need for unit testing by enforcing contract compliance."
        correct: false

  - description: "What does the use of interfaces in Spring promote in terms of application design?"
    answers:
      - option: "High cohesion and loose coupling."
        correct: true
      - option: "Tight coupling and high complexity."
        correct: false
      - option: "Code duplication and reduced modularity."
        correct: false
      - option: "Dependency on concrete classes."
        correct: false

  - description: "How do interfaces contribute to Spring's dependency injection mechanism? (select 2)"
    answers:
      - option: "By defining clear contracts for beans, making it easier to inject them where needed."
        correct: true
      - option: "By allowing for different implementations to be injected without changing the consuming bean's code."
        correct: true
      - option: "By injecting dependencies at compile-time rather than runtime."
        correct: false
      - option: "By making all beans singletons by default."
        correct: false
      - option: "By automatically creating interface implementations at runtime."
        correct: false

  - description: "What feature of Java interfaces enables adding new methods without breaking existing implementations?"
    answers:
      - option: "Default methods"
        correct: true
      - option: "Abstract methods"
        correct: false
      - option: "Static methods"
        correct: false
      - option: "Final methods"
        correct: false

  - description: "In what scenario is using JDK Dynamic Proxy preferred over CGLIB proxy in Spring?"
    answers:
      - option: "When AOP is applied to beans that are accessed via interfaces."
        correct: true
      - option: "When beans do not implement any interfaces at all."
        correct: false
      - option: "When optimizing for memory usage is not a priority."
        correct: false
      - option: "When all beans are configured to use prototype scope."
        correct: false

  - description: "In Java interfaces, which of the following can be contained? (select 2)"
    answers:
      - option: "Default methods"
        correct: true
      - option: "Static methods"
        correct: true
      - option: "Private constructors"
        correct: false
      - option: "Protected fields"
        correct: false
      - option: "Public classes"
        correct: false

  - description: "What is true about the use of interfaces in Spring for proxy creation? (select 2)"
    answers:
      - option: "JDK Dynamic Proxy can be used when interfaces are utilized."
        correct: true
      - option: "Implementation hiding is facilitated through interfaces."
        correct: true
      - option: "Interfaces eliminate the need for CGLIB proxies."
        correct: false
      - option: "Interfaces cannot be used for proxying classes without interfaces."
        correct: false
      - option: "All beans must be accessed directly without using interfaces."
        correct: false
  - description: "What does the Application Context in Spring Boot contain?"
    answers:
      - option: "All bean definitions from the application."
        correct: true
      - option: "Only the configurations related to the web layer."
        correct: false
      - option: "Runtime exceptions log."
        correct: false
      - option: "External library definitions only."
        correct: false

  - description: "Which of the following are responsibilities of the Application Context? (select 2)"
    answers:
      - option: "Initializing beans."
        correct: true
      - option: "Managing the lifecycle of beans."
        correct: true
      - option: "Directly managing database connections."
        correct: false
      - option: "Compiling Java source code."
        correct: false
      - option: "Encrypting property files."
        correct: false

  - description: "What is true about the Application Context and BeanFactory in Spring? (select 2)"
    answers:
      - option: "Application Context extends the BeanFactory interface."
        correct: true
      - option: "Application Context allows fetching any bean defined in the application."
        correct: true
      - option: "BeanFactory supports event publication, while Application Context does not."
        correct: false
      - option: "BeanFactory can load resources from the classpath, but Application Context cannot."
        correct: false
      - option: "Application Context is mainly used for low-level resource handling."
        correct: false

  - description: "Which Application Context implementation is used for web applications in a servlet environment?"
    answers:
      - option: "AnnotationConfigWebApplicationContext"
        correct: true
      - option: "AnnotationConfigApplicationContext"
        correct: false
      - option: "ClassPathXmlApplicationContext"
        correct: false
      - option: "FileSystemXmlApplicationContext"
        correct: false

  - description: "How can you specify which implementation of an interface to inject using Spring?"
    answers:
      - option: "By annotating the class with @Component('name') and selecting with @Qualifier."
        correct: true
      - option: "Using @Autowired on private fields only."
        correct: false
      - option: "By only using constructor injection."
        correct: false
      - option: "Spring automatically selects based on the class name."
        correct: false

  - description: "What are common types of Application Context in Spring? (select 2)"
    answers:
      - option: "AnnotationConfigApplicationContext"
        correct: true
      - option: "ClassPathXmlApplicationContext"
        correct: true
      - option: "DirectXmlApplicationContext"
        correct: false
      - option: "ManualConfigApplicationContext"
        correct: false
      - option: "DynamicWebApplicationContext"
        correct: false

  - description: "For creating an Application Context in a test, you first need to ensure:"
    answers:
      - option: "Dependencies for Spring Test are included."
        correct: true
      - option: "@Autowired is used on all test methods."
        correct: false
      - option: "Your application is annotated with @SpringApplication."
        correct: false
      - option: "All beans are manually instantiated within the test."
        correct: false

  - description: "When using AnnotationConfigApplicationContext, how should you instantiate your class?"
    answers:
      - option: "Using a class annotated with @ComponentScan or @SpringBootApplication."
        correct: true
      - option: "By creating a new instance with the new keyword."
        correct: false
      - option: "Through XML configuration files."
        correct: false
      - option: "Using @Autowired on the main class."
        correct: false

  - description: "What is the role of @ComponentScan in Spring?"
    answers:
      - option: "It allows Spring to detect components and configurations."
        correct: true
      - option: "It explicitly lists beans to be created in the application context."
        correct: false
      - option: "It scans the filesystem for XML configuration files."
        correct: false
      - option: "It generates new components based on templates."
        correct: false

  - description: "What does AnnotationConfigApplicationContext do with the configurations provided to it?"
    answers:
      - option: "Extracts bean definitions to manage within the application context."
        correct: true
      - option: "Compiles annotated classes into bytecode."
        correct: false
      - option: "Automatically generates web endpoints for beans."
        correct: false
      - option: "Encrypts the configuration for security purposes."
        correct: false

  - description: "Which ApplicationContext implementation is designed for standalone applications?"
    answers:
      - option: "AnnotationConfigApplicationContext"
        correct: true
      - option: "AnnotationConfigWebApplicationContext"
        correct: false
      - option: "XmlWebApplicationContext"
        correct: false
      - option: "FileSystemXmlApplicationContext"
        correct: false

  - description: "What does the ApplicationContext provide over a simple BeanFactory? (select 2)"
    answers:
      - option: "Lifecycle management of beans."
        correct: true
      - option: "Resource loading capabilities."
        correct: true
      - option: "Automatic compilation of Java classes."
        correct: false
      - option: "Direct JDBC connections management."
        correct: false
      - option: "Automatic encryption of property files."
        correct: false

  - description: "Which type of ApplicationContext would you use for defining beans in an XML file within the classpath?"
    answers:
      - option: "ClassPathXmlApplicationContext"
        correct: true
      - option: "AnnotationConfigApplicationContext"
        correct: false
      - option: "FileSystemXmlApplicationContext"
        correct: false
      - option: "XmlWebApplicationContext"
        correct: false

  - description: "In what scenario do you use FileSystemXmlApplicationContext?"
    answers:
      - option: "When the XML configuration file is located in the filesystem outside of the classpath."
        correct: true
      - option: "For web applications running in a servlet container."
        correct: false
      - option: "When defining beans using annotations."
        correct: false
      - option: "For applications that do not require external configurations."
        correct: false

  - description: "How does the Spring framework ensure that an ApplicationContext is closed properly in a standalone application?"
    answers:
      - option: "By using the registerShutdownHook method of the ApplicationContext."
        correct: true
      - option: "Spring automatically closes the ApplicationContext when the JVM exits."
        correct: false
      - option: "The ApplicationContext must be manually closed by the developer in all scenarios."
        correct: false
      - option: "By implementing the DisposableBean interface in configuration classes."
        correct: false
  - description: "What is a container in the context of Spring?"
    answers:
      - option: "An execution environment providing technical services for code utilization."
        correct: true
      - option: "A Java data structure for organizing objects."
        correct: false
      - option: "A database management tool."
        correct: false
      - option: "A version control system for Spring applications."
        correct: false

  - description: "What principle do containers generally follow to manage beans?"
    answers:
      - option: "Inversion of Control (IoC), focusing on business implementation while the execution environment handles communication."
        correct: true
      - option: "Procedural programming, where the execution order of functions is crucial."
        correct: false
      - option: "Event-driven programming, reacting to user inputs and system outputs."
        correct: false
      - option: "Functional programming, emphasizing the use of functions."
        correct: false

  - description: "Which Spring component is responsible for managing beans and their lifecycle?"
    answers:
      - option: "Spring container, using Bean definitions and Application Context."
        correct: true
      - option: "Spring MVC Dispatcher Servlet."
        correct: false
      - option: "Spring Security ContextHolder."
        correct: false
      - option: "Spring AOP Proxy Factory."
        correct: false

  - description: "What is the role of BeanFactoryPostProcessor in a Spring application? (select 2)"
    answers:
      - option: "Processes all bean definitions after their creation but before beans are instantiated."
        correct: true
      - option: "Allows implementing custom logic to modify bean definitions."
        correct: true
      - option: "Directly instantiates beans and manages their lifecycle."
        correct: false
      - option: "Secures bean definitions against unauthorized access."
        correct: false
      - option: "Automatically generates bean definitions from annotated classes."
        correct: false

  - description: "Which actions are performed upon the startup of a Spring application? (select 2)"
    answers:
      - option: "Creation of the Spring container."
        correct: true
      - option: "Reading and processing configuration to create bean definitions."
        correct: true
      - option: "Destruction callbacks are invoked."
        correct: false
      - option: "Beans are directly accessed and manipulated by the developer."
        correct: false
      - option: "External services are automatically integrated without configuration."
        correct: false

  - description: "What happens after all bean definitions are processed by BeanFactoryPostProcessor?"
    answers:
      - option: "Spring beans are instantiated, configured, and assembled."
        correct: true
      - option: "The application immediately shuts down."
        correct: false
      - option: "Spring Security interceptors are initialized."
        correct: false
      - option: "Web server is started, listening to HTTP requests."
        correct: false

  - description: "When is BeanPostProcessor invoked in the Spring bean lifecycle?"
    answers:
      - option: "Both before and after bean initialization."
        correct: true
      - option: "Before bean definitions are created."
        correct: false
      - option: "After the application context is closed."
        correct: false
      - option: "Immediately after bean instantiation, before dependencies are injected."
        correct: false

  - description: "What does implementing BeanPostProcessor allow you to do? (select 2)"
    answers:
      - option: "Modify bean instances before and after their initialization."
        correct: true
      - option: "Execute custom logic specific to certain bean lifecycle events."
        correct: true
      - option: "Prevent specific beans from being instantiated."
        correct: false
      - option: "Directly access and manipulate the underlying database connections."
        correct: false
      - option: "Override the default bean instantiation logic with custom code."
        correct: false

  - description: "In the Spring framework, what triggers the application shutdown process?"
    answers:
      - option: "Closing the Spring Context."
        correct: true
      - option: "Exceeding a predefined number of bean instantiations."
        correct: false
      - option: "A failure in bean post-processing."
        correct: false
      - option: "Reaching the maximum memory limit allocated to the JVM."
        correct: false

  - description: "What is automatically invoked by Spring upon application shutdown?"
    answers:
      - option: "Destruction callbacks."
        correct: true
      - option: "Bean instantiation methods."
        correct: false
      - option: "ApplicationContext initializers."
        correct: false
      - option: "BeanFactoryPostProcessor implementations."
        correct: false

  - description: "Which Spring interface allows you to modify bean definitions before bean instantiation?"
    answers:
      - option: "BeanFactoryPostProcessor."
        correct: true
      - option: "BeanPostProcessor."
        correct: false
      - option: "ApplicationListener."
        correct: false
      - option: "ApplicationContextInitializer."
        correct: false

  - description: "What advantage does the BeanPostProcessor interface provide in Spring's bean lifecycle?"
    answers:
      - option: "It enables modification of bean properties and dependencies after bean initialization."
        correct: true
      - option: "It replaces the default bean instantiation logic with a custom one."
        correct: false
      - option: "It allows for the direct invocation of bean methods during the startup phase."
        correct: false
      - option: "It encrypts bean properties for secure application contexts."
        correct: false

  - description: "How does Spring ensure that beans are fully initialized before being used in the application?"
    answers:
      - option: "By using BeanPostProcessor to call initialization callbacks."
        correct: true
      - option: "By instantiating all beans at the start of the application."
        correct: false
      - option: "Through manual initialization by the developer."
        correct: false
      - option: "Using a special annotation that marks beans as ready for use."
        correct: false

  - description: "What key role does the Application Context play in a Spring application? (select 2)"
    answers:
      - option: "It acts as a central registry for all Spring bean definitions."
        correct: true
      - option: "It manages the complete lifecycle of Spring beans, from creation to destruction."
        correct: true
      - option: "It compiles the application’s source code into bytecode."
        correct: false
      - option: "It serves as an HTTP request handler."
        correct: false
      - option: "It directly manages user sessions and security contexts."
        correct: false

  - description: "What is the significance of the BeanFactoryPostProcessor in the context of Spring?"
    answers:
      - option: "It allows for custom modification of bean definitions before the Spring container instantiates any beans."
        correct: true
      - option: "It automatically generates implementation classes for interfaces."
        correct: false
      - option: "It is responsible for managing transactions within Spring applications."
        correct: false
      - option: "It directly interacts with the database to persist bean data."
        correct: false

  - description: "Which method in the Spring bean lifecycle is specifically designated for custom initialization logic?"
    answers:
      - option: "The method annotated with @PostConstruct."
        correct: true
      - option: "The setter methods of bean properties."
        correct: false
      - option: "Any method annotated with @Autowired."
        correct: false
      - option: "Methods defined in the BeanFactoryPostProcessor interface."
        correct: false

  - description: "What functionality does implementing the DisposableBean interface provide to a Spring bean?"
    answers:
      - option: "It allows the bean to perform cleanup before the Spring container is destroyed."
        correct: true
      - option: "It makes the bean eligible for dependency injection."
        correct: false
      - option: "It automatically configures bean properties from properties files."
        correct: false
      - option: "It registers the bean as a candidate for aspect-oriented programming (AOP) advice."
        correct: false

  - description: "Which of the following best describes the purpose of the @PreDestroy annotation in a Spring bean?"
    answers:
      - option: "Marks a method to be called just before the bean is removed from the Spring container."
        correct: true
      - option: "Indicates that a bean should be instantiated at the start of the application."
        correct: false
      - option: "Specifies that a bean is ready to be injected into other beans."
        correct: false
      - option: "Designates a method that should run immediately after bean instantiation."
        correct: false

  - description: "In the context of Spring, what triggers the execution of methods annotated with @PostConstruct?"
    answers:
      - option: "These methods are executed after the bean is fully initialized, including all property injections."
        correct: true
      - option: "They are run during the bean instantiation phase, before any property injection."
        correct: false
      - option: "Spring schedules these methods to run periodically, based on a fixed schedule."
        correct: false
      - option: "They are executed before the application context is loaded."
        correct: false

  - description: "How does Spring support the configuration and management of beans in an application? (select 2)"
    answers:
      - option: "Through XML files specifying bean definitions and dependencies."
        correct: true
      - option: "By using Java-based configuration classes annotated with @Configuration."
        correct: true
      - option: "Via direct manual instantiation and management of beans by the developer."
        correct: false
      - option: "Employing runtime bytecode generation to dynamically create bean instances."
        correct: false
      - option: "Utilizing a proprietary language for defining bean workflows and lifecycles."
        correct: false

  - description: "What advantage do the BeanPostProcessor and BeanFactoryPostProcessor interfaces provide in Spring?"
    answers:
      - option: "They offer hooks for customizing bean properties and behaviors before and after initialization."
        correct: true
      - option: "They are used to manually instantiate beans instead of using Spring's container."
        correct: false
      - option: "These interfaces allow for direct manipulation of the Spring container’s internal structures."
        correct: false
      - option: "They enable the automatic generation of web endpoints for beans."
        correct: false

  - description: "What is the primary purpose of the ApplicationContext in Spring?"
    answers:
      - option: "To serve as the central interface for configuration and lifecycle management of Spring beans."
        correct: true
      - option: "To provide an embedded web server for Spring MVC applications."
        correct: false
      - option: "To compile and deploy Spring applications to a variety of platforms."
        correct: false
      - option: "To manage transactions and security contexts for Spring beans."
        correct: false

  - description: "Which Spring interface is used for cleaning up resources before a bean is destroyed?"
    answers:
      - option: "DisposableBean"
        correct: true
      - option: "InitializingBean"
        correct: false
      - option: "ApplicationContextAware"
        correct: false
      - option: "BeanFactoryAware"
        correct: false

  - description: "What does the Application Context use to load resources, such as property files?"
    answers:
      - option: "Its resource loader capabilities."
        correct: true
      - option: "Direct file system access through Java's File API."
        correct: false
      - option: "A dedicated ResourceBeanPostProcessor."
        correct: false
      - option: "The ClassLoader exclusively."
        correct: false

  - description: "Which method is called by the Spring container to signal that a bean is being removed and should release resources?"
    answers:
      - option: "The method annotated with @PreDestroy."
        correct: true
      - option: "Any custom method annotated with @Bean."
        correct: false
      - option: "The initMethod defined in the bean's @Bean annotation."
        correct: false
      - option: "Methods annotated with @PostConstruct."
        correct: false
  - description: "How do you create a new instance of an ApplicationContext for non-web applications using annotations?"
    answers:
      - option: "Instantiate AnnotationConfigApplicationContext with a class annotated with @ComponentScan."
        correct: true
      - option: "Directly instantiate ApplicationContext without any parameters."
        correct: false
      - option: "Use ClassPathXmlApplicationContext with XML configuration."
        correct: false
      - option: "Create ApplicationContext by providing a package name to scan for beans."
        correct: false

  - description: "What is the purpose of using @Configuration annotation in Spring?"
    answers:
      - option: "To define beans and their dependencies explicitly."
        correct: true
      - option: "To automatically scan and detect beans without explicit declarations."
        correct: false
      - option: "To create AOP proxies for beans."
        correct: false
      - option: "To encrypt property files for secure bean configuration."
        correct: false

  - description: "What does @ComponentScan annotation do in Spring? (select 2)"
    answers:
      - option: "It enables Spring to detect components, configurations, and services in the specified packages."
        correct: true
      - option: "Scans the classpath for all beans that are annotated with stereotypes like @Component, @Service, etc."
        correct: true
      - option: "Directly initializes beans without going through the bean lifecycle."
        correct: false
      - option: "Automatically generates web endpoints for REST-ful services."
        correct: false
      - option: "Encrypts bean definitions for enhanced security."
        correct: false

  - description: "Which of the following best describes the use of AnnotationConfigApplicationContext?"
    answers:
      - option: "For creating ApplicationContext in non-web applications using annotated classes."
        correct: true
      - option: "It is used exclusively for XML-based bean definition."
        correct: false
      - option: "For creating web applications only."
        correct: false
      - option: "To enable AOP proxies automatically without configuration."
        correct: false

  - description: "How can you define bean dependencies using annotations in Spring? (select 2)"
    answers:
      - option: "By using @Autowired on constructors or setters."
        correct: true
      - option: "Defining bean methods in @Configuration annotated classes with @Bean annotation."
        correct: true
      - option: "Through XML configuration files specifying bean dependencies."
        correct: false
      - option: "Using @Value annotation on fields that represent dependencies."
        correct: false
      - option: "Directly instantiating beans within other bean's constructors."
        correct: false

  - description: "What does the @Bean annotation do in a class annotated with @Configuration?"
    answers:
      - option: "Declares a method to return a bean to be managed by the Spring container."
        correct: true
      - option: "Automatically scans the classpath for beans to be created."
        correct: false
      - option: "Marks a class as a source of bean definitions."
        correct: false
      - option: "Specifies the scope of the bean being declared."
        correct: false

  - description: "When defining a bean, what does the 'initMethod' attribute specify in Spring?"
    answers:
      - option: "A method to be called on the bean immediately after its instantiation."
        correct: true
      - option: "The method to be used for destroying the bean."
        correct: false
      - option: "A constructor method to create bean instances."
        correct: false
      - option: "The default scope of the bean."
        correct: false

  - description: "What is the advantage of using the @Autowired annotation for dependency injection in Spring?"
    answers:
      - option: "It allows Spring to resolve and inject collaborating beans automatically."
        correct: true
      - option: "It encrypts the properties file containing sensitive information."
        correct: false
      - option: "Automatically generates implementation classes for interfaces."
        correct: false
      - option: "Creates AOP proxies for all injected beans."
        correct: false

  - description: "In Spring, how do you specify the method to call before a bean is destroyed?"
    answers:
      - option: "Using the 'destroyMethod' attribute of the @Bean annotation."
        correct: true
      - option: "Annotating a method in the bean class with @PreDestroy."
        correct: false
      - option: "Using @Autowired on a special bean destruction method."
        correct: false
      - option: "Defining a static method in the @Configuration annotated class."
        correct: false

  - description: "What role does the CustomBeanPostProcessor play in a Spring application?"
    answers:
      - option: "It allows for custom modification of bean instances before and after initialization."
        correct: true
      - option: "It encrypts and secures bean definitions."
        correct: false
      - option: "Generates data repositories implementations at runtime."
        correct: false
      - option: "Automatically exports beans as REST-ful web services."
        correct: false

  - description: "Which Spring class is used to create an ApplicationContext that reads bean definitions from XML files?"
    answers:
      - option: "ClassPathXmlApplicationContext"
        correct: true
      - option: "AnnotationConfigApplicationContext"
        correct: false
      - option: "XmlWebApplicationContext"
        correct: false
      - option: "FileSystemXmlApplicationContext"
        correct: false

  - description: "What does using @ComponentScan with @Configuration classes enable in a Spring application?"
    answers:
      - option: "Automatic detection and registration of beans within specified packages."
        correct: true
      - option: "Conversion of all POJOs in the application into Spring-managed beans."
        correct: false
      - option: "Encryption of bean properties for security purposes."
        correct: false
      - option: "Direct management of database transactions."
        correct: false

  - description: "How does AnnotationConfigApplicationContext facilitate the creation of a Spring application context?"
    answers:
      - option: "By receiving a configuration class as a parameter, which defines beans and their dependencies."
        correct: true
      - option: "By scanning the entire filesystem for bean definitions."
        correct: false
      - option: "Through explicit XML configuration files only."
        correct: false
      - option: "Using a web-based interface to configure beans."
        correct: false

  - description: "What is the significance of the @PreDestroy annotation in a Spring-managed bean?"
    answers:
      - option: "It marks a method to be called just before the bean is destroyed by the container."
        correct: true
      - option: "Indicates that a bean should be instantiated before all others."
        correct: false
      - option: "Specifies a method that should automatically encrypt bean data before destruction."
        correct: false
      - option: "Designates the primary constructor to use for bean instantiation."
        correct: false

  - description: "Which Spring framework feature allows for the automatic wiring of beans?"
    answers:
      - option: "@Autowired annotation."
        correct: true
      - option: "@Bean annotation in a configuration class."
        correct: false
      - option: "Manual bean instantiation within a @Configuration class."
        correct: false
      - option: "Defining beans in an XML file with <autowire> tag."
        correct: false

  - description: "What is the primary benefit of defining beans in a @Configuration class over XML configuration?"
    answers:
      - option: "It allows for type-safe configuration and integration with modern Java-based development."
        correct: true
      - option: "It provides better performance due to reduced parsing time."
        correct: false
      - option: "It is the only way to implement Aspect-Oriented Programming in Spring."
        correct: false
      - option: "XML configuration is deprecated and will be removed in future Spring versions."
        correct: false

  - description: "In Spring's ApplicationContext, what does the 'refresh' method do?"
    answers:
      - option: "Reloads the bean definitions and reinitialized the context."
        correct: true
      - option: "Clears all singleton beans from the application context."
        correct: false
      - option: "Restarts the embedded web server."
        correct: false
      - option: "Forces all prototype beans to be recreated."
        correct: false

  - description: "How can Spring manage bean lifecycles through annotations? (select 2)"
    answers:
      - option: "@PostConstruct for initializing bean properties after injection."
        correct: true
      - option: "@PreDestroy for cleanup before the bean is removed from the application context."
        correct: true
      - option: "@Bean for directly instantiating beans in non-Spring managed classes."
        correct: false
      - option: "@Autowired for manual instantiation and lifecycle management."
        correct: false
      - option: "@Configuration for defining scheduled tasks."
        correct: false

  - description: "What distinguishes @Autowired from @Inject in Spring?"
    answers:
      - option: "@Autowired is Spring-specific, while @Inject is a standard Java annotation for dependency injection."
        correct: true
      - option: "@Inject can only be used with XML configuration."
        correct: false
      - option: "@Autowired supports optional injection, but @Inject does not."
        correct: false
      - option: "@Inject is capable of creating beans, whereas @Autowired only injects them."
        correct: false

  - description: "Which statement about AnnotationConfigApplicationContext is accurate?"
    answers:
      - option: "It allows for registering configuration classes programmatically."
        correct: true
      - option: "It is primarily used for XML bean definitions."
        correct: false
      - option: "It does not support @ComponentScan and @Autowired annotations."
        correct: false
      - option: "It's specifically designed for web applications only."
        correct: false

  - description: "What role does @Qualifier play when used alongside @Autowired in Spring?"
    answers:
      - option: "It specifies which bean to inject when multiple candidates qualify for autowiring."
        correct: true
      - option: "It defines the scope of the bean being injected."
        correct: false
      - option: "It marks a bean as primary when multiple beans of the same type are present."
        correct: false
      - option: "It creates a new instance of the bean every time it's injected."
        correct: false
  - description: "What is required to create a Spring bean definition?"
    answers:
      - option: "The bean must be read from Spring Bean Configuration, which can be XML or a class annotated with @ComponentScan and @Configuration."
        correct: true
      - option: "A direct implementation without using Spring configurations."
        correct: false
      - option: "Manual instantiation of beans without using the Spring container."
        correct: false
      - option: "Exclusive use of XML files without annotation-based configuration."
        correct: false

  - description: "What are the phases a bean goes through in its lifecycle within an application context? (select 2)"
    answers:
      - option: "The bean is instantiated and ready to be used under normal conditions."
        correct: true
      - option: "The bean is destroyed."
        correct: true
      - option: "The bean is compiled into bytecode."
        correct: false
      - option: "The bean is archived for deployment."
        correct: false
      - option: "The bean undergoes encryption for security purposes."
        correct: false

  - description: "What triggers the creation of the application context?"
    answers:
      - option: "The application startup."
        correct: true
      - option: "A request sent to the Spring MVC Dispatcher Servlet."
        correct: false
      - option: "The completion of a database transaction."
        correct: false
      - option: "A REST API call to a Spring Boot application."
        correct: false

  - description: "Which annotation is used to enable the context to scan the classpath for all beans?"
    answers:
      - option: "@ComponentScan"
        correct: true
      - option: "@Bean"
        correct: false
      - option: "@Autowired"
        correct: false
      - option: "@Configuration"
        correct: false

  - description: "What information does a bean definition contain? (select 2)"
    answers:
      - option: "The class to be initialized."
        correct: true
      - option: "The properties values."
        correct: true
      - option: "The encryption keys for property files."
        correct: false
      - option: "The web server port configuration."
        correct: false
      - option: "The URL mappings for the Spring MVC controllers."
        correct: false

  - description: "When is BeanFactoryPostProcessor called in the bean lifecycle?"
    answers:
      - option: "After bean definitions are created but before any bean is instantiated."
        correct: true
      - option: "After the application context is fully initialized."
        correct: false
      - option: "Immediately after a bean is destroyed."
        correct: false
      - option: "Before the bean definitions are created."
        correct: false

  - description: "What is the role of BeanFactoryPostProcessor?"
    answers:
      - option: "It can modify bean definitions after they are created but before beans are instantiated."
        correct: true
      - option: "It directly creates bean instances without relying on Spring container."
        correct: false
      - option: "It encrypts sensitive bean properties."
        correct: false
      - option: "It automatically configures DataSource beans for database connectivity."
        correct: false

  - description: "Which of the following best describes the process of bean instantiation in Spring?"
    answers:
      - option: "Spring beans are instantiated, configured, and assembled based on the bean definitions."
        correct: true
      - option: "Beans are instantiated by manually calling their constructors within the application code."
        correct: false
      - option: "Instantiation occurs automatically when a bean is first accessed by its id in the runtime."
        correct: false
      - option: "Beans are instantiated after receiving an HTTP request for a REST endpoint."
        correct: false

  - description: "How can you ensure that a BeanFactoryPostProcessor runs before any other bean is created?"
    answers:
      - option: "By defining its constructor method as static in the configuration class."
        correct: true
      - option: "Using the @Order annotation with the highest precedence."
        correct: false
      - option: "By manually invoking it in the main method of your application."
        correct: false
      - option: "By annotating it with @Primary to indicate its priority."
        correct: false

  - description: "What advantage does implementing BeanPostProcessor provide?"
    answers:
      - option: "It allows modifying bean objects before and after they are initialized."
        correct: true
      - option: "It can add new bean definitions dynamically at runtime."
        correct: false
      - option: "Enables direct database interactions within bean lifecycle methods."
        correct: false
      - option: "Automatically generates REST endpoints for beans."
        correct: false

  - description: "When are destruction callbacks called in the Spring bean lifecycle?"
    answers:
      - option: "When the application context is closed or the application is shut down."
        correct: true
      - option: "Immediately after a bean is instantiated and before it is put into use."
        correct: false
      - option: "Right before the BeanFactoryPostProcessor is executed."
        correct: false
      - option: "After every HTTP request is processed in a web application."
        correct: false

  - description: "Which component is responsible for resolving property values and injecting dependencies?"
    answers:
      - option: "The Spring container during bean configuration and assembly."
        correct: true
      - option: "BeanFactoryPostProcessor before bean instantiation."
        correct: false
      - option: "BeanPostProcessor after bean initialization."
        correct: false
      - option: "Custom application code manually written by developers."
        correct: false

  - description: "What does the ApplicationContext do after creating all Spring beans? (select 2)"
    answers:
      - option: "Configures and assembles Spring beans."
        correct: true
      - option: "Invokes BeanPostProcessor for each bean."
        correct: true
      - option: "Automatically exports beans as microservices."
        correct: false
      - option: "Compiles the application’s source code into bytecode."
        correct: false
      - option: "Deploys the application to an external web server."
        correct: false

  - description: "How does @ComponentScan affect bean creation?"
    answers:
      - option: "It enables the ApplicationContext to discover beans and create bean definitions for them."
        correct: true
      - option: "Directly instantiates beans without creating bean definitions."
        correct: false
      - option: "Prevents the creation of beans that are not explicitly defined in the configuration."
        correct: false
      - option: "Creates beans based on XML configurations found in the classpath."
        correct: false

  - description: "What functionality does the @Primary annotation provide when defining beans?"
    answers:
      - option: "Indicates the bean that should be preferred when multiple candidates are qualified to autowire a single-valued dependency."
        correct: true
      - option: "Marks a bean to be initialized first before all other beans in the application context."
        correct: false
      - option: "Specifies that a bean should only be available for injection into primary components."
        correct: false
      - option: "Designates a method in a @Configuration class that will replace all other bean definitions."
        correct: false

  - description: "What is the Spring Framework's EventListener mechanism used for?"
    answers:
      - option: "To handle application events and custom events that are published within the Spring application context."
        correct: true
      - option: "Exclusively for handling HTTP request events in Spring MVC applications."
        correct: false
      - option: "For managing bean lifecycle events such as creation, initialization, and destruction."
        correct: false
      - option: "To listen for database event changes like insert, update, or delete operations."
        correct: false

  - description: "How can you define a custom application event in Spring? (select 2)"
    answers:
      - option: "By extending the ApplicationEvent class."
        correct: true
      - option: "Publishing it through the application context using the ApplicationEventPublisher interface."
        correct: true
      - option: "Declaring it in a XML configuration file as an event bean."
        correct: false
      - option: "Using the @Event annotation on any method that should trigger the event."
        correct: false
      - option: "Automatically generating events based on method names in any Spring bean."
        correct: false

  - description: "What does the ApplicationContextAware interface do?"
    answers:
      - option: "Allows a bean to be notified of the ApplicationContext that it is running in."
        correct: true
      - option: "Automatically wires beans into the application context without configuration."
        correct: false
      - option: "Provides a mechanism for beans to access the properties files within the application context."
        correct: false
      - option: "Ensures that a bean is aware of its dependencies in the context."
        correct: false

  - description: "Which annotation is used to mark a method as an event listener for application events?"
    answers:
      - option: "@EventListener"
        correct: true
      - option: "@EventWatcher"
        correct: false
      - option: "@HandleEvent"
        correct: false
      - option: "@SubscribeToEvent"
        correct: false

  - description: "In what scenario is the @Qualifier annotation particularly useful?"
    answers:
      - option: "When autowiring beans and there are multiple beans of the same type that qualify for injection."
        correct: true
      - option: "To specify which bean to instantiate when the application starts."
        correct: false
      - option: "For defining which bean methods should be transactional."
        correct: false
      - option: "Indicating the primary data source in multi-database applications."
        correct: false

  - description: "What role do @PostConstruct and @PreDestroy annotations play in a Spring managed bean's lifecycle?"
    answers:
      - option: "@PostConstruct is used for post-initialization logic, and @PreDestroy for pre-destruction cleanup logic."
        correct: true
      - option: "They define the order in which beans in the application context are instantiated."
        correct: false
      - option: "They indicate the primary bean when multiple beans of the same type exist."
        correct: false
      - option: "They are used to automatically inject dependencies into the bean."
        correct: false

  - description: "What is the main purpose of implementing the InitializingBean and DisposableBean interfaces?"
    answers:
      - option: "To provide a means for a bean to perform initialization and destruction callbacks."
        correct: true
      - option: "To indicate that a bean should be treated as a prototype or singleton."
        correct: false
      - option: "To automatically generate bean definitions based on classpath scanning."
        correct: false
      - option: "To mark a bean as eligible for aspect-oriented programming (AOP) advice."
        correct: false
  - description: "What is the first step to create an application context in a test?"
    answers:
      - option: "Ensure the dependencies for Spring Test are included."
        correct: true
      - option: "Annotate the test class with @SpringBootApplication."
        correct: false
      - option: "Directly instantiate the application context without any dependencies."
        correct: false
      - option: "Use @Autowired to inject the application context."
        correct: false

  - description: "Which annotation is used with SpringRunner to indicate a test class in Spring?"
    answers:
      - option: "@RunWith(SpringRunner.class)"
        correct: true
      - option: "@SpringBootTest"
        correct: false
      - option: "@TestConfiguration"
        correct: false
      - option: "@EnableAutoConfiguration"
        correct: false

  - description: "What does @ContextConfiguration do in a Spring test?"
    answers:
      - option: "Specifies the classes used for loading the application context."
        correct: true
      - option: "Configures the port for the embedded web server."
        correct: false
      - option: "Defines the strategy for loading context configuration."
        correct: false
      - option: "Automatically scans for Spring beans in the test package."
        correct: false

  - description: "How to specify configuration classes for creating an application context in a test? (select 2)"
    answers:
      - option: "Use @ContextConfiguration with the classes attribute."
        correct: true
      - option: "Include a class annotated with @Configuration in the classes attribute of @ContextConfiguration."
        correct: true
      - option: "Directly instantiate configuration classes in the test methods."
        correct: false
      - option: "Use @Autowired to automatically detect configuration classes."
        correct: false
      - option: "List all configuration classes in a properties file linked to the test."
        correct: false

  - description: "Which dependency scope is specified for Spring Test in a Maven project?"
    answers:
      - option: "test"
        correct: true
      - option: "compile"
        correct: false
      - option: "runtime"
        correct: false
      - option: "provided"
        correct: false

  - description: "What is the role of @RunWith(SpringRunner.class) in a Spring test?"
    answers:
      - option: "It integrates the Spring TestContext Framework with JUnit."
        correct: true
      - option: "It specifies the Spring application context to be loaded for the test."
        correct: false
      - option: "It marks the test to run only within a Spring Boot application."
        correct: false
      - option: "It configures the embedded web server for web integration tests."
        correct: false

  - description: "In Spring testing, what is required to ensure an application context is correctly created?"
    answers:
      - option: "A class annotated with @ContextConfiguration."
        correct: true
      - option: "A properties file named application-test.properties."
        correct: false
      - option: "A YAML file with the name test-application.yml."
        correct: false
      - option: "An XML file with the test configurations."
        correct: false

  - description: "What annotation is used to indicate which configuration classes should be used in a Spring test?"
    answers:
      - option: "@ContextConfiguration"
        correct: true
      - option: "@TestConfiguration"
        correct: false
      - option: "@EnableTesting"
        correct: false
      - option: "@ConfigurationProperties"
        correct: false

  - description: "Why is @ComponentScan important in the configuration class used for testing?"
    answers:
      - option: "It allows Spring to detect and register all beans within specified packages."
        correct: true
      - option: "It specifies which packages should be excluded from scanning."
        correct: false
      - option: "It enables automatic conversion of properties files to Java config."
        correct: false
      - option: "It defines the order in which beans are instantiated."
        correct: false

  - description: "How can you replace a configuration class in @ContextConfiguration for testing?"
    answers:
      - option: "List all classes to be tested directly in the annotation."
        correct: true
      - option: "Manually modify the configuration class before running tests."
        correct: false
      - option: "Use @ReplaceWith annotation to specify alternative classes."
        correct: false
      - option: "Override the configuration class with a properties file."
        correct: false
  - description: "Which Maven dependency is essential for Spring MVC testing?"
    answers:
      - option: "spring-test"
        correct: true
      - option: "spring-core"
        correct: false
      - option: "spring-mvc"
        correct: false
      - option: "junit"
        correct: false

  - description: "What does @SpringBootTest do in a Spring Boot application test?"
    answers:
      - option: "It provides integration testing support with full application context loading."
        correct: true
      - option: "It initializes only the web layer of the application context."
        correct: false
      - option: "It disables the web environment for faster unit testing."
        correct: false
      - option: "It marks the test to be ignored by the Spring testing framework."
        correct: false

  - description: "How do you mock a bean in the application context during a test? (select 2)"
    answers:
      - option: "Use @MockBean to add mock objects to the Spring application context."
        correct: true
      - option: "Annotate the test class with @Mock to automatically replace real beans with mocks."
        correct: true
      - option: "Directly instantiate the mock object in the test method."
        correct: false
      - option: "Configure the mock in the application-test.properties file."
        correct: false
      - option: "Use @Autowired to inject the mock object instead of the real bean."
        correct: false

  - description: "What annotation ensures that each test method runs in its own transaction in Spring?"
    answers:
      - option: "@Transactional"
        correct: true
      - option: "@Commit"
        correct: false
      - option: "@Rollback"
        correct: false
      - option: "@EnableTransactionManagement"
        correct: false

  - description: "For a test class, what does annotating a test method with @DirtiesContext accomplish?"
    answers:
      - option: "Indicates that the application context should be reloaded after the test method."
        correct: true
      - option: "Cleans the application context before running the test method."
        correct: false
      - option: "Marks the context as 'dirty' but does not reload it."
        correct: false
      - option: "Automatically rolls back any database transactions made during the test."
        correct: false

  - description: "What is the benefit of using @DataJpaTest in Spring Boot testing?"
    answers:
      - option: "It focuses on JPA components, using an in-memory database for testing repository layers."
        correct: true
      - option: "It provides utilities for web layer testing, simulating HTTP requests."
        correct: false
      - option: "It enables comprehensive testing of all Spring components together."
        correct: false
      - option: "It speeds up performance tests by bypassing the actual database."
        correct: false
  - description: "Is the Spring Application Context automatically closed by Spring in standalone applications?"
    answers:
      - option: "No, it must be closed manually using one of the recommended methods."
        correct: true
      - option: "Yes, Spring automatically closes the Application Context."
        correct: false

  - description: "Which method is recommended for closing the Application Context in a standalone application? (select 2)"
    answers:
      - option: "Using the registerShutdownHook method provided by the ApplicationContext."
        correct: true
      - option: "Utilizing the ApplicationContext in a try-with-resources block."
        correct: true
      - option: "Directly calling the close() method on the ApplicationContext."
        correct: false
      - option: "Leaving the Application Context open for the JVM to close upon application exit."
        correct: false
      - option: "Automatically closing the context after a fixed duration."
        correct: false

  - description: "What does the registerShutdownHook method do?"
    answers:
      - option: "It ensures the Application Context is closed before the application shuts down, regardless of how the application ends."
        correct: true
      - option: "It restarts the Application Context automatically after shutdown."
        correct: false
      - option: "It hooks into the JVM shutdown process to perform memory cleanup."
        correct: false
      - option: "Registers the application with a monitoring service for shutdown notifications."
        correct: false

  - description: "Why is the try-with-resources approach recommended for closing the Application Context?"
    answers:
      - option: "Because it guarantees the Application Context is closed when the block's execution ends."
        correct: true
      - option: "It provides better performance by optimizing resource utilization."
        correct: false
      - option: "Because it allows for conditional closure of the Application Context based on runtime decisions."
        correct: false
      - option: "It enables asynchronous closing of the Application Context."
        correct: false

  - description: "What is the risk associated with manually calling the close() method on the Application Context?"
    answers:
      - option: "The method might not be called due to an exception, leaving the context open."
        correct: true
      - option: "It can accidentally close the context too early, disrupting the application's functionality."
        correct: false
      - option: "The close() method is deprecated and its use is discouraged in newer versions of Spring."
        correct: false
      - option: "Closing the context manually can lead to memory leaks."
        correct: false

  - description: "What annotation is used to mark a bean method for execution before the Application Context is closed?"
    answers:
      - option: "@PreDestroy"
        correct: true
      - option: "@PostConstruct"
        correct: false
      - option: "@Bean"
        correct: false
      - option: "@Autowired"
        correct: false

  - description: "Which Spring class provides the registerShutdownHook method?"
    answers:
      - option: "AnnotationConfigApplicationContext"
        correct: true
      - option: "ApplicationContextAware"
        correct: false
      - option: "WebApplicationContext"
        correct: false
      - option: "BeanFactoryPostProcessor"
        correct: false

  - description: "When should the registerShutdownHook method be called?"
    answers:
      - option: "Immediately after the ApplicationContext has been created."
        correct: true
      - option: "Before any beans are instantiated within the Application Context."
        correct: false
      - option: "At the end of the application's main execution block."
        correct: false
      - option: "Periodically, to check if the application should be closed."
        correct: false

  - description: "What is the primary advantage of using registerShutdownHook over close()?"
    answers:
      - option: "It provides a more reliable way to close the Application Context, especially in error scenarios."
        correct: true
      - option: "It significantly improves the application's performance by managing resources more efficiently."
        correct: false
      - option: "registerShutdownHook allows for graceful shutdown of web servers in addition to closing the context."
        correct: false
      - option: "It automatically archives application data before closing the context."
        correct: false

  - description: "What happens to beans annotated with @PreDestroy when the Application Context is closed?"
    answers:
      - option: "Their annotated methods are called."
        correct: true
      - option: "They are automatically removed from the Application Context without calling any methods."
        correct: false
      - option: "The @PreDestroy annotation is ignored upon context closure."
        correct: false
      - option: "They are serialized and saved for application restarts."
        correct: false
  - description: "Which interface should a Spring bean implement to be notified of ApplicationContext closures?"
    answers:
      - option: "DisposableBean"
        correct: true
      - option: "ApplicationContextAware"
        correct: false
      - option: "InitializingBean"
        correct: false
      - option: "ApplicationListener"
        correct: false

  - description: "In a standalone Spring application, what is a common use case for manually closing the ApplicationContext?"
    answers:
      - option: "To release resources explicitly when the application is about to shut down."
        correct: true
      - option: "To reload the ApplicationContext with different configurations at runtime."
        correct: false
      - option: "To periodically refresh the ApplicationContext for performance optimization."
        correct: false
      - option: "To enable hot-swapping of beans during development for quick testing."
        correct: false

  - description: "What is the consequence of not properly closing the ApplicationContext in standalone applications?"
    answers:
      - option: "Potential resource leaks and incomplete execution of shutdown hooks."
        correct: true
      - option: "Automatic restart of the ApplicationContext."
        correct: false
      - option: "Increased performance due to persistent context caching."
        correct: false
      - option: "None, the JVM manages ApplicationContext closure automatically."
        correct: false

  - description: "How can you automate the closure of the ApplicationContext in a web application deployed on a servlet container?"
    answers:
      - option: "The servlet container typically manages the lifecycle, including the closure of the ApplicationContext."
        correct: true
      - option: "Invoke registerShutdownHook in the servlet's destroy method."
        correct: false
      - option: "Manually close the ApplicationContext in a @PreDestroy method of a bean."
        correct: false
      - option: "Use a context listener to close the ApplicationContext on session timeout."
        correct: false

  - description: "What does the 'try-with-resources' statement ensure when used with the ApplicationContext?"
    answers:
      - option: "That the ApplicationContext is automatically closed at the end of the block."
        correct: true
      - option: "It guarantees that beans within the ApplicationContext are singleton scoped."
        correct: false
      - option: "That the ApplicationContext is refreshed before each method execution."
        correct: false
      - option: "It prevents any exceptions from being thrown during the application's lifecycle."
        correct: false

  - description: "Why might you prefer the 'try-with-resources' approach over registerShutdownHook for closing the ApplicationContext?"
    answers:
      - option: "It provides a more deterministic and immediate way to close the ApplicationContext, especially useful in tests."
        correct: true
      - option: "Because 'try-with-resources' can handle more complex scenarios involving multiple ApplicationContexts."
        correct: false
      - option: "It's the only way to close an ApplicationContext that has web-based components."
        correct: false
      - option: "Because it integrates better with Spring's transaction management."
        correct: false
  - description: "What is the first step in describing dependencies using Java Configuration?"
    answers:
      - option: "Creating an ApplicationContext and providing a @Configuration annotated class to its constructor."
        correct: true
      - option: "Annotating the class with @Autowired to enable automatic dependency injection."
        correct: false
      - option: "Defining the beans directly within the main application class."
        correct: false
      - option: "Using XML configuration files to describe bean definitions."
        correct: false

  - description: "What is the role of the @Configuration annotation in Java Configuration?"
    answers:
      - option: "It indicates that a class declares one or more @Bean methods and may be processed by the Spring container."
        correct: true
      - option: "It is used to automatically detect and register beans based on classpath scanning."
        correct: false
      - option: "It specifies the scope of the beans defined within the class."
        correct: false
      - option: "It marks the class as a target for property injection using @Value annotations."
        correct: false

  - description: "How can you define a bean using Java Configuration? (select 2)"
    answers:
      - option: "By annotating a method with @Bean within a @Configuration annotated class."
        correct: true
      - option: "Using @Autowired on a method within a @Configuration class to automatically instantiate the bean."
        correct: true
      - option: "Declaring bean instances as public static fields in the @Configuration class."
        correct: false
      - option: "Annotating fields with @Bean in any component-scanned class."
        correct: false
      - option: "Using XML files to define beans and importing them into the @Configuration class."
        correct: false

  - description: "What is the purpose of using @Autowired in Java Configuration?"
    answers:
      - option: "To enable automatic wiring of dependencies among beans defined in the configuration class."
        correct: true
      - option: "To indicate that a bean should be exported for remote access."
        correct: false
      - option: "To specify default values for bean properties."
        correct: false
      - option: "To configure the bean lifecycle methods."
        correct: false

  - description: "In Java Configuration, how does Spring handle a bean that is dependent on other beans?"
    answers:
      - option: "Spring resolves and injects all required dependencies as defined in the @Configuration class before instantiation."
        correct: true
      - option: "Dependencies must be manually instantiated and passed to the bean constructor."
        correct: false
      - option: "Spring instantiates the bean first, then sets its dependencies using reflection."
        correct: false
      - option: "The dependent beans are fetched lazily at runtime when accessed."
        correct: false

  - description: "Which of the following is true about bean definition in Java Configuration?"
    answers:
      - option: "Bean methods annotated with @Bean produce a bean to be managed by the Spring container."
        correct: true
      - option: "Bean definitions are only possible through XML configuration files."
        correct: false
      - option: "Each bean definition must be accompanied by an XML counterpart."
        correct: false
      - option: "Beans defined in a @Configuration class cannot depend on each other."
        correct: false

  - description: "What ensures a bean is singleton scoped by default in Java Configuration?"
    answers:
      - option: "Spring's default behavior when no explicit scope is provided."
        correct: true
      - option: "Annotating the bean method with @Singleton."
        correct: false
      - option: "Defining the bean within a static method."
        correct: false
      - option: "Using @Scope(\"singleton\") on each bean method."
        correct: false

  - description: "How does @Bean differ from @Component in Java Configuration?"
    answers:
      - option: "@Bean is used within a @Configuration class to declare beans explicitly, while @Component is used to auto-detect and auto-configure beans."
        correct: true
      - option: "@Bean is used for bean definition in XML files, whereas @Component is used in Java classes."
        correct: false
      - option: "@Bean indicates a singleton bean, whereas @Component is used for prototype beans."
        correct: false
      - option: "@Component is deprecated and replaced by @Bean in newer versions of Spring."
        correct: false

  - description: "What is the effect of using @Autowired on a constructor in Java Configuration?"
    answers:
      - option: "It allows Spring to automatically inject the required dependencies into the bean when it is created."
        correct: true
      - option: "It makes the constructor private to prevent manual instantiation of the bean."
        correct: false
      - option: "It specifies that the bean should be lazily loaded."
        correct: false
      - option: "It indicates that this constructor should be used for destroying the bean."
        correct: false

  - description: "Can Java Configuration be used alongside XML configuration?"
    answers:
      - option: "Yes, they can be mixed, allowing for flexible configuration strategies."
        correct: true
      - option: "No, once Java Configuration is used, XML configuration becomes invalid."
        correct: false
      - option: "Yes, but only if the XML files are manually parsed within the Java Configuration class."
        correct: false
      - option: "No, Java Configuration and XML configuration are mutually exclusive due to Spring limitations."
        correct: false
  - description: "How can a specific profile be activated in Java Configuration?"
    answers:
      - option: "By annotating a @Configuration class or a @Bean method with @Profile and specifying the profile name."
        correct: true
      - option: "Using the @ActivateProfile annotation on the main application class."
        correct: false
      - option: "Directly modifying the application.properties file to include the active profile."
        correct: false
      - option: "Passing the profile name as an argument to the @Bean annotation."
        correct: false

  - description: "What does the @Primary annotation indicate in Java Configuration?"
    answers:
      - option: "It marks a bean as the primary candidate for autowiring when multiple beans match a given dependency."
        correct: true
      - option: "It specifies that a bean should be the first to be instantiated within its scope."
        correct: false
      - option: "It designates a configuration class as the primary source of bean definitions."
        correct: false
      - option: "It is used to set the highest priority for a bean in the application context."
        correct: false

  - description: "How do you externalize configuration properties in Java Configuration? (select 2)"
    answers:
      - option: "By using the @PropertySource annotation to specify the properties file."
        correct: true
      - option: "Injecting properties using the @Value annotation."
        correct: true
      - option: "Defining properties directly within the @Configuration class."
        correct: false
      - option: "Annotating beans with @Externalize to automatically load properties."
        correct: false
      - option: "Using XML configuration files to define property placeholders."
        correct: false

  - description: "What is the function of @Lazy annotation in Java Configuration?"
    answers:
      - option: "It indicates that a bean should be instantiated lazily, on demand, rather than eagerly at startup."
        correct: true
      - option: "It forces Spring to delay the initialization of the application context."
        correct: false
      - option: "It specifies that a method within a @Configuration class should be executed asynchronously."
        correct: false
      - option: "It is used to mark a bean for exclusion from the application context until explicitly requested."
        correct: false

  - description: "In Java Configuration, how are method-level security annotations enabled?"
    answers:
      - option: "By using @EnableGlobalMethodSecurity on a @Configuration class to specify the mode of security."
        correct: true
      - option: "Directly applying security annotations like @Secured or @PreAuthorize on service methods without additional configuration."
        correct: false
      - option: "Annotating the @Configuration class with @MethodSecurity."
        correct: false
      - option: "Security annotations are automatically enabled without any specific configuration in Java Config."
        correct: false
  - description: "What is the primary annotation used to enable automatic detection of Spring beans?"
    answers:
      - option: "@ComponentScan"
        correct: true
      - option: "@Bean"
        correct: false
      - option: "@Configuration"
        correct: false
      - option: "@Autowired"
        correct: false

  - description: "Which annotation is used to automatically wire beans by type?"
    answers:
      - option: "@Autowired"
        correct: true
      - option: "@Bean"
        correct: false
      - option: "@Component"
        correct: false
      - option: "@Qualifier"
        correct: false

  - description: "How does Spring resolve a bean when multiple implementations are present? (select 2)"
    answers:
      - option: "Using @Primary to indicate the default bean to be used."
        correct: true
      - option: "Utilizing @Qualifier to specify which bean to inject."
        correct: true
      - option: "Declaring the preferred bean directly in the method annotated with @Autowired."
        correct: false
      - option: "Automatically selecting the first found bean alphabetically."
        correct: false
      - option: "Creating a new bean instance specifically for each injection."
        correct: false

  - description: "What is the function of @PostConstruct in Spring's DI process?"
    answers:
      - option: "It marks a method to be executed after dependency injection is complete but before the bean is put into service."
        correct: true
      - option: "It indicates the method to run before the Spring container is fully initialized."
        correct: false
      - option: "Specifies a method to be invoked just before a bean is destroyed."
        correct: false
      - option: "Designates the initialization method for lazy-loaded beans."
        correct: false

  - description: "In what scenarios can @Autowired be used? (select 2)"
    answers:
      - option: "On constructor for constructor-based dependency injection."
        correct: true
      - option: "On setter methods or any arbitrary method to inject dependencies."
        correct: true
      - option: "Directly on the field to be injected without using a setter."
        correct: true
      - option: "On static methods to configure class-level dependencies."
        correct: false
      - option: "To annotate configuration classes and enable component scanning."
        correct: false

  - description: "Which annotations are used to define a Spring bean in a configuration class? (select 2)"
    answers:
      - option: "@Configuration"
        correct: true
      - option: "@Bean"
        correct: true
      - option: "@Component"
        correct: false
      - option: "@Service"
        correct: false
      - option: "@Repository"
        correct: false

  - description: "What does the @Component annotation indicate?"
    answers:
      - option: "It marks a class as a candidate for creating a bean to be managed by the Spring container."
        correct: true
      - option: "It specifies a method within a @Configuration class to define a bean."
        correct: false
      - option: "Declares an externalized property or value to be injected."
        correct: false
      - option: "It is used to identify the primary bean when multiple beans qualify for autowiring."
        correct: false

  - description: "What is the role of @Configuration in Spring?"
    answers:
      - option: "It indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests."
        correct: true
      - option: "It is used to specify which package to scan for Spring beans."
        correct: false
      - option: "It defines a configuration property to be injected into Spring beans."
        correct: false
      - option: "Marks a class as a Spring bean without needing a @Bean method."
        correct: false

  - description: "How is dependency injection achieved using setter methods in Spring?"
    answers:
      - option: "By annotating a setter method with @Autowired to let Spring inject the dependency."
        correct: true
      - option: "Using the @Value annotation on a setter method to inject values."
        correct: false
      - option: "Declaring the setter method within a class annotated with @Component."
        correct: false
      - option: "Through XML-based configuration specifying the property's value."
        correct: false

  - description: "Which of the following is a correct way to perform constructor injection in Spring?"
    answers:
      - option: "Annotate the constructor with @Autowired to automatically inject the required dependencies."
        correct: true
      - option: "Use the @Inject annotation on constructors instead of @Autowired for better performance."
        correct: false
      - option: "Constructor injection is not supported in Spring; use setter injection instead."
        correct: false
      - option: "Manually instantiate the dependencies and pass them to the constructor."
        correct: false

  - description: "Why is constructor injection preferred over field injection in Spring?"
    answers:
      - option: "It allows for immutable dependency references and ensures that required dependencies are not null."
        correct: true
      - option: "Constructor injection is less complex and more performance-efficient than field injection."
        correct: false
      - option: "Spring internally converts all field injections to constructor injections during runtime."
        correct: false
      - option: "Field injection is deprecated in the latest versions of Spring."
        correct: false

  - description: "What annotation should be used to inject a specific implementation when multiple beans of the same type are available?"
    answers:
      - option: "@Qualifier"
        correct: true
      - option: "@Primary"
        correct: false
      - option: "@Inject"
        correct: false
      - option: "@Bean"
        correct: false

  - description: "What is the significance of the @Primary annotation in Spring?"
    answers:
      - option: "It indicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency."
        correct: true
      - option: "It marks the primary configuration class that Spring should consider for bean definitions."
        correct: false
      - option: "Specifies that a method in a @Configuration class should be treated as the main bean creation method."
        correct: false
      - option: "It is used to set the priority of bean initialization during application startup."
        correct: false

  - description: "In which scenario is the @Lazy annotation particularly useful?"
    answers:
      - option: "When you want to delay the initialization of a bean to the point of its first usage rather than at application startup."
        correct: true
      - option: "For beans that are used frequently and need to be available as soon as the application starts."
        correct: false
      - option: "When beans need to be initialized in a specific order and @Lazy ensures the correct sequence."
        correct: false
      - option: "For defining beans that will be used in a non-web context, ensuring they are only loaded when needed."
        correct: false
  - description: "Which annotation is used to define a Spring bean in a configuration class?"
    answers:
      - option: "@Bean"
        correct: true
      - option: "@Component"
        correct: false
      - option: "@Service"
        correct: false
      - option: "@Repository"
        correct: false

  - description: "What does @Autowired do in Spring?"
    answers:
      - option: "It autowire bean on the setter method, constructor, or field."
        correct: true
      - option: "It marks a class as a Spring bean."
        correct: false
      - option: "It defines a configuration class."
        correct: false
      - option: "It specifies the URL patterns to be used by a servlet."
        correct: false

  - description: "What is the purpose of @PostConstruct in Spring?"
    answers:
      - option: "It is used to run code after the bean initialization."
        correct: true
      - option: "It defines a method to destroy a bean."
        correct: false
      - option: "It creates a new bean instance."
        correct: false
      - option: "It autowire the dependencies of a bean."
        correct: false

  - description: "How can you achieve dependency injection in Spring? (select 2)"
    answers:
      - option: "Using @Autowired on constructors."
        correct: true
      - option: "By declaring beans in a configuration class with @Bean."
        correct: true
      - option: "Directly instantiating beans using new keyword inside the configuration class."
        correct: false
      - option: "Using @ComponentScan to automatically instantiate and configure beans."
        correct: true
      - option: "Manually creating bean instances and setting them as properties."
        correct: false

  - description: "What annotation do you use to automatically scan for Spring components?"
    answers:
      - option: "@ComponentScan"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Bean"
        correct: false
      - option: "@Configuration"
        correct: false
  - description: "What is the primary purpose of stereotype annotations in Spring?"
    answers:
      - option: "To indicate that a class is a candidate for becoming a Spring bean."
        correct: true
      - option: "To encrypt class properties."
        correct: false
      - option: "To automatically generate REST endpoints."
        correct: false
      - option: "To configure bean destruction methods."
        correct: false

  - description: "Which stereotype annotation is typically used for a Spring MVC controller?"
    answers:
      - option: "@Controller"
        correct: true
      - option: "@Service"
        correct: false
      - option: "@Repository"
        correct: false
      - option: "@Component"
        correct: false

  - description: "What does the @Repository annotation signify in a Spring application?"
    answers:
      - option: "It is used on classes that directly access the database."
        correct: true
      - option: "It marks a class as a web controller."
        correct: false
      - option: "It designates a service class containing business logic."
        correct: false
      - option: "It is used to annotate configuration classes."
        correct: false

  - description: "Which of the following annotations are considered Spring stereotypes? (select 2)"
    answers:
      - option: "@Service"
        correct: true
      - option: "@Component"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Value"
        correct: false
      - option: "@Configuration"
        correct: false

  - description: "How does Spring treat classes annotated with stereotype annotations?"
    answers:
      - option: "It creates bean definitions for them, allowing them to be autowired."
        correct: true
      - option: "It encrypts their properties for secure communication."
        correct: false
      - option: "It converts them into REST controllers automatically."
        correct: false
      - option: "It ignores them unless explicitly declared in a configuration class."
        correct: false

  - description: "What stereotype annotation is considered the root stereotype and is generally used for any Spring-managed component?"
    answers:
      - option: "@Component"
        correct: true
      - option: "@Service"
        correct: false
      - option: "@Repository"
        correct: false
      - option: "@Controller"
        correct: false

  - description: "In what scenario would you use the @Service stereotype annotation?"
    answers:
      - option: "For classes that contain business logic."
        correct: true
      - option: "For classes that access a database."
        correct: false
      - option: "For classes that define Spring beans."
        correct: false
      - option: "For classes that handle HTTP requests."
        correct: false

  - description: "Can stereotype annotations like @Controller and @Service be used together on the same class?"
    answers:
      - option: "No, each class should be annotated with a single stereotype that reflects its purpose."
        correct: true
      - option: "Yes, combining them increases the class's functionality."
        correct: false
      - option: "Yes, but only if the class acts as both a controller and a service."
        correct: false
      - option: "No, because stereotype annotations are not compatible with each other."
        correct: false

  - description: "Which stereotype annotation is specifically designed for use in Spring MVC web applications?"
    answers:
      - option: "@Controller"
        correct: true
      - option: "@Service"
        correct: false
      - option: "@Repository"
        correct: false
      - option: "@Component"
        correct: false

  - description: "What is a common characteristic of classes annotated with @Repository?"
    answers:
      - option: "They are involved in database access or data persistence."
        correct: true
      - option: "They contain the main method of the application."
        correct: false
      - option: "They are used to store configuration properties."
        correct: false
      - option: "They define URL mappings for web applications."
        correct: false
  - description: "What are the meta-annotations in Spring?"
    answers:
      - option: "Annotations that can be used to create custom annotations."
        correct: true
      - option: "Annotations used to inject dependencies into Spring beans."
        correct: false
      - option: "Annotations that define the scope of Spring beans."
        correct: false
      - option: "Annotations used exclusively for Spring MVC controllers."
        correct: false

  - description: "What is the primary use of @RestController in Spring?"
    answers:
      - option: "To create controllers that handle REST-ful web requests."
        correct: true
      - option: "To define beans that will be automatically scanned and registered."
        correct: false
      - option: "To mark classes for dependency injection."
        correct: false
      - option: "To configure Spring's application context."
        correct: false

  - description: "Meta-annotations are essentially annotations that:"
    answers:
      - option: "Implement multiple annotations."
        correct: true
      - option: "Can only be applied to methods."
        correct: false
      - option: "Directly instantiate beans."
        correct: false
      - option: "Are used for XML configuration."
        correct: false

  - description: "Which Spring framework part is closely associated with the use of meta-annotations like @RestController?"
    answers:
      - option: "Spring MVC"
        correct: true
      - option: "Spring Data"
        correct: false
      - option: "Spring Security"
        correct: false
      - option: "Spring Cloud"
        correct: false

  - description: "Which of the following is an example of a meta-annotation in Spring?"
    answers:
      - option: "@RestController, which is composed of @Controller and @ResponseBody."
        correct: true
      - option: "@Autowired, used for automatic dependency injection."
        correct: false
      - option: "@ComponentScan, used for scanning beans."
        correct: false
      - option: "@Configuration, used to define configuration classes."
        correct: false

  - description: "How do meta-annotations enhance Spring configuration? (select 2)"
    answers:
      - option: "By reducing boilerplate code through combining common annotations."
        correct: true
      - option: "Facilitating more readable and maintainable configuration."
        correct: true
      - option: "Increasing the complexity of Spring configuration."
        correct: false
      - option: "Limiting the flexibility in defining bean configurations."
        correct: false
      - option: "Directly interacting with the database for data persistence configurations."
        correct: false

  - description: "Why are custom meta-annotations valuable in large Spring projects?"
    answers:
      - option: "They provide a way to enforce consistency and best practices across the project."
        correct: true
      - option: "They automatically generate documentation for the project."
        correct: false
      - option: "They eliminate the need for Java or XML configuration."
        correct: false
      - option: "Custom meta-annotations are discouraged in large projects due to performance issues."
        correct: false

  - description: "Which annotation is often used to customize the behavior of @RequestMapping in Spring MVC?"
    answers:
      - option: "@RequestMapping itself when combined with other annotations to form a composite meta-annotation."
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Service"
        correct: false
      - option: "@Component"
        correct: false

  - description: "What allows for the creation of meta-annotations in Spring?"
    answers:
      - option: "Spring's support for annotation inheritance and composition."
        correct: true
      - option: "The presence of specific XML configuration files."
        correct: false
      - option: "The use of Java's native reflection capabilities exclusively."
        correct: false
      - option: "A special Spring compiler plugin."
        correct: false

  - description: "In creating a custom meta-annotation, what is a critical consideration?"
    answers:
      - option: "The meta-annotation should provide clear, reusable configuration patterns."
        correct: true
      - option: "Every meta-annotation must be paired with a direct XML equivalent."
        correct: false
      - option: "Custom meta-annotations require manual registration with the Spring container."
        correct: false
      - option: "Meta-annotations are only effective when used on classes, not methods or fields."
        correct: false
  - description: "What is the default scope of Spring beans when not specified?"
    answers:
      - option: "@Singleton"
        correct: true
      - option: "@Prototype"
        correct: false
      - option: "@RequestScope"
        correct: false
      - option: "@SessionScope"
        correct: false

  - description: "Which scope would you use for a bean that needs to be different for each user session in a web application?"
    answers:
      - option: "@SessionScope"
        correct: true
      - option: "@RequestScope"
        correct: false
      - option: "@Singleton"
        correct: false
      - option: "@Prototype"
        correct: false

  - description: "What Spring bean scope creates a new bean instance for each request in a web application?"
    answers:
      - option: "@RequestScope"
        correct: true
      - option: "@SessionScope"
        correct: false
      - option: "@Singleton"
        correct: false
      - option: "@Prototype"
        correct: false

  - description: "In which type of application is the @Singleton scope generally used?"
    answers:
      - option: "Standalone applications"
        correct: true
      - option: "Web applications"
        correct: false
      - option: "Both standalone and web applications"
        correct: false
      - option: "Neither, it's used in enterprise applications only"
        correct: false

  - description: "What Spring bean scope generates a new bean instance each time one is needed?"
    answers:
      - option: "@Prototype"
        correct: true
      - option: "@Singleton"
        correct: false
      - option: "@RequestScope"
        correct: false
      - option: "@SessionScope"
        correct: false

  - description: "How do you define a bean with @Prototype scope? (select 2)"
    answers:
      - option: "Using @Scope(\"prototype\") on the bean definition."
        correct: true
      - option: "Annotating the class with @Component and specifying the scope."
        correct: true
      - option: "It is the default scope, so no need to specify."
        correct: false
      - option: "Using @Singleton with negation."
        correct: false
      - option: "Annotating the class with @Prototype directly."
        correct: false

  - description: "Which bean scope is suitable for stateful beans in Spring web applications?"
    answers:
      - option: "@SessionScope"
        correct: true
      - option: "@RequestScope"
        correct: false
      - option: "@Singleton"
        correct: false
      - option: "@Prototype"
        correct: false

  - description: "What happens to a @RequestScope bean at the end of a web request?"
    answers:
      - option: "It is eligible for garbage collection."
        correct: true
      - option: "It is stored in the HttpSession."
        correct: false
      - option: "It becomes a @Singleton bean."
        correct: false
      - option: "It is persisted to a database."
        correct: false

  - description: "Can a @Prototype scoped bean be injected into a @Singleton bean?"
    answers:
      - option: "Yes, but the prototype bean will behave like a singleton when injected into a singleton."
        correct: true
      - option: "No, Spring does not allow this type of injection."
        correct: false
      - option: "Yes, and the prototype bean will always generate a new instance in the singleton."
        correct: false
      - option: "No, because it causes a scope conflict."
        correct: false

  - description: "What is the significance of the @Singleton scope in the Spring framework?"
    answers:
      - option: "It ensures that a single instance of a bean is created and shared across the application context."
        correct: true
      - option: "It indicates that each bean usage will have a unique instance."
        correct: false
      - option: "It is used to create beans that are stateless."
        correct: false
      - option: "It marks beans that are thread-safe."
        correct: false
  - description: "Are Spring beans eagerly or lazily instantiated by default?"
    answers:
      - option: "Eagerly instantiated by default for Singleton scope."
        correct: true
      - option: "Lazily instantiated by default."
        correct: false
      - option: "Instantiated at runtime on demand for every scope."
        correct: false
      - option: "Eagerly instantiated for all scopes."
        correct: false

  - description: "How can the default instantiation behavior of Spring beans be altered?"
    answers:
      - option: "Using the @Lazy annotation."
        correct: true
      - option: "By defining beans in XML configuration files."
        correct: false
      - option: "Using the @Eager annotation."
        correct: false
      - option: "It cannot be altered; it's a fixed behavior."
        correct: false

  - description: "What does @Lazy(true) imply when used with a @Component?"
    answers:
      - option: "The bean is lazily instantiated."
        correct: true
      - option: "The bean is eagerly instantiated."
        correct: false
      - option: "The bean is instantiated at compile time."
        correct: false
      - option: "The bean is instantiated twice to ensure singleton."
        correct: false

  - description: "Which scope causes beans to be lazily instantiated by default?"
    answers:
      - option: "Prototype scope."
        correct: true
      - option: "Singleton scope."
        correct: false
      - option: "Request scope."
        correct: false
      - option: "Session scope."
        correct: false

  - description: "When a Singleton bean depends on a Prototype bean, how is the Prototype bean instantiated?"
    answers:
      - option: "Eagerly, to satisfy the Singleton's dependency."
        correct: true
      - option: "Lazily, upon the first access to the Prototype bean."
        correct: false
      - option: "It remains uninstantiated until manually called."
        correct: false
      - option: "As a Singleton, to match the dependency's scope."
        correct: false

  - description: "How to ensure all beans are lazily instantiated in a Spring application?"
    answers:
      - option: "Annotate the configuration class with @ComponentScan(lazyInit = true)."
        correct: true
      - option: "Annotate each bean with @Lazy."
        correct: false
      - option: "Use @Lazy at the class level only."
        correct: false
      - option: "Spring beans are lazily instantiated by default; no action needed."
        correct: false

  - description: "Which annotation is used to force eager instantiation of a bean that's configured to be lazily instantiated?"
    answers:
      - option: "@Lazy(false)"
        correct: true
      - option: "@Eager"
        correct: false
      - option: "@PreLoad"
        correct: false
      - option: "@Instantiate"
        correct: false

  - description: "What effect does @Lazy have when applied to a @Configuration class?"
    answers:
      - option: "It causes all beans defined in the configuration to be lazily instantiated."
        correct: true
      - option: "It marks the configuration itself for lazy instantiation, which is not applicable."
        correct: false
      - option: "It forces the configuration class to be loaded at application startup."
        correct: false
      - option: "No effect, as @Lazy is ignored on @Configuration classes."
        correct: false

  - description: "Under which condition is a bean defined as lazy in a @ComponentScan annotated class with lazyInit set to true?"
    answers:
      - option: "Unless annotated with @Lazy(false), all beans are lazy."
        correct: true
      - option: "All beans are eager unless explicitly marked with @Lazy."
        correct: false
      - option: "Only beans annotated with @Lazy are considered for lazy instantiation."
        correct: false
      - option: "Beans are lazy only if they are of Prototype scope."
        correct: false

  - description: "What happens to Prototype scoped beans when accessed from a Singleton bean without any lazy configuration?"
    answers:
      - option: "They are instantiated eagerly to satisfy the Singleton bean's dependencies."
        correct: true
      - option: "They remain lazily instantiated until explicitly accessed."
        correct: false
      - option: "Prototype beans ignore any lazy or eager settings."
        correct: false
      - option: "They are instantiated lazily, but only upon the first request."
        correct: false

  - description: "Which bean scope is not affected by the @Lazy annotation?"
    answers:
      - option: "Singleton, when @Lazy is not used."
        correct: false
      - option: "Prototype, as it's lazily instantiated by default."
        correct: true
      - option: "Request scope, as each request creates a new bean instance."
        correct: false
      - option: "Session scope, as it depends on user sessions."
        correct: false

  - description: "Can @Lazy be applied to component scanning with @ComponentScan?"
    answers:
      - option: "Yes, using the lazyInit attribute of @ComponentScan."
        correct: true
      - option: "No, @Lazy is only applicable to individual beans."
        correct: false
      - option: "Yes, but it requires additional configuration."
        correct: false
      - option: "No, because @Lazy is incompatible with @ComponentScan."
        correct: false

  - description: "What scope results in beans being created only when explicitly requested?"
    answers:
      - option: "Prototype"
        correct: true
      - option: "Singleton"
        correct: false
      - option: "Request"
        correct: false
      - option: "Session"
        correct: false

  - description: "Which annotation directly influences whether a bean is eagerly or lazily instantiated?"
    answers:
      - option: "@Lazy"
        correct: true
      - option: "@Scope"
        correct: false
      - option: "@Component"
        correct: false
      - option: "@Service"
        correct: false

  - description: "In a web application, which scope would cause a bean to be instantiated for each HTTP request?"
    answers:
      - option: "@RequestScope"
        correct: true
      - option: "@SessionScope"
        correct: false
      - option: "@ApplicationScope"
        correct: false
      - option: "@Singleton"
        correct: false
  - description: "What is the effect of applying the @Lazy annotation on a dependency injection point?"
    answers:
      - option: "The dependency is injected lazily at its point of use rather than at application startup."
        correct: true
      - option: "The dependency is always injected eagerly, ignoring the @Lazy annotation."
        correct: false
      - option: "It has no effect; @Lazy is only applicable at the bean definition level."
        correct: false
      - option: "It prevents the dependency from being injected, making it optional."
        correct: false

  - description: "Which method ensures a Spring bean defined in XML is lazily loaded?"
    answers:
      - option: "Setting the 'lazy-init' attribute to true in the bean definition."
        correct: true
      - option: "Annotating the XML file with @Lazy at the top."
        correct: false
      - option: "Using the <lazy-load> tag within the bean definition."
        correct: false
      - option: "XML-based bean definitions cannot be lazily loaded."
        correct: false

  - description: "How does the @Lazy annotation affect the startup time of a Spring application?"
    answers:
      - option: "It can decrease startup time by delaying bean instantiation until necessary."
        correct: true
      - option: "It increases startup time due to additional processing required to handle lazy loading."
        correct: false
      - option: "@Lazy has no impact on application startup time."
        correct: false
      - option: "It significantly increases startup time as it conflicts with component scanning."
        correct: false

  - description: "When using @Lazy in a configuration class, how does Spring treat the beans defined in the class?"
    answers:
      - option: "All beans defined in the class are lazily instantiated by default."
        correct: true
      - option: "Beans are eagerly instantiated, but their dependencies are lazily loaded."
        correct: false
      - option: "Only beans explicitly marked with @Lazy are affected; others remain eagerly loaded."
        correct: false
      - option: "The @Lazy annotation is ignored in configuration classes."
        correct: false

  - description: "What potential issue should be considered when using @Lazy with a Singleton scoped bean?"
    answers:
      - option: "If the bean is required during startup, it may not be available, leading to errors."
        correct: true
      - option: "Lazy loading a Singleton bean can cause duplicate bean instances."
        correct: false
      - option: "@Lazy is incompatible with Singleton scope and results in a fallback to Prototype scope."
        correct: false
      - option: "There are no potential issues; @Lazy is fully compatible with all bean scopes without drawbacks."
        correct: false
  - description: "Can @Profile be used together with @Component?"
    answers:
      - option: "Yes, to conditionally include a bean based on the active profile."
        correct: true
      - option: "No, they cannot be used together."
        correct: false
      - option: "@Profile is only usable with @Configuration."
        correct: false
      - option: "@Component ignores any @Profile annotation."
        correct: false

  - description: "What happens to a @Component annotated class without @Profile in any profile situation?"
    answers:
      - option: "It is always instantiated, regardless of the active profile."
        correct: true
      - option: "It is never instantiated."
        correct: false
      - option: "It is instantiated only if no profile is active."
        correct: false
      - option: "It requires explicit configuration to be instantiated."
        correct: false

  - description: "How is a bean defined with a single @Profile annotation instantiated?"
    answers:
      - option: "Only if the specified profile is active."
        correct: true
      - option: "Regardless of which profile is active."
        correct: false
      - option: "Only if no profile is active."
        correct: false
      - option: "If any profile other than the specified one is active."
        correct: false

  - description: "What does @Profile('!profile') mean when used with @Component?"
    answers:
      - option: "The bean is instantiated if the specified profile is not active."
        correct: true
      - option: "The bean is instantiated only in the negated profile."
        correct: false
      - option: "It is a syntax error and not a valid usage."
        correct: false
      - option: "The bean is instantiated without considering profiles."
        correct: false

  - description: "Can a bean be associated with multiple profiles? (select 2)"
    answers:
      - option: "Yes, using @Profile({'profile1', 'profile2'})."
        correct: true
      - option: "Yes, by annotating the bean with multiple @Profile annotations."
        correct: true
      - option: "No, a bean can only be associated with a single profile."
        correct: false
      - option: "Yes, but only if the profiles are specified in XML configuration."
        correct: false
      - option: "No, Spring beans ignore profile annotations."
        correct: false

  - description: "What is the effect of annotating a @Component with no @Profile?"
    answers:
      - option: "The component is considered a default bean and instantiated regardless of active profiles."
        correct: true
      - option: "It is ignored by Spring and not instantiated."
        correct: false
      - option: "It causes a runtime error due to missing profile specification."
        correct: false
      - option: "It is instantiated only when all profiles are inactive."
        correct: false

  - description: "How does Spring handle a component annotated with @Profile('profile') when the profile is not active?"
    answers:
      - option: "The component is not instantiated."
        correct: true
      - option: "The component is instantiated but marked as inactive."
        correct: false
      - option: "It is instantiated and placed in a special 'inactive' context."
        correct: false
      - option: "The application fails to start due to a profile mismatch."
        correct: false

  - description: "What is required to activate multiple profiles for a Spring application?"
    answers:
      - option: "Set the active profiles via Context.getEnvironment().setActiveProfiles('Profile1','Profile2')."
        correct: true
      - option: "Manually instantiate beans for each required profile."
        correct: false
      - option: "Multiple @Profile annotations on the main application class."
        correct: false
      - option: "Annotate each bean with all profiles it should belong to."
        correct: false

  - description: "Is there a limit to the number of profiles that can be active in Spring?"
    answers:
      - option: "No explicit limit, but constrained by the maximum size of a Java array."
        correct: true
      - option: "Yes, a maximum of 10 profiles can be active at any time."
        correct: false
      - option: "Yes, only a single profile can be active at a time."
        correct: false
      - option: "Spring documentation specifies a maximum of 100 active profiles."
        correct: false

  - description: "What does annotating a @Component with multiple @Profile annotations signify?"
    answers:
      - option: "The component is instantiated if any of the specified profiles are active."
        correct: true
      - option: "The component will only be instantiated if all specified profiles are active."
        correct: false
      - option: "It results in a conflict, and the component is never instantiated."
        correct: false
      - option: "It is an invalid configuration and causes an application startup failure."
        correct: false

  - description: "Can @Profile be used to exclude a bean from being instantiated in a specific profile?"
    answers:
      - option: "Yes, by prefixing the profile name with '!' in the @Profile annotation."
        correct: true
      - option: "No, @Profile can only include, not exclude beans."
        correct: false
      - option: "Exclusion requires a custom Spring extension, not @Profile."
        correct: false
      - option: "Excluding beans is managed through configuration properties, not annotations."
        correct: false

  - description: "What approach is used to manage bean creation based on profiles without @Profile?"
    answers:
      - option: "The bean is always created, making it default for any profile configuration."
        correct: true
      - option: "Such beans are only created if no profiles are active."
        correct: false
      - option: "Beans without @Profile are manually instantiated through XML configuration."
        correct: false
      - option: "Spring ignores these beans unless explicitly configured in a Java config class."
        correct: false
  - description: "What is a Property Source in Spring?"
    answers:
      - option: "An abstraction over environment variables and properties as key-value pairs."
        correct: true
      - option: "A Spring annotation used for defining bean scopes."
        correct: false
      - option: "A type of Spring bean."
        correct: false
      - option: "A configuration class in Spring Boot applications."
        correct: false

  - description: "From where can property values be loaded into the Spring environment? (select 2)"
    answers:
      - option: "JVM Properties"
        correct: true
      - option: "System environment variables"
        correct: true
      - option: "XML configuration files"
        correct: false
      - option: "Annotations directly in the code"
        correct: false
      - option: "Directly from the database"
        correct: false

  - description: "How do you add properties from a file located in the filesystem to Spring's Environment?"
    answers:
      - option: "Using @PropertySource annotation with a 'file:' prefix"
        correct: true
      - option: "@Autowired on a properties file"
        correct: false
      - option: "Using @Value annotation directly on a properties file"
        correct: false
      - option: "By defining them in the application.properties file"
        correct: false

  - description: "What does the @PropertySources annotation do?"
    answers:
      - option: "It is used to declare a set of @PropertySource annotations."
        correct: true
      - option: "It specifies the sources of beans for component scanning."
        correct: false
      - option: "It defines properties directly within the code."
        correct: false
      - option: "It is used to inject property values into fields."
        correct: false

  - description: "Which of the following is a valid use of the @PropertySource annotation?"
    answers:
      - option: "@PropertySource('classpath:/app-defaults.properties')"
        correct: true
      - option: "@PropertySource without specifying a location."
        correct: false
      - option: "@PropertySource to inject values directly to fields."
        correct: false
      - option: "Using @PropertySource to define bean scopes."
        correct: false

  - description: "Where does @PropertySource look for properties when prefixed with 'classpath:'?"
    answers:
      - option: "In the classpath, typically in the resources directory."
        correct: true
      - option: "Directly on the system's environment variables."
        correct: false
      - option: "In the file system outside the application."
        correct: false
      - option: "In the source code of the application."
        correct: false

  - description: "How can you specify a property source that is external to your Spring application?"
    answers:
      - option: "Using @PropertySource with a 'file:' prefix and the path to the file."
        correct: true
      - option: "By adding properties to the application.properties file."
        correct: false
      - option: "By using environment variables only."
        correct: false
      - option: "Through direct field injection using @Value."
        correct: false

  - description: "What is required to use variables like '${app-home}' in @PropertySource?"
    answers:
      - option: "Defining the variable in the JVM arguments."
        correct: true
      - option: "Adding the variable to the application.properties file."
        correct: false
      - option: "Declaring the variable as a bean in the Spring context."
        correct: false
      - option: "Nothing, Spring resolves these variables automatically."
        correct: false

  - description: "Which annotation is used to declare that properties should be loaded from a specific location?"
    answers:
      - option: "@PropertySource"
        correct: true
      - option: "@Value"
        correct: false
      - option: "@Environment"
        correct: false
      - option: "@PropertiesLoader"
        correct: false

  - description: "Can you use @PropertySource to load properties from multiple files?"
    answers:
      - option: "Yes, by using @PropertySources or multiple @PropertySource annotations."
        correct: true
      - option: "No, @PropertySource can only load properties from a single file."
        correct: false
      - option: "Yes, but only if the files are located in the classpath."
        correct: false
      - option: "No, properties can only be loaded from the application.properties file."
        correct: false

  - description: "How do you handle properties with missing values to prevent application failure?"
    answers:
      - option: "Using the ':' operator in @Value to specify a default value."
        correct: true
      - option: "Spring automatically ignores missing properties."
        correct: false
      - option: "By annotating the property field with @IgnoreMissing."
        correct: false
      - option: "Properties with missing values must be manually checked in code."
        correct: false

  - description: "What is the impact of defining multiple @PropertySource annotations with overlapping properties?"
    answers:
      - option: "The last @PropertySource annotation processed overrides the values of overlapping properties."
        correct: true
      - option: "Spring throws an exception due to property conflicts."
        correct: false
      - option: "All overlapping properties are ignored by Spring."
        correct: false
      - option: "Spring merges the values of overlapping properties."
        correct: false

  - description: "Can environment variables override properties defined in @PropertySource files?"
    answers:
      - option: "Yes, environment variables have higher precedence."
        correct: true
      - option: "No, properties defined in @PropertySource files always take precedence."
        correct: false
      - option: "Only if explicitly configured in Spring's application context."
        correct: false
      - option: "Environment variables and @PropertySource properties are isolated and do not interact."
        correct: false

  - description: "Which Spring annotation allows for property resolution using SpEL (Spring Expression Language)?"
    answers:
      - option: "@Value"
        correct: true
      - option: "@PropertySource"
        correct: false
      - option: "@Expression"
        correct: false
      - option: "@SpEL"
        correct: false

  - description: "In Spring, where is the most common place to declare @PropertySource annotations?"
    answers:
      - option: "In a configuration class annotated with @Configuration."
        correct: true
      - option: "Directly on bean methods within the configuration class."
        correct: false
      - option: "On the main application class."
        correct: false
      - option: "Within the application.properties file."
        correct: false

  - description: "How does @PropertySource integrate with Spring's Environment abstraction?"
    answers:
      - option: "It adds the specified properties to the set of PropertySources in the Environment."
        correct: true
      - option: "It replaces the existing PropertySources in the Environment."
        correct: false
      - option: "It creates a new Environment instance for each @PropertySource."
        correct: false
      - option: "@PropertySource properties are stored separately from the Environment."
        correct: false

  - description: "What is the role of the Environment interface in relation to @PropertySource?"
    answers:
      - option: "It provides access to the properties loaded from @PropertySource."
        correct: true
      - option: "It is used to define new property sources."
        correct: false
      - option: "It acts as an alternative to @PropertySource for loading properties."
        correct: false
      - option: "It secures properties loaded by @PropertySource."
        correct: false

  - description: "Is it possible to use @PropertySource with properties files located outside of the application's packaged JAR/WAR?"
    answers:
      - option: "Yes, using a file path or URL."
        correct: true
      - option: "No, @PropertySource can only load files from the classpath."
        correct: false
      - option: "Yes, but only with additional configuration."
        correct: false
      - option: "No, external files must be manually loaded into the Environment."
        correct: false

  - description: "What mechanism does Spring provide to customize the order in which property sources are added?"
    answers:
      - option: "The @Order annotation or the 'order' attribute in @PropertySource."
        correct: true
      - option: "Spring does not allow customization of property source order."
        correct: false
      - option: "Using priority levels in application.properties."
        correct: false
      - option: "Order is determined by the alphabetical order of file names."
        correct: false

  - description: "How are active profiles considered when loading properties with @PropertySource?"
    answers:
      - option: "@PropertySource does not directly consider profiles; profiles need to be managed separately."
        correct: true
      - option: "@PropertySource automatically filters properties based on active profiles."
        correct: false
      - option: "Properties are loaded only if they match the names of active profiles."
        correct: false
      - option: "A special @ProfilePropertySource annotation is required for profile integration."
        correct: false
  - description: "What command is used to activate multiple Spring profiles simultaneously?"
    answers:
      - option: "Context.getEnvironment().setActiveProfiles('Profile1', 'Profile2', 'Prod')"
        correct: true
      - option: "Using the @ActiveProfiles annotation with profile names as parameters."
        correct: false
      - option: "Adding profile names to the spring.profiles.active property in application.properties."
        correct: false
      - option: "Profiles are automatically activated based on the environment."
        correct: false

  - description: "Is there a limit to the number of active profiles in a Spring application?"
    answers:
      - option: "No explicit limit, but effectively limited by the maximum size of a Java array."
        correct: true
      - option: "Yes, a maximum of 10 profiles can be active at any time."
        correct: false
      - option: "Yes, only one profile can be active at any given time."
        correct: false
      - option: "The limit is specified by the Spring framework configuration."
        correct: false

  - description: "How do you register a configuration class and refresh the application context after activating a profile?"
    answers:
      - option: "By using context.register('ApplicationConfig') followed by context.refresh()."
        correct: true
      - option: "Automatically upon activating the profile with no additional steps required."
        correct: false
      - option: "Using @Configuration and @Profile annotations on the class."
        correct: false
      - option: "Profiles and configuration registration is managed exclusively through properties files."
        correct: false

  - description: "How are profiles stored within the Spring framework? (select 2)"
    answers:
      - option: "In an array, as part of the Environment abstraction."
        correct: true
      - option: "Profiles are referenced through JVM system properties."
        correct: false
      - option: "Directly within the ApplicationContext."
        correct: false
      - option: "Using @Profile annotations on beans."
        correct: true
      - option: "In external configuration files outside the framework."
        correct: false

  - description: "What is the purpose of using the @Profile annotation in Spring?"
    answers:
      - option: "To conditionally register beans based on the active profiles."
        correct: true
      - option: "To define the default profile for the application."
        correct: false
      - option: "To specify the version of the Spring framework to be used."
        correct: false
      - option: "To enhance the performance of the application by selecting profiles."
        correct: false

  - description: "Can the @Profile annotation be combined with @Component?"
    answers:
      - option: "Yes, to specify that a bean should only be available in certain profiles."
        correct: true
      - option: "No, they serve different purposes and cannot be used together."
        correct: false
      - option: "Yes, but only if the component is part of the default profile."
        correct: false
      - option: "No, @Profile can only be used with @Configuration classes."
        correct: false

  - description: "What effect does not specifying a profile have on a @Component annotated bean?"
    answers:
      - option: "It is registered regardless of the active profile."
        correct: true
      - option: "It is only registered if there are no active profiles."
        correct: false
      - option: "It will cause a runtime error due to missing profile configuration."
        correct: false
      - option: "It will be registered under a default profile created by Spring."
        correct: false

  - description: "How does the '@Profile(\"!prod\")' annotation affect bean registration?"
    answers:
      - option: "The bean is registered if the 'prod' profile is not active."
        correct: true
      - option: "The bean is always registered, regardless of the profile."
        correct: false
      - option: "The bean is only registered within the 'prod' profile."
        correct: false
      - option: "It prevents the bean from being registered in any profile."
        correct: false
  - description: "What is the purpose of BeanFactoryPostProcessor in Spring?"
    answers:
      - option: "It allows for custom modification of bean definitions before the Spring container instantiates any beans."
        correct: true
      - option: "It is used for bean instantiation and dependency injection."
        correct: false
      - option: "It directly creates bean instances."
        correct: false
      - option: "It manages transactional behavior of beans."
        correct: false

  - description: "When is BeanFactoryPostProcessor invoked in the Spring lifecycle?"
    answers:
      - option: "After all bean definitions are loaded and before any beans are instantiated."
        correct: true
      - option: "After beans are instantiated but before dependency injection."
        correct: false
      - option: "At the beginning of the application context initialization."
        correct: false
      - option: "After the application context is fully initialized."
        correct: false

  - description: "Why would you define a @Bean method as static?"
    answers:
      - option: "To ensure that BeanFactoryPostProcessor beans are created before any other beans."
        correct: true
      - option: "To prevent Spring from creating bean instances."
        correct: false
      - option: "Static @Bean methods are required for all bean definitions."
        correct: false
      - option: "To increase the performance of the application startup."
        correct: false

  - description: "What is PropertySourcesPlaceholderConfigurer used for?"
    answers:
      - option: "Resolving ${...} placeholders within bean definition property values and @Value annotations."
        correct: true
      - option: "Defining new property sources for the Spring environment."
        correct: false
      - option: "Injecting property values directly into beans."
        correct: false
      - option: "Configuring the bean lifecycle methods."
        correct: false

  - description: "Which of the following is true about BeanFactoryPostProcessor? (select 2)"
    answers:
      - option: "It modifies bean definitions before beans get instantiated."
        correct: true
      - option: "It is invoked before any bean instances are created."
        correct: true
      - option: "It is responsible for creating bean instances."
        correct: false
      - option: "It is typically used for injecting dependencies into beans."
        correct: false
      - option: "It is used to annotate data access layers in Spring applications."
        correct: false

  - description: "How does defining a @Bean method as static affect its execution?"
    answers:
      - option: "It causes the method to be executed at the time of class loading, ensuring it's processed before non-static beans."
        correct: true
      - option: "Static @Bean methods are executed after all non-static beans are created."
        correct: false
      - option: "Static methods are ignored by the Spring container."
        correct: false
      - option: "It makes the bean globally accessible without an instance of the container."
        correct: false

  - description: "What ensures that a BeanFactoryPostProcessor runs before other beans are fully initialized?"
    answers:
      - option: "Its operation is hard-coded into the Spring container lifecycle to execute after bean definitions are loaded but before any bean instantiation."
        correct: true
      - option: "The @Order annotation defining the sequence of execution."
        correct: false
      - option: "The static nature of its declaration in a configuration class."
        correct: false
      - option: "Manual invocation within the application's main method."
        correct: false

  - description: "Why is PropertySourcesPlaceholderConfigurer considered a BeanFactoryPostProcessor?"
    answers:
      - option: "Because it modifies bean definitions to resolve property placeholders before beans are instantiated."
        correct: true
      - option: "It directly instantiates beans with properties defined in property files."
        correct: false
      - option: "It post-processes beans after instantiation to inject property values."
        correct: false
      - option: "It is not a BeanFactoryPostProcessor but a BeanPostProcessor."
        correct: false

  - description: "In what scenario would you utilize a BeanFactoryPostProcessor?"
    answers:
      - option: "When needing to read or modify the configuration metadata of beans before the Spring container instantiates them."
        correct: true
      - option: "For post-processing beans immediately after they are instantiated."
        correct: false
      - option: "To define transaction management across Spring beans."
        correct: false
      - option: "For dynamically registering beans at runtime after the application context is initialized."
        correct: false

  - description: "What functionality does the static @Bean method provide in context with BeanFactoryPostProcessor?"
    answers:
      - option: "It ensures the early instantiation of BeanFactoryPostProcessor beans to allow modification of bean definitions before other beans are instantiated."
        correct: true
      - option: "Static methods provide a mechanism for lazy instantiation of beans."
        correct: false
      - option: "They are used to define the order in which beans are instantiated."
        correct: false
      - option: "Static @Bean methods are used for defining bean post-processors."
        correct: false
  - description: "What is the primary difference between BeanFactoryPostProcessor and BeanPostProcessor in Spring?"
    answers:
      - option: "BeanFactoryPostProcessor operates on bean configuration metadata before the bean is instantiated, while BeanPostProcessor modifies bean instances before and after initialization."
        correct: true
      - option: "BeanFactoryPostProcessor modifies bean instances, whereas BeanPostProcessor operates on bean configuration metadata."
        correct: false
      - option: "BeanFactoryPostProcessor is only called once per application context refresh, while BeanPostProcessor is called for each bean instance."
        correct: false
      - option: "There is no significant difference; both serve the same purpose."
        correct: false

  - description: "When is BeanFactoryPostProcessor invoked during the Spring bean lifecycle?"
    answers:
      - option: "Before any bean instances are created."
        correct: true
      - option: "After all bean instances are created but before they are initialized."
        correct: false
      - option: "Immediately after each bean instance is created."
        correct: false
      - option: "At the end of the application context initialization."
        correct: false

  - description: "What are the two main methods of a BeanPostProcessor, and when are they called?"
    answers:
      - option: "postProcessBeforeInitialization (before bean initialization) and postProcessAfterInitialization (after bean initialization)."
        correct: true
      - option: "preProcessBeforeDestruction (before bean destruction) and postProcessAfterDestruction (after bean destruction)."
        correct: false
      - option: "beforeBeanFactoryPostProcess (before BeanFactoryPostProcessor) and afterBeanFactoryPostProcess (after BeanFactoryPostProcessor)."
        correct: false
      - option: "initializeBean (before bean initialization) and destroyBean (after bean initialization)."
        correct: false

  - description: "How can you declare an initialization method for a Spring bean? (select 2)"
    answers:
      - option: "Using @PostConstruct annotation."
        correct: true
      - option: "Specifying init-method attribute in the @Bean annotation."
        correct: true
      - option: "Using @PreDestroy annotation as an initializer."
        correct: false
      - option: "Declaring the method as static."
        correct: false
      - option: "Implementing the InitializingBean interface and overriding afterPropertiesSet method."
        correct: true

  - description: "Which annotation enables JSR-250 annotations like @PostConstruct and @PreDestroy in Spring?"
    answers:
      - option: "No specific annotation is required; they are supported by default in Spring."
        correct: true
      - option: "@EnableJSR250Annotations"
        correct: false
      - option: "@Component"
        correct: false
      - option: "@Configuration"
        correct: false

  - description: "When and how is a destroy method called for a Spring bean?"
    answers:
      - option: "Using @PreDestroy annotation or specifying destroy-method attribute in the @Bean annotation."
        correct: true
      - option: "Automatically by the garbage collector when the bean is no longer referenced."
        correct: false
      - option: "By manually invoking the destroy method from the bean instance."
        correct: false
      - option: "Destroy methods are not supported in Spring."
        correct: false

  - description: "What allows BeanPostProcessors to modify bean instances before and after initialization?"
    answers:
      - option: "Implementing postProcessBeforeInitialization and postProcessAfterInitialization methods."
        correct: true
      - option: "They directly modify the bean instance fields."
        correct: false
      - option: "By defining custom annotations on the bean class."
        correct: false
      - option: "Using AOP aspects around the bean instantiation logic."
        correct: false

  - description: "How do you ensure that BeanPostProcessors are registered before any other beans in the Spring container?"
    answers:
      - option: "By defining their beans as static in the configuration class."
        correct: true
      - option: "Using the @Priority annotation to specify order."
        correct: false
      - option: "Registering them manually with the ApplicationContext before refresh."
        correct: false
      - option: "Spring automatically detects and registers BeanPostProcessors first."
        correct: false

  - description: "What is an initialization method in the context of a Spring bean?"
    answers:
      - option: "A method that is called after a bean is fully constructed, with all its dependencies injected."
        correct: true
      - option: "A method that initializes the Spring ApplicationContext."
        correct: false
      - option: "The constructor of the bean class."
        correct: false
      - option: "A method called before the bean is constructed to set default values."
        correct: false

  - description: "In what scenario might you use a BeanFactoryPostProcessor over a BeanPostProcessor?"
    answers:
      - option: "When needing to modify bean configuration metadata before beans are instantiated."
        correct: true
      - option: "To inject dependencies into bean instances."
        correct: false
      - option: "For modifying bean instances after they are fully initialized."
        correct: false
      - option: "BeanFactoryPostProcessor is not recommended for use in modern Spring applications."
        correct: false
  - description: "What is the primary use of the @Value annotation in Spring?"
    answers:
      - option: "To inject literal values, environment variables, and properties into beans."
        correct: true
      - option: "To define bean scopes."
        correct: false
      - option: "To create bean definitions."
        correct: false
      - option: "To specify bean destruction methods."
        correct: false

  - description: "How can the @Value annotation inject environment variables into a Spring bean property?"
    answers:
      - option: "@Value(\"${envVariable}\")"
        correct: true
      - option: "@Value(\"envVariable\")"
        correct: false
      - option: "@Value(\"#envVariable\")"
        correct: false
      - option: "@Value(\"&envVariable\")"
        correct: false

  - description: "Which of the following is a correct use of the @Value annotation for injecting a Spring bean property with a default value?"
    answers:
      - option: "@Value(\"${property.name:default}\") provides a default value if property.name is not defined."
        correct: true
      - option: "Injecting a collection type directly without using SpEL."
        correct: false
      - option: "Direct injection of method return values."
        correct: false
      - option: "@Value without specifying a property or literal."
        correct: false
      - option: "Using @Value to annotate bean creation methods."
        correct: false
  - description: "What capability does BeanFactoryPostProcessor provide in Spring?"
    answers:
      - option: "It allows modification of bean definitions before the bean object is created."
        correct: true
      - option: "It injects dependencies into beans."
        correct: false
      - option: "It creates bean instances."
        correct: false
      - option: "It manages transactions for beans."
        correct: false

  - description: "How does BeanPostProcessor differ from BeanFactoryPostProcessor in its functionality?"
    answers:
      - option: "BeanPostProcessor allows modification of bean objects before and after they are initialized."
        correct: true
      - option: "It modifies bean definitions after bean objects are created."
        correct: false
      - option: "There is no functional difference; they are used interchangeably."
        correct: false
      - option: "BeanPostProcessor is used exclusively for XML-based bean definitions."
        correct: false

  - description: "At which point in the bean lifecycle does BeanFactoryPostProcessor intervene?"
    answers:
      - option: "Before the bean object is created."
        correct: true
      - option: "After the bean object is fully initialized and ready for use."
        correct: false
      - option: "Immediately after the constructor is called but before properties are set."
        correct: false
      - option: "During the destruction phase of the bean lifecycle."
        correct: false
  - description: "What is the main purpose of BeanFactoryPostProcessor in Spring?"
    answers:
      - option: "To modify bean definitions before the bean object is created."
        correct: true
      - option: "To inject dependencies into bean objects."
        correct: false
      - option: "To create bean instances."
        correct: false
      - option: "To manage transactional behavior of beans."
        correct: false

  - description: "How does BeanPostProcessor differ from BeanFactoryPostProcessor?"
    answers:
      - option: "BeanPostProcessor allows modifications to bean objects before and after they are initialized, while BeanFactoryPostProcessor modifies bean definitions before instantiation."
        correct: true
      - option: "BeanPostProcessor modifies bean definitions, whereas BeanFactoryPostProcessor modifies bean instances."
        correct: false
      - option: "They perform the same functions but are invoked at different times."
        correct: false
      - option: "BeanPostProcessor is used for XML-based bean definitions only."
        correct: false

  - description: "When is the BeanFactoryPostProcessor invoked?"
    answers:
      - option: "After the bean definition is created but before the bean object is instantiated."
        correct: true
      - option: "After bean objects are instantiated but before dependencies are injected."
        correct: false
      - option: "Immediately after each bean instance is created."
        correct: false
      - option: "During the destruction phase of the bean lifecycle."
        correct: false

  - description: "What does BeanPostProcessor allow you to do? (select 2)"
    answers:
      - option: "Modify bean objects before they are initialized."
        correct: true
      - option: "Modify bean objects after they are initialized."
        correct: true
      - option: "Create bean instances."
        correct: false
      - option: "Inject dependencies into bean objects."
        correct: false
      - option: "Modify bean definitions."
        correct: false

  - description: "What is initialization method in the context of a Spring bean?"
    answers:
      - option: "A method that is called to modify the bean after it is constructed and all properties have been set."
        correct: true
      - option: "A method used to instantiate bean objects."
        correct: false
      - option: "A method that initializes the Spring ApplicationContext."
        correct: false
      - option: "The constructor of the bean class."
        correct: false

  - description: "How is a destroy method declared for a Spring bean?"
    answers:
      - option: "By using the @PreDestroy annotation or specifying a destroy-method attribute in the bean definition."
        correct: true
      - option: "Destroy methods are automatically inferred by Spring."
        correct: false
      - option: "Using the @PostConstruct annotation with a special parameter."
        correct: false
      - option: "By implementing the DisposableBean interface."
        correct: false

  - description: "How are JSR-250 annotations like @PostConstruct and @PreDestroy enabled in Spring?"
    answers:
      - option: "They are enabled by default in the Spring ApplicationContext."
        correct: true
      - option: "By annotating the configuration class with @EnableJSR250Annotations."
        correct: false
      - option: "By manually registering them as bean post-processors."
        correct: false
      - option: "Through XML configuration in the Spring context file."
        correct: false

  - description: "When are methods annotated with @PreDestroy called?"
    answers:
      - option: "Before the bean is destroyed and the ApplicationContext is closed."
        correct: true
      - option: "Immediately after the bean is instantiated."
        correct: false
      - option: "Before the bean properties are set."
        correct: false
      - option: "After the ApplicationContext is refreshed."
        correct: false
  - description: "What is the Environment abstraction in Spring primarily used for?"
    answers:
      - option: "Resolving properties and listing profiles."
        correct: true
      - option: "Defining bean scopes."
        correct: false
      - option: "Instantiating bean definitions."
        correct: false
      - option: "Managing bean lifecycle events."
        correct: false

  - description: "How can you obtain the Environment interface in a Spring application?"
    answers:
      - option: "By calling the getEnvironment() method on ApplicationContext."
        correct: true
      - option: "Using the @Autowired annotation."
        correct: false
      - option: "Direct instantiation of the Environment class."
        correct: false
      - option: "Environment beans cannot be obtained directly; they are auto-configured by Spring."
        correct: false

  - description: "Which method on the Environment interface is used to get the value of a property?"
    answers:
      - option: "getProperty(String key)"
        correct: true
      - option: "getValue(String key)"
        correct: false
      - option: "resolveProperty(String key)"
        correct: false
      - option: "findProperty(String key)"
        correct: false

  - description: "From where can properties be loaded into the Spring environment? (select 3)"
    answers:
      - option: "System environment variables"
        correct: true
      - option: "JVM system properties"
        correct: true
      - option: "Property files"
        correct: true
      - option: "Database records"
        correct: false
      - option: "Annotations in the code"
        correct: false

  - description: "What is the role of @PropertySource in Spring?"
    answers:
      - option: "It is used to define property sources for the application."
        correct: true
      - option: "It dynamically changes the properties at runtime."
        correct: false
      - option: "It creates new Environment instances."
        correct: false
      - option: "It serves as a placeholder for injecting properties."
        correct: false

  - description: "How are active profiles determined in Spring?"
    answers:
      - option: "Through the Environment interface, using methods like getActiveProfiles()."
        correct: true
      - option: "By scanning the application for @ActiveProfile annotations."
        correct: false
      - option: "Active profiles are set in the main configuration file only."
        correct: false
      - option: "Using the @Profile annotation on configuration classes."
        correct: false

  - description: "Which annotation can be used alongside @Value to inject property values?"
    answers:
      - option: "No specific annotation is needed alongside @Value for property injection."
        correct: true
      - option: "@InjectProperty"
        correct: false
      - option: "@EnvironmentProperty"
        correct: false
      - option: "@PropertyInject"
        correct: false

  - description: "What advantage does the Environment abstraction provide regarding profiles?"
    answers:
      - option: "It allows easy observation of which profiles are active and which are default."
        correct: true
      - option: "It automatically activates profiles based on the application's runtime environment."
        correct: false
      - option: "It generates profiles based on the properties defined in the application."
        correct: false
      - option: "Profiles have to be manually defined and activated outside of the Environment abstraction."
        correct: false
  - description: "What is the purpose of an initialization method in a Spring bean?"
    answers:
      - option: "To perform custom modifications on the bean after it has been constructed and its dependencies injected."
        correct: true
      - option: "To define how a bean is constructed and its constructor is called."
        correct: false
      - option: "To inject dependencies and properties into the bean."
        correct: false
      - option: "To destroy the bean before it is removed from the Spring context."
        correct: false

  - description: "When is an initialization method called during the bean lifecycle?"
    answers:
      - option: "After the bean is constructed, dependencies are injected, and just after BeanPostProcessor's postProcessAfterInitialization method."
        correct: true
      - option: "Before the bean constructor is called."
        correct: false
      - option: "Immediately after the bean constructor is called but before any properties are set."
        correct: false
      - option: "At the end of the bean lifecycle, just before the bean is destroyed."
        correct: false

  - description: "Which of the following correctly describes an initialization method's execution context? (select 2)"
    answers:
      - option: "It allows for final modifications before the bean is put into service."
        correct: true
      - option: "It is invoked after beanPostProcessorAfterInitialization to finalize bean setup."
        correct: true
      - option: "It configures the bean's environment before any properties are injected."
        correct: false
      - option: "It replaces the need for a constructor in Spring beans."
        correct: false
      - option: "It is used to initiate the ApplicationContext that the bean belongs to."
        correct: false

  - description: "What does defining an initialization method in a Spring bean class enable?"
    answers:
      - option: "Custom behavior to modify the bean after its properties have been set but before it's used in the application."
        correct: true
      - option: "An alternative way to construct bean instances without using a constructor."
        correct: false
      - option: "A mechanism to inject dependencies, bypassing the standard autowiring."
        correct: false
      - option: "Direct control over the bean's lifecycle, including its destruction."
        correct: false

  - description: "How can an initialization method enhance the configuration of a Spring bean?"
    answers:
      - option: "By allowing for custom setup that is not possible through constructor injection or property setting alone."
        correct: true
      - option: "It can dynamically alter the bean's scope at runtime."
        correct: false
      - option: "It serves as the primary method for dependency injection."
        correct: false
      - option: "Initialization methods are primarily used for bean identification purposes."
        correct: false
  - description: "What are valid property sources for a standalone Spring application? (select 3)"
    answers:
      - option: "System environment variables"
        correct: true
      - option: "JVM parameters"
        correct: true
      - option: "Property files using @PropertySource annotation in configuration class"
        correct: true
      - option: "Servlet context init parameters"
        correct: false
      - option: "JNDI"
        correct: false

  - description: "How are property sources specified in a Spring application?"
    answers:
      - option: "Using the @PropertySource annotation in a configuration class."
        correct: true
      - option: "Directly in the @Component annotation."
        correct: false
      - option: "Within the application.properties file without any additional annotations."
        correct: false
      - option: "By implementing the PropertySource interface in any class."
        correct: false

  - description: "What additional property sources are available in a Spring application running within a servlet container? (select 2)"
    answers:
      - option: "Servlet context init parameters"
        correct: true
      - option: "ServletConfig init parameters"
        correct: true
      - option: "Properties defined in a .env file at the root of the application"
        correct: false
      - option: "Annotations in the application code"
        correct: false
      - option: "YAML files located outside the JAR"
        correct: false

  - description: "Where does the @Value annotation search for the property 'app.vm.property'?"
    answers:
      - option: "JVM parameters"
        correct: true
      - option: "System environment variables"
        correct: false
      - option: "Property files specified with @PropertySource"
        correct: false
      - option: "Servlet context init parameters"
        correct: false

  - description: "What does the @PropertySource annotation do in a Spring configuration class?"
    answers:
      - option: "It defines the location of property files to be used as property sources."
        correct: true
      - option: "It directly injects properties into bean fields."
        correct: false
      - option: "It generates new properties at runtime."
        correct: false
      - option: "It scans for property files in the classpath automatically."
        correct: false

  - description: "Which of the following correctly injects the value of the 'JAVA_HOME' system environment variable into a Spring bean?"
    answers:
      - option: "@Value(\"${JAVA_HOME}\")"
        correct: true
      - option: "@Value(\"#JAVA_HOME\")"
        correct: false
      - option: "@Environment(\"JAVA_HOME\")"
        correct: false
      - option: "@PropertySource(\"JAVA_HOME\")"
        correct: false

  - description: "For a web application running in a servlet container, from which sources can properties be obtained? (select 2)"
    answers:
      - option: "Servlet context init parameters"
        correct: true
      - option: "ServletConfig init parameters"
        correct: true
      - option: "Directly from the HTTP request headers"
        correct: false
      - option: "Annotations within the controller classes"
        correct: false
      - option: "External YAML configuration files"
        correct: false

  - description: "In the context of property sources, what functionality does @Configuration provide in a Spring application?"
    answers:
      - option: "It marks a class as a source of bean definitions and @PropertySource annotations."
        correct: true
      - option: "It automatically generates property files based on the application's needs."
        correct: false
      - option: "It is used to directly inject properties into beans without needing @Value."
        correct: false
      - option: "It defines the default property values for the entire application."
        correct: false
  - description: "What are the three methods to define an initialization method in a Spring Bean?"
    answers:
      - option: "Using @PostConstruct annotation, implementing InitializingBean interface, specifying init-method in @Bean annotation."
        correct: true
      - option: "Using @Autowired annotation, implementing BeanFactoryAware interface, specifying destroy-method in @Bean annotation."
        correct: false
      - option: "Implementing ApplicationContextAware interface, using @PreDestroy annotation, and using @Value annotation."
        correct: false
      - option: "Using @Qualifier annotation, implementing DisposableBean interface, and specifying init-method in XML configuration."
        correct: false

  - description: "When does the initialization method get called in the Spring Bean lifecycle?"
    answers:
      - option: "After the bean is instantiated and dependencies are injected but before it's fully initialized."
        correct: true
      - option: "Immediately after the bean definition is registered."
        correct: false
      - option: "Before any bean instances are created."
        correct: false
      - option: "After the application context is refreshed."
        correct: false

  - description: "What role does @PostConstruct annotation play in a Spring Bean's lifecycle?"
    answers:
      - option: "It marks a method to be called after the bean is initialized but before it is put into use."
        correct: true
      - option: "It designates a method to run immediately after the bean constructor is called."
        correct: false
      - option: "It specifies a method to be invoked right before the bean's destruction."
        correct: false
      - option: "It is used to inject dependencies into the bean."
        correct: false

  - description: "What is the purpose of the afterPropertiesSet() method in Spring?"
    answers:
      - option: "It provides a way to perform actions after properties are set, specifically for beans implementing InitializingBean."
        correct: true
      - option: "It's a method used to set properties on the bean instance."
        correct: false
      - option: "It initializes the bean's properties before injection."
        correct: false
      - option: "It cleans up resources before a bean is destroyed."
        correct: false

  - description: "How is the init-method specified in a Spring Bean?"
    answers:
      - option: "By defining it within the @Bean annotation in a configuration class."
        correct: true
      - option: "Directly within the bean class using the @InitMethod annotation."
        correct: false
      - option: "Using the @PostConstruct annotation on the method."
        correct: false
      - option: "By implementing a specific interface in the bean class."
        correct: false

  - description: "Which interface do you implement to use the afterPropertiesSet method for initialization?"
    answers:
      - option: "InitializingBean"
        correct: true
      - option: "DisposableBean"
        correct: false
      - option: "ApplicationContextAware"
        correct: false
      - option: "BeanFactoryAware"
        correct: false

  - description: "Can the @PostConstruct annotation be used for initialization in Spring beans? (select 2)"
    answers:
      - option: "Yes, it marks a method to run after dependencies are injected."
        correct: true
      - option: "Yes, it's supported by default in Spring and does not require additional configuration."
        correct: true
      - option: "No, it is only used for destruction purposes."
        correct: false
      - option: "No, it requires explicit configuration in XML files."
        correct: false
      - option: "Yes, but it must be combined with the @PreDestroy annotation for it to work."
        correct: false

  - description: "What ensures an initialization method runs after all dependencies are injected in Spring?"
    answers:
      - option: "Implementing InitializingBean, using @PostConstruct, or specifying init-method."
        correct: true
      - option: "Placing the initialization logic in the bean constructor."
        correct: false
      - option: "Using @Autowired on the initialization method."
        correct: false
      - option: "Implementing BeanFactoryAware and calling the initialization method manually."
        correct: false
  - description: "What is the purpose of a destroy method in Spring?"
    answers:
      - option: "To execute custom code before a bean is destroyed."
        correct: true
      - option: "To initialize bean properties during bean creation."
        correct: false
      - option: "To inject dependencies into the bean."
        correct: false
      - option: "To define bean scopes."
        correct: false

  - description: "How can you define a destroy method in a Spring application? (select 3)"
    answers:
      - option: "Using the @PreDestroy annotation."
        correct: true
      - option: "Implementing the DisposableBean interface and its destroy method."
        correct: true
      - option: "Specifying a destroy-method attribute in the @Bean annotation."
        correct: true
      - option: "Using the @PostConstruct annotation."
        correct: false
      - option: "Implementing the InitializingBean interface."
        correct: false

  - description: "When are destroy methods called in a Spring application?"
    answers:
      - option: "When the ApplicationContext is closed."
        correct: true
      - option: "Immediately after bean instantiation."
        correct: false
      - option: "Before bean properties are set."
        correct: false
      - option: "During bean post-processing after initialization."
        correct: false

  - description: "What triggers the closure of an ApplicationContext in a typical Spring application?"
    answers:
      - option: "Implementing a registerShutdownHook or calling the close() method."
        correct: true
      - option: "The destruction of all beans in the application context."
        correct: false
      - option: "Automatically when a bean is removed from the context."
        correct: false
      - option: "After a fixed duration since the context's initialization."
        correct: false

  - description: "Which interface do you need to implement for a bean to execute custom destroy logic?"
    answers:
      - option: "DisposableBean"
        correct: true
      - option: "InitializingBean"
        correct: false
      - option: "ApplicationContextAware"
        correct: false
      - option: "BeanFactoryAware"
        correct: false

  - description: "In web applications, when is the ApplicationContext typically closed?"
    answers:
      - option: "When the web container is shut down or the application is undeploy."
        correct: true
      - option: "After every HTTP request is processed."
        correct: false
      - option: "Before a new HTTP request is received."
        correct: false
      - option: "Automatically every 24 hours for cleanup."
        correct: false

  - description: "Which of the following is a valid way to use a try-with-resources block with an ApplicationContext?"
    answers:
      - option: "By using AnnotationConfigApplicationContext which is AutoCloseable."
        correct: true
      - option: "With any ApplicationContext implementation since all are AutoCloseable."
        correct: false
      - option: "Try-with-resources cannot be used with ApplicationContext."
        correct: false
      - option: "Only when explicitly implementing the AutoCloseable interface."
        correct: false

  - description: "What does implementing the DisposableBean interface allow a bean to do?"
    answers:
      - option: "It provides a standard method to clean up resources before the bean is destroyed."
        correct: true
      - option: "It enables the bean to be aware of its BeanFactory."
        correct: false
      - option: "Allows the bean to perform initialization logic."
        correct: false
      - option: "It automatically registers the bean for destruction on context close."
        correct: false
  - description: "What is a method of destruction in Spring, and when is it called?"
    answers:
      - option: "A method that allows you to run specific code before a bean is destroyed, called when the ApplicationContext is closed."
        correct: true
      - option: "A method to initialize bean properties before the bean is used."
        correct: false
      - option: "A static method that cleans up resources before application shutdown."
        correct: false
      - option: "A constructor method that is called before a bean is instantiated."
        correct: false

  - description: "How can the ApplicationContext be closed? (select 3)"
    answers:
      - option: "Using a try-with-resources block, as AnnotationConfigApplicationContext is AutoCloseable."
        correct: true
      - option: "Registering a shutdown hook with the ApplicationContext."
        correct: true
      - option: "Calling the close() method on the ApplicationContext."
        correct: true
      - option: "Automatically upon garbage collection."
        correct: false
      - option: "When the @PreDestroy method is called."
        correct: false

  - description: "Which methods can be used to define a destruction method in Spring? (select 3)"
    answers:
      - option: "Using the @PreDestroy annotation."
        correct: true
      - option: "Implementing the DisposableBean interface and its destroy method."
        correct: true
      - option: "Specifying a custom destroyMethod in the @Bean annotation."
        correct: true
      - option: "Using the @PostConstruct annotation for destruction."
        correct: false
      - option: "Implementing the InitializingBean interface for destruction."
        correct: false

  - description: "What triggers the execution of destruction methods in a web application context?"
    answers:
      - option: "When the web container is shut down or undeploy."
        correct: true
      - option: "After each HTTP request is processed."
        correct: false
      - option: "Before the ApplicationContext is refreshed."
        correct: false
      - option: "During bean instantiation."
        correct: false

  - description: "What is the recommended way to close an ApplicationContext in a standalone application?"
    answers:
      - option: "Using a try-with-resources block or registering a shutdown hook."
        correct: true
      - option: "Invoking the destroy() method on each bean manually."
        correct: false
      - option: "Letting the JVM shutdown process handle it."
        correct: false
      - option: "Using the ApplicationContext's refresh() method."
        correct: false

  - description: "Which of the following is true about the @PreDestroy annotation?"
    answers:
      - option: "It marks a method to be called before the bean is removed from the ApplicationContext."
        correct: true
      - option: "It is called immediately after the bean is instantiated."
        correct: false
      - option: "It can be applied to multiple methods within the same bean."
        correct: false
      - option: "It is used to initialize bean properties."
        correct: false

  - description: "What is the role of the DisposableBean interface in Spring?"
    answers:
      - option: "It provides a callback method, destroy(), that is called when a bean is about to be removed from the ApplicationContext."
        correct: true
      - option: "It is used to inject dependencies into Spring beans."
        correct: false
      - option: "It defines initialization logic that is executed after bean properties are set."
        correct: false
      - option: "It is responsible for creating bean instances during context initialization."
        correct: false

  - description: "What happens when you specify a destroyMethod in the @Bean annotation?"
    answers:
      - option: "Spring calls the specified method to perform cleanup actions before the bean is destroyed."
        correct: true
      - option: "The method is ignored, as Spring does not support custom destroy methods."
        correct: false
      - option: "It acts as an initialization method, not a destruction method."
        correct: false
      - option: "The method is called immediately after the bean is instantiated."
        correct: false
  - description: "What are the main reasons to use @Qualifier annotation in Spring? (select 2)"
    answers:
      - option: "To specify which bean to inject when multiple beans of the same type are present."
        correct: true
      - option: "To create a new bean instance specifically for the current context."
        correct: false
      - option: "To improve the performance of the application by reducing the ambiguity among beans."
        correct: false
      - option: "To define a specific behavior for a bean during its initialization phase."
        correct: false
      - option: "To resolve the ambiguity when multiple beans qualify for autowiring."
        correct: true
  - description: "Which of the following are true regarding the use of @Primary annotation in Spring? (select 2)"
    answers:
      - option: "It indicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency."
        correct: true
      - option: "It is used to generate primary beans automatically without configuration."
        correct: false
      - option: "It helps in identifying the main bean among multiple beans for dependency injection."
        correct: true
      - option: "It replaces the functionality of @Qualifier annotation completely."
        correct: false
      - option: "It can only be applied to beans defined in XML configuration files."
        correct: false
  - description: "What role does @Primary play in Spring's autowiring mechanism?"
    answers:
      - option: "It designates a bean as the primary candidate for autowiring when multiple beans exist for a single dependency."
        correct: true
      - option: "It is used to mark a bean as secondary or backup in case the primary bean fails."
        correct: false
      - option: "It explicitly specifies the constructor to use for autowiring."
        correct: false
      - option: "It creates a proxy bean to handle all autowiring-related tasks."
        correct: false
      - option: "It assigns a higher priority to a bean during component scanning."
        correct: false
  - description: "In Spring, when is it recommended to use @Qualifier annotation?"
    answers:
      - option: "When there is a need to control the specific bean to be injected among several available beans."
        correct: true
      - option: "To forcibly create a singleton bean even if the scope is set to prototype."
        correct: false
      - option: "To enhance the injection process by automatically selecting the most recent bean."
        correct: false
      - option: "As a primary method to generate bean definitions dynamically."
        correct: false
  - description: "How does the @Primary annotation assist in resolving conflicts during autowiring?"
    answers:
      - option: "By marking a bean as the preferred choice when multiple beans are eligible for autowiring."
        correct: true
      - option: "It forces Spring to use a specific bean, ignoring any @Qualifier annotations."
        correct: false
      - option: "By creating a proxy class that decides at runtime which bean to inject."
        correct: false
      - option: "It increases the loading priority of a bean so it's injected before others."
        correct: false
  - description: "What is the default status of JSR-250 annotations like @PostConstruct and @PreDestroy in Spring?"
    answers:
      - option: "Enabled by default when using annotations."
        correct: true
      - option: "Disabled and require explicit activation."
        correct: false
      - option: "Only enabled in XML configuration."
        correct: false
      - option: "Enabled only when specifically configured in Java Config."
        correct: false
      - option: "Available but deprecated in the latest Spring version."
        correct: false
  - description: "Which annotations are automatically enabled in Spring for bean lifecycle callbacks? (select 2)"
    answers:
      - option: "@PostConstruct"
        correct: true
      - option: "@Bean"
        correct: false
      - option: "@PreDestroy"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Component"
        correct: false
  - description: "For enabling JSR-250 annotations like @PostConstruct and @PreDestroy, what is required in Spring?"
    answers:
      - option: "No explicit configuration; they are enabled by default."
        correct: true
      - option: "An <annotation-config/> element in XML configuration."
        correct: false
      - option: "A @EnableLifecycleAnnotations annotation in your configuration."
        correct: false
      - option: "Implementation of InitializingBean and DisposableBean interfaces."
        correct: false
      - option: "Adding dependency to spring-context-annotations library."
        correct: false
  - description: "What functionality does the @PostConstruct annotation provide in a Spring application?"
    answers:
      - option: "It marks a method to be executed after dependency injection is complete."
        correct: true
      - option: "It designates a method to run before the bean is destroyed."
        correct: false
      - option: "It indicates the method to be used for creating bean instances."
        correct: false
      - option: "It specifies a custom scope for the Spring bean."
        correct: false
  - description: "How does the @PreDestroy annotation enhance a bean's lifecycle management in Spring?"
    answers:
      - option: "By defining a method to execute before the bean is removed from the container."
        correct: true
      - option: "It indicates the initial method to run upon bean instantiation."
        correct: false
      - option: "By specifying a custom destruction callback interface."
        correct: false
      - option: "It forces the bean to be a prototype scoped bean."
        correct: false
  - description: "What are the main advantages of using @Autowired in Spring? (select 2)"
    answers:
      - option: "It allows for automatic dependency injection, simplifying configuration."
        correct: true
      - option: "Enables tight coupling between beans for more efficient code."
        correct: false
      - option: "Supports both field and constructor injection, providing flexibility."
        correct: true
      - option: "Automatically generates bean definitions based on the classpath."
        correct: false
      - option: "Increases the load time of the application by optimizing bean instantiation."
        correct: false
  - description: "Which types of autowiring does Spring support? (select 2)"
    answers:
      - option: "By type"
        correct: true
      - option: "By XML configuration"
        correct: false
      - option: "By name"
        correct: true
      - option: "By annotation"
        correct: false
      - option: "By constructor"
        correct: true
  - description: "How does @Autowired improve application development in Spring?"
    answers:
      - option: "Reduces boilerplate code for bean configuration."
        correct: true
      - option: "Eliminates the need for setter or constructor injection."
        correct: false
      - option: "Directly links the application context to the Java code."
        correct: false
      - option: "Forces the application to use XML-based configuration."
        correct: false
      - option: "Automatically detects and resolves circular dependencies."
        correct: false
  - description: "In Spring, what happens if @Autowired cannot find a matching bean?"
    answers:
      - option: "It throws a NoSuchBeanDefinitionException."
        correct: true
      - option: "It creates a new bean instance automatically."
        correct: false
      - option: "The application context initialization fails."
        correct: false
      - option: "It falls back to using a default bean if available."
        correct: false
  - description: "What is the role of @Qualifier annotation when used with @Autowired?"
    answers:
      - option: "It specifies which bean to autowire when there are multiple candidates."
        correct: true
      - option: "It creates a new bean instance for the autowiring process."
        correct: false
      - option: "It increases the priority of a bean during autowiring."
        correct: false
      - option: "It disables autowiring for the specified bean."
        correct: false
  - description: "What is the correct order of method calls in a typical Spring Bean lifecycle?"
    answers:
      - option: "@PostConstruct annotated methods, then afterPropertiesSet() from InitializingBean."
        correct: true
      - option: "Methods annotated with @PreDestroy, followed by destroy() from DisposableBean."
        correct: false
      - option: "The destroy() method of DisposableBean, followed by @PreDestroy annotated methods."
        correct: false
      - option: "@PreDestroy annotated methods, then beforePropertiesSet() from InitializingBean."
        correct: false
      - option: "Custom init-method definitions, followed by @PostConstruct annotated methods."
        correct: false
  - description: "Which methods are called when a Spring Bean is being destroyed? (select 2)"
    answers:
      - option: "Custom destroy-method."
        correct: true
      - option: "Methods annotated with @PreDestroy."
        correct: true
      - option: "@PostConstruct annotated methods."
        correct: false
      - option: "afterPropertiesSet() method from InitializingBean."
        correct: false
      - option: "beforePropertiesSet() method from InitializingBean."
        correct: false
  - description: "In the Spring Bean lifecycle, what role does the afterPropertiesSet() method from the InitializingBean interface play?"
    answers:
      - option: "It is called after all bean properties have been set."
        correct: true
      - option: "It initializes bean properties before dependency injection."
        correct: false
      - option: "It cleans up resources before a bean is destroyed."
        correct: false
      - option: "It is used to set properties on beans marked as @PreDestroy."
        correct: false
      - option: "It is automatically generated by the Spring framework to manage bean lifecycle."
        correct: false
  - description: "What is the significance of the @PreDestroy annotation in a Spring application?"
    answers:
      - option: "Marks a method to be called just before a bean is removed from the Spring context."
        correct: true
      - option: "Indicates a method to automatically inject dependencies before bean destruction."
        correct: false
      - option: "Specifies initialization logic that should run right after bean creation."
        correct: false
      - option: "Configures additional properties not set during the initial bean creation process."
        correct: false
  - description: "How does Spring ensure that a bean is fully initialized before calling its @PostConstruct annotated methods?"
    answers:
      - option: "By completing the injection of all required dependencies first."
        correct: true
      - option: "Through explicit configuration in the Spring XML file or Java Config."
        correct: false
      - option: "By waiting for all beans in the context to be created before any @PostConstruct methods are called."
        correct: false
      - option: "By invoking custom init-methods defined in the bean configuration prior to @PostConstruct methods."
        correct: false
  - description: "What is the correct order of a Spring Bean's lifecycle phases?"
    answers:
      - option: "Bean instantiation, Populate properties, @PostConstruct, afterPropertiesSet(), custom init-method, Bean ready for use, custom destroy-method, @PreDestroy, destroy()."
        correct: true
      - option: "@PostConstruct, Bean instantiation, Populate properties, afterPropertiesSet(), custom init-method, Bean ready for use, @PreDestroy, custom destroy-method, destroy()."
        correct: false
      - option: "Bean instantiation, @PostConstruct, Populate properties, custom init-method, afterPropertiesSet(), Bean ready for use, destroy(), custom destroy-method, @PreDestroy."
        correct: false
      - option: "Populate properties, Bean instantiation, afterPropertiesSet(), @PostConstruct, custom init-method, Bean ready for use, @PreDestroy, destroy(), custom destroy-method."
        correct: false
      - option: "Bean instantiation, Populate properties, custom init-method, @PostConstruct, afterPropertiesSet(), Bean ready for use, @PreDestroy, destroy(), custom destroy-method."
        correct: false
  - description: "What is the purpose of Component Scanning in Spring?"
    answers:
      - option: "To discover classes annotated with stereotypes like @Controller, @Service, @Repository, and @Component."
        correct: true
      - option: "To enhance the performance of Spring applications by reducing startup time."
        correct: false
      - option: "To automatically generate bean definitions from XML configuration files."
        correct: false
      - option: "To manually define beans in the Spring application context."
        correct: false

  - description: "Which annotations are detected by Spring's Component Scanning feature? (select 2)"
    answers:
      - option: "@Controller"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Service"
        correct: true
      - option: "@Configuration"
        correct: false
      - option: "@Entity"
        correct: false

  - description: "What are the stereotypes that can be used with Spring's Component Scanning? (select 2)"
    answers:
      - option: "@Repository"
        correct: true
      - option: "@Inject"
        correct: false
      - option: "@Component"
        correct: true
      - option: "@Qualifier"
        correct: false
      - option: "@Aspect"
        correct: false

  - description: "How does Spring's Component Scanning support the configuration of beans?"
    answers:
      - option: "By automatically registering beans annotated with @Component, @Service, @Repository, or @Controller."
        correct: true
      - option: "It requires explicit bean definitions in an XML file for scanning to work."
        correct: false
      - option: "Component Scanning only works with Java Config and not with annotations."
        correct: false
      - option: "Scanning is performed only at runtime, not at startup."
        correct: false

  - description: "Which of the following is NOT a valid stereotype annotation in Spring Framework?"
    answers:
      - option: "@Inject"
        correct: true
      - option: "@Component"
        correct: false
      - option: "@Service"
        correct: false
      - option: "@Repository"
        correct: false

  - description: "What is required to enable Component Scanning in a Spring application?"
    answers:
      - option: "Configuring the @ComponentScan annotation in a configuration class."
        correct: true
      - option: "Manual registration of each bean in the application context."
        correct: false
      - option: "Enabling a special flag in the application.properties file."
        correct: false
      - option: "Installing additional libraries to support scanning."
        correct: false

  - description: "In the context of Spring's Component Scanning, what does the @Service annotation indicate?"
    answers:
      - option: "That the annotated class should be treated as a service component in the business layer."
        correct: true
      - option: "It is a specialized version of @Component for service-oriented middleware."
        correct: false
      - option: "That the class provides system-level services such as logging and security."
        correct: false
      - option: "It is used to mark classes that perform DAO operations."
        correct: false
  - description: "How is the @Autowired annotation processed in Spring?"
    answers:
      - option: "By the AutowiredAnnotationBeanPostProcessor."
        correct: true
      - option: "Directly by the ApplicationContext."
        correct: false
      - option: "Through manual configuration in XML files."
        correct: false
      - option: "Using the @Bean annotation."
        correct: false

  - description: "What does the @Autowired annotation activate in Spring?"
    answers:
      - option: "Spring Dependency Resolution."
        correct: true
      - option: "Spring AOP proxies."
        correct: false
      - option: "Component scanning."
        correct: false
      - option: "Bean lifecycle callbacks."
        correct: false

  - description: "What is primarily used by Spring Dependency Resolution to resolve dependencies?"
    answers:
      - option: "The type of beans."
        correct: true
      - option: "The name of the beans."
        correct: false
      - option: "The scope of the beans."
        correct: false
      - option: "The annotations on the beans."
        correct: false

  - description: "What happens when you try to inject an interface implemented by multiple classes annotated with @Component?"
    answers:
      - option: "Spring considers both classes to resolve the dependency."
        correct: true
      - option: "Spring ignores both classes and throws an exception immediately."
        correct: false
      - option: "Only the first found implementation is used."
        correct: false
      - option: "The application fails to start without indicating a specific error."
        correct: false

  - description: "Which exception is thrown when multiple candidate classes are found for a dependency injection, but none is marked with @Primary or @Qualifier?"
    answers:
      - option: "NoUniqueBeanDefinitionException."
        correct: true
      - option: "NoSuchBeanDefinitionException."
        correct: false
      - option: "BeanCreationException."
        correct: false
      - option: "BeanDefinitionStoreException."
        correct: false

  - description: "What is the consequence of a dependency not being annotated with any stereotype annotation?"
    answers:
      - option: "NoSuchBeanDefinitionException is thrown."
        correct: true
      - option: "The dependency is injected with a default implementation."
        correct: false
      - option: "Spring creates a proxy class for the dependency."
        correct: false
      - option: "The application context fails to refresh."
        correct: false

  - description: "How can you specify that a dependency injection by @Autowired is not mandatory? (select 2)"
    answers:
      - option: "Annotating the dependency with @Nullable."
        correct: true
      - option: "Setting the dependency as Optional in Java."
        correct: true
      - option: "Using @Optional annotation."
        correct: false
      - option: "Setting required=false in the @Autowired annotation."
        correct: true
      - option: "Marking the dependency with @NotRequired."
        correct: false

  - description: "What is the default requirement for dependencies declared with @Autowired?"
    answers:
      - option: "All dependencies are required by default."
        correct: true
      - option: "Dependencies are optional by default."
        correct: false
      - option: "Only primary beans are required; others are optional."
        correct: false
      - option: "Dependencies are required only if annotated with @Required."
        correct: false

  - description: "What does Spring do when @Autowired is used on a collection type?"
    answers:
      - option: "Injects all beans of the same type into the collection."
        correct: true
      - option: "Injects only the primary bean of the specified type into the collection."
        correct: false
      - option: "Throws an exception due to ambiguous dependencies."
        correct: false
      - option: "Ignores the collection and does not inject any beans."
        correct: false

  - description: "How does Spring handle @Autowired on a Map?"
    answers:
      - option: "Injects bean names as keys and corresponding beans as values."
        correct: true
      - option: "Injects only the keys of matching beans without their instances."
        correct: false
      - option: "Throws an exception if more than one bean of the same type is found."
        correct: false
      - option: "Ignores the Map and does not inject any beans."
        correct: false

  - description: "Which exception is thrown if Spring cannot resolve a bean for injection?"
    answers:
      - option: "NoSuchBeanDefinitionException."
        correct: true
      - option: "BeanInstantiationException."
        correct: false
      - option: "BeanNotOfRequiredTypeException."
        correct: false
      - option: "NoUniqueBeanDefinitionException."
        correct: false

  - description: "What does setting required=false in @Autowired do?"
    answers:
      - option: "Allows the application context to start without the dependency being satisfied."
        correct: true
      - option: "Forces Spring to inject a null value if no matching bean is found."
        correct: false
      - option: "Makes the dependency injection process optional for Spring."
        correct: true
      - option: "Indicates that the dependency can be satisfied at runtime."
        correct: false

  - description: "In which scenarios can @Autowired be used? (select 2)"
    answers:
      - option: "On constructors."
        correct: true
      - option: "On field declarations."
        correct: true
      - option: "On static methods."
        correct: false
      - option: "On package declarations."
        correct: false
      - option: "On local variable declarations within a method."
        correct: false

  - description: "What ensures that all required dependencies are satisfied when using @Autowired on a constructor with multiple parameters?"
    answers:
      - option: "Spring treats all parameters as required unless they are marked with @Nullable or are Optional."
        correct: true
      - option: "Spring ignores constructor-based injection if multiple parameters are involved."
        correct: false
      - option: "All parameters are optional by default, and Spring attempts to inject them if beans are available."
        correct: false
      - option: "The developer must manually check for the presence of beans in the context."
        correct: false

  - description: "What annotation is processed by AutowiredAnnotationBeanPostProcessor?"
    answers:
      - option: "@Autowired."
        correct: true
      - option: "@Bean."
        correct: false
      - option: "@Component."
        correct: false
      - option: "@Value."
        correct: false

  - description: "What can @Autowired be applied to? (select 2)"
    answers:
      - option: "Setter methods."
        correct: true
      - option: "Private fields."
        correct: true
      - option: "Module declarations."
        correct: false
      - option: "Package names."
        correct: false
      - option: "Import statements."
        correct: false

  - description: "What feature does Spring provide to resolve ambiguity when multiple beans of the same type are available for injection?"
    answers:
      - option: "Using @Qualifier annotation to specify which bean should be injected."
        correct: true
      - option: "Automatically selecting the bean with the latest creation timestamp."
        correct: false
      - option: "Injecting a proxy to delegate calls to one of the available beans randomly."
        correct: false
      - option: "Creating a new bean instance specifically for this injection point."
        correct: false

  - description: "How does Spring prioritize beans when @Autowired is used for injection and multiple beans are available?"
    answers:
      - option: "It looks for the bean marked with @Primary when making the selection."
        correct: true
      - option: "It selects the bean based on the alphabetical order of their IDs."
        correct: false
      - option: "Spring injects all available beans into a list or array."
        correct: false
      - option: "It chooses the bean with the smallest scope."
        correct: false

  - description: "What is the effect of @Autowired on a configuration class with multiple @Bean methods returning the same type?"
    answers:
      - option: "Spring will consider all @Bean methods to resolve the injection point."
        correct: true
      - option: "Only the first @Bean method encountered is considered for autowiring."
        correct: false
      - option: "Spring raises an exception due to conflicting beans of the same type."
        correct: false
      - option: "The @Bean methods are ignored, and Spring searches for matching beans within its context."
        correct: false

  - description: "How can @Autowired be used for method injection with parameters? (select 2)"
    answers:
      - option: "By marking any method with @Autowired and defining the required parameters."
        correct: true
      - option: "Applying @Autowired to only setter methods of the class."
        correct: false
      - option: "Annotating methods with @Autowired that are not related to setting properties."
        correct: true
      - option: "Using @Autowired on static methods to inject dependencies."
        correct: false
      - option: "Applying @Autowired to private methods to encourage encapsulation."
        correct: false

  - description: "What does Spring do if a matching bean cannot be found for an @Autowired injection point?"
    answers:
      - option: "It throws a NoSuchBeanDefinitionException if the dependency is required."
        correct: true
      - option: "Spring creates a default implementation of the bean."
        correct: false
      - option: "It injects a null value if marked as not required."
        correct: false
      - option: "The injection is postponed until a matching bean becomes available."
        correct: false

  - description: "What is the recommended way to use @Autowired in terms of best practices for dependency injection?"
    answers:
      - option: "Constructor injection for mandatory dependencies."
        correct: true
      - option: "Field injection for easier configuration and testing."
        correct: false
      - option: "Setter injection for optional dependencies."
        correct: false
      - option: "Using @Autowired on private fields to avoid exposing setters."
        correct: false

  - description: "How can the @Autowired annotation be made optional for a dependency?"
    answers:
      - option: "By setting the required attribute of the @Autowired annotation to false."
        correct: true
      - option: "Annotating the dependency with @Optional."
        correct: false
      - option: "Using Java's Optional for the field or parameter type."
        correct: true
      - option: "Marking the field or method with @Nullable annotation."
        correct: true

  - description: "Which Spring annotation is not directly related to the @Autowired annotation but is often used alongside it to further specify the intended bean to be injected?"
    answers:
      - option: "@Qualifier."
        correct: true
      - option: "@Bean."
        correct: false
      - option: "@Component."
        correct: false
      - option: "@Value."
        correct: false
  - description: "What are the necessary components for Dependency Injection in Spring? (select 2)"
    answers:
      - option: "@ComponentScan annotation for discovering beans"
        correct: true
      - option: "Application context to manage bean lifecycle"
        correct: true
      - option: "Manual instantiation of beans inside classes"
        correct: false
      - option: "Use of native Java serialization for bean creation"
        correct: false
      - option: "Direct use of JDBC for database connectivity"
        correct: false

  - description: "Which annotations are used for component scanning in Spring? (select 2)"
    answers:
      - option: "@Component"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Service"
        correct: true
      - option: "@Entity"
        correct: false
      - option: "@Interface"
        correct: false

  - description: "What are the benefits of using Java config for bean declaration in Spring? (select 2)"
    answers:
      - option: "Decoupling configuration from the application logic"
        correct: true
      - option: "Automatic resolution of circular dependencies"
        correct: false
      - option: "Ability to easily switch between different profiles"
        correct: true
      - option: "Direct access to low-level concurrency primitives"
        correct: false
      - option: "Increased performance due to bytecode optimization"
        correct: false

  - description: "How can you achieve Dependency Injection in Spring using annotations? (select 2)"
    answers:
      - option: "Annotating beans with @Component"
        correct: true
      - option: "Using @Autowired on constructors or fields"
        correct: true
      - option: "Declaring beans in an external properties file"
        correct: false
      - option: "Manual creation of beans inside the application main method"
        correct: false
      - option: "Implementing the BeanFactoryAware interface"
        correct: false

  - description: "Which of the following are correct about application contexts in Spring? (select 2)"
    answers:
      - option: "It manages bean lifecycle and configurations"
        correct: true
      - option: "It is created manually by the developer in every application"
        correct: false
      - option: "Can be closed manually or automatically, depending on the application type"
        correct: true
      - option: "Only supports XML-based configuration"
        correct: false
      - option: "Cannot be used for defining beans"
        correct: false

  - description: "What is true about the @Component and @Autowired annotations in Spring? (select 2)"
    answers:
      - option: "@Component marks a class as a Spring bean"
        correct: true
      - option: "@Autowired can be used for constructor, setter, and field injection"
        correct: true
      - option: "@Component automatically configures bean properties"
        correct: false
      - option: "@Autowired is necessary for beans defined with Java Config"
        correct: false
      - option: "@ComponentScan is not needed when using @Component"
        correct: false

  - description: "In what scenarios is the ApplicationContext in Spring closed automatically? (select 2)"
    answers:
      - option: "In web applications managed by Spring Boot"
        correct: true
      - option: "When using @Autowired without @ComponentScan"
        correct: false
      - option: "In standalone applications using the registerShutdownHook method"
        correct: true
      - option: "Upon calling the destroy() method on individual beans"
        correct: false
      - option: "Directly after bean instantiation due to memory optimization"
        correct: false

  - description: "What annotations are essential for defining a Spring bean and injecting dependencies? (select 2)"
    answers:
      - option: "@Component for declaring a bean"
        correct: true
      - option: "@Inject for dependency injection"
        correct: false
      - option: "@Autowired for dependency injection"
        correct: true
      - option: "@Entity for marking a bean"
        correct: false
      - option: "@Qualifier for specifying bean IDs"
        correct: false

  - description: "Which of the following statements are true regarding Spring's way of managing beans? (select 2)"
    answers:
      - option: "Beans can be defined using annotations like @Service and @Repository"
        correct: true
      - option: "Every bean must be manually instantiated in the application's main class"
        correct: false
      - option: "Dependency injection can be achieved through both autowiring and manual wiring"
        correct: true
      - option: "Spring requires XML configuration for bean management"
        correct: false
      - option: "The ApplicationContext is responsible for creating and managing beans"
        correct: true

  - description: "How do you correctly configure and utilize an ApplicationContext in a Spring application? (select 2)"
    answers:
      - option: "By using @Configuration to define beans"
        correct: true
      - option: "Instantiating ApplicationContext in every class that uses beans"
        correct: false
      - option: "Utilizing @ComponentScan to automatically detect and register beans"
        correct: true
      - option: "Calling the static method ApplicationContext.getBean() to retrieve beans"
        correct: false
      - option: "Manually registering each bean in the ApplicationContext"
        correct: false
  - description: "Which types of injections does the @Autowired annotation support? (select 2)"
    answers:
      - option: "Constructor injection"
        correct: true
      - option: "Field injection"
        correct: true
      - option: "Manual injection"
        correct: false
      - option: "Static method injection"
        correct: false
      - option: "Interface injection"
        correct: false

  - description: "What are the features of the @Autowired annotation in handling bean dependencies? (select 2)"
    answers:
      - option: "Automatically resolves dependencies based on bean types"
        correct: true
      - option: "Can be applied to constructors, fields, setters, and configuration methods"
        correct: true
      - option: "Requires manual bean instantiation"
        correct: false
      - option: "Only injects beans annotated with @Primary by default"
        correct: false
      - option: "Ignores beans defined in XML configuration files"
        correct: false

  - description: "What happens when @Autowired is used for a type with multiple qualifying beans without specifying @Primary or @Qualifier? (select 2)"
    answers:
      - option: "A NoUniqueBeanDefinitionException is thrown"
        correct: true
      - option: "Spring context initialization fails"
        correct: true
      - option: "The first bean found in the context is injected"
        correct: false
      - option: "All matching beans are injected into a collection"
        correct: false
      - option: "It defaults to using a bean named after the class"
        correct: false

  - description: "How can the requirement of a dependency being mandatory be altered using @Autowired? (select 2)"
    answers:
      - option: "By annotating the dependency with @Nullable"
        correct: true
      - option: "Using Java Optional for the dependency"
        correct: true
      - option: "Setting required attribute to false"
        correct: true
      - option: "Declaring the dependency as static"
        correct: false
      - option: "Using @Optional annotation"
        correct: false

  - description: "In which scenarios is an injected bean considered optional with @Autowired? (select 2)"
    answers:
      - option: "When the dependency is wrapped with Java's Optional"
        correct: true
      - option: "If the injected field is annotated with @Nullable"
        correct: true
      - option: "When the dependency is marked with @Optional annotation"
        correct: false
      - option: "If the bean is defined as abstract"
        correct: false
      - option: "When @Autowired's required attribute is set to true"
        correct: false

  - description: "What are the consequences of using @Autowired on a collection type? (select 2)"
    answers:
      - option: "All beans matching the collection's type are injected"
        correct: true
      - option: "The collection can be ordered or prioritized"
        correct: true
      - option: "Only the primary bean of the matching type is injected"
        correct: false
      - option: "Collections are not supported; only single beans can be injected"
        correct: false
      - option: "A NoSuchBeanDefinitionException is thrown if no beans are found"
        correct: false

  - description: "Which types of collections can @Autowired populate? (select 2)"
    answers:
      - option: "List"
        correct: true
      - option: "Map"
        correct: true
      - option: "Array"
        correct: true
      - option: "Stream"
        correct: false
      - option: "Set"
        correct: true

  - description: "How does @Autowired handle injection when applied to a map? (select 2)"
    answers:
      - option: "Bean names are used as keys"
        correct: true
      - option: "Bean instances are used as values"
        correct: true
      - option: "Map keys are derived from bean scopes"
        correct: false
      - option: "Only beans of type Map can be injected"
        correct: false
      - option: "Injects only beans annotated with @Qualifier"
        correct: false

  - description: "What does specifying required=false in @Autowired do? (select 2)"
    answers:
      - option: "Makes the dependency injection optional"
        correct: true
      - option: "Allows the application context to load without the bean"
        correct: true
      - option: "Forces Spring to inject a null value if no matching bean is found"
        correct: false
      - option: "Prevents the bean from being injected into other beans"
        correct: false
      - option: "Automatically creates a proxy bean if no matching bean is found"
        correct: false

  - description: "What annotations are compatible with @Autowired to control how dependencies are injected? (select 2)"
    answers:
      - option: "@Nullable for optional injection"
        correct: true
      - option: "@Qualifier to specify which bean to inject"
        correct: true
      - option: "@Inject as a direct alternative"
        correct: false
      - option: "@Bean to define the injected bean inline"
        correct: false
      - option: "@Value to inject property values"
        correct: false
  - description: "What type of injection is preferred in Spring for immutable properties?"
    answers:
      - option: "Constructor injection"
        correct: true
      - option: "Field injection"
        correct: false
      - option: "Setter injection"
        correct: false
      - option: "Method injection"
        correct: false

  - description: "Which annotation makes a bean injection optional if no matching bean is found?"
    answers:
      - option: "@Nullable"
        correct: true
      - option: "@Optional"
        correct: false
      - option: "@Autowired(required=false)"
        correct: false
      - option: "@Primary"
        correct: false

  - description: "How are beans sorted when injected into a List using @Autowired?"
    answers:
      - option: "By their definition order in the application context"
        correct: false
      - option: "Alphabetically by their bean IDs"
        correct: false
      - option: "No specific order is guaranteed"
        correct: true
      - option: "By their natural ordering if they implement Comparable"
        correct: false

  - description: "What happens when @Autowired is applied to a Map whose values are beans?"
    answers:
      - option: "It injects all matching beans with their IDs as keys"
        correct: true
      - option: "Throws an exception due to type mismatch"
        correct: false
      - option: "Only injects the primary bean of the matching type"
        correct: false
      - option: "Maps are not supported for @Autowired injection"
        correct: false

  - description: "What does the 'required' attribute of @Autowired do when set to false?"
    answers:
      - option: "Allows context initialization without the dependency"
        correct: true
      - option: "Makes the annotated field, setter, or constructor private"
        correct: false
      - option: "Injects a default bean if no matching bean is found"
        correct: false
      - option: "Forces Spring to create a new bean instance"
        correct: false

  - description: "In which scenario is @Autowired not recommended by Spring?"
    answers:
      - option: "When injecting single constructor dependencies"
        correct: false
      - option: "For field injection due to the difficulty in testing"
        correct: true
      - option: "Injecting properties from the application.properties file"
        correct: false
      - option: "When using Java-based configuration"
        correct: false

  - description: "What feature does @Autowired provide when used on Java collections?"
    answers:
      - option: "Injects all beans of the specified type into the collection"
        correct: true
      - option: "Automatically sorts the beans by their dependency order"
        correct: false
      - option: "Only injects beans annotated with @Primary"
        correct: false
      - option: "Limits the collection size to a maximum of 10 beans"
        correct: false

  - description: "Which method of dependency injection allows easier unit testing by not relying on Spring to inject dependencies?"
    answers:
      - option: "Constructor injection"
        correct: true
      - option: "Field injection"
        correct: false
      - option: "Setter injection"
        correct: false
      - option: "Method injection"
        correct: false

  - description: "What is the primary use of @Qualifier in conjunction with @Autowired?"
    answers:
      - option: "To specify which bean to inject when multiple candidates exist"
        correct: true
      - option: "To mark a bean as the primary source for autowiring"
        correct: false
      - option: "To define new bean definitions inline"
        correct: false
      - option: "To inject properties from application.properties"
        correct: false

  - description: "How is the injection of optional dependencies handled in Spring?"
    answers:
      - option: "By using @Autowired with required=false or @Nullable"
        correct: true
      - option: "Through explicit configuration in XML files"
        correct: false
      - option: "Using the @Optional annotation on the field"
        correct: false
      - option: "Optional injections are not supported in Spring"
        correct: false

  - description: "What annotation should be used to automatically wire a bean by its type if more than one bean of the same type is defined in the context?"
    answers:
      - option: "@Primary"
        correct: true
      - option: "@Qualifier"
        correct: false
      - option: "@Autowired"
        correct: false
      - option: "@Bean"
        correct: false

  - description: "What is a common practice for declaring a bean that requires mandatory dependencies?"
    answers:
      - option: "Using @Autowired on a constructor with all necessary parameters"
        correct: true
      - option: "Annotating the class with @Component only"
        correct: false
      - option: "Using setter injection with @Autowired"
        correct: false
      - option: "Declaring the bean in a property file"
        correct: false

  - description: "What does using @Autowired on a setter method enable in Spring?"
    answers:
      - option: "Dependency injection through setter methods"
        correct: true
      - option: "Automatic bean creation and registration"
        correct: false
      - option: "Exclusion of the bean from the application context"
        correct: false
      - option: "Static injection of dependencies"
        correct: false

  - description: "Which of the following is true about the behavior of @Autowired in relation to constructor injection when there's only one constructor?"
    answers:
      - option: "@Autowired can be omitted as Spring automatically uses it"
        correct: true
      - option: "It is mandatory to use @Autowired on the constructor"
        correct: false
      - option: "Spring will ignore the constructor for dependency injection"
        correct: false
      - option: "A bean will be created without dependencies being injected"
        correct: false

  - description: "When using @Autowired for method injection, what is the role of the method's parameters?"
    answers:
      - option: "Spring injects beans matching the parameters' types"
        correct: true
      - option: "Parameters are ignored, and injection is based on field names"
        correct: false
      - option: "The method's parameters are used to generate bean IDs"
        correct: false
      - option: "Parameters determine the order of bean instantiation"
        correct: false
  - description: "What does Spring do if a matching bean is not found for an @Autowired field with 'required' set to false?"
    answers:
      - option: "Leaves the field as null"
        correct: true
      - option: "Throws a NoSuchBeanDefinitionException"
        correct: false
      - option: "Creates a default instance of the field's class"
        correct: false
      - option: "Searches for a bean in parent contexts"
        correct: false

  - description: "Which Spring annotation is used to indicate that a bean method produces a bean to be managed by the Spring container?"
    answers:
      - option: "@Bean"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Component"
        correct: false
      - option: "@Service"
        correct: false

  - description: "For constructor injection, what does Spring Framework recommend as the best practice when there are multiple constructors?"
    answers:
      - option: "Annotate the constructor to be used with @Autowired"
        correct: true
      - option: "Spring automatically selects the constructor with the most parameters"
        correct: false
      - option: "Use @Primary on one of the constructors"
        correct: false
      - option: "Only use default constructors for beans"
        correct: false

  - description: "How does the @Autowired annotation work with regards to field injection?"
    answers:
      - option: "Injects dependency by type into the annotated field"
        correct: true
      - option: "Requires the field to be public for injection to work"
        correct: false
      - option: "Injects dependency by name based on the field name"
        correct: false
      - option: "Allows injection of multiple dependencies into a single field"
        correct: false

  - description: "Which is a valid use of @Autowired in combination with generics?"
    answers:
      - option: "Autowired can inject beans matching the generic type of the target field"
        correct: true
      - option: "Generics are ignored by @Autowired during dependency injection"
        correct: false
      - option: "You must manually specify the generic type using @Qualifier"
        correct: false
      - option: "@Autowired does not support injection of generic types"
        correct: false
  - description: "What are the implications of injecting dependencies into private fields in Spring? (select 2)"
    answers:
      - option: "It can make unit testing more challenging."
        correct: true
      - option: "Requires the use of @Autowired or @Value annotations for injection."
        correct: true
      - option: "Automatically makes the field public."
        correct: false
      - option: "Eliminates the need for setter or constructor injection."
        correct: false
      - option: "Improves performance by reducing visibility."
        correct: false

  - description: "Which annotations are used for injecting values into private fields in Spring? (select 2)"
    answers:
      - option: "@Autowired for dependency injection"
        correct: true
      - option: "@Value for injecting property values"
        correct: true
      - option: "@Component for making the class a bean"
        correct: false
      - option: "@Service to designate service layer"
        correct: false
      - option: "@Repository for data access layer beans"
        correct: false

  - description: "What are the options for testing a class with private fields injected using @Autowired in Spring? (select 2)"
    answers:
      - option: "Using SpringRunner with @MockBean for mock injection"
        correct: true
      - option: "Creating a test context configuration with @ContextConfiguration"
        correct: true
      - option: "Directly instantiating the class and manually injecting mocks"
        correct: false
      - option: "Using @InjectMocks without a Spring context"
        correct: false
      - option: "Making fields public solely for testing purposes"
        correct: false

  - description: "How can @Autowired's requirement for a dependency be bypassed? (select 2)"
    answers:
      - option: "By marking the dependency with @Nullable"
        correct: true
      - option: "Using Java's Optional for the dependency"
        correct: true
      - option: "Declaring the dependency static"
        correct: false
      - option: "Setting @Autowired's required attribute to false"
        correct: true
      - option: "Annotating the dependency with @Optional"
        correct: false

  - description: "Which techniques are valid for injecting beans into a collection or map with @Autowired? (select 2)"
    answers:
      - option: "Injecting all beans of the specified type into a collection"
        correct: true
      - option: "Using a map to store beans with their IDs as keys"
        correct: true
      - option: "Only primary beans of the matching type are injected into collections"
        correct: false
      - option: "Collections and maps cannot be used with @Autowired"
        correct: false
      - option: "A NoSuchBeanDefinitionException is thrown if no matching beans are found"
        correct: false
  - description: "What annotation is necessary alongside @Autowired to specify a particular bean when multiple candidates exist?"
    answers:
      - option: "@Qualifier"
        correct: true
      - option: "@Primary"
        correct: false
      - option: "@Inject"
        correct: false
      - option: "@Bean"
        correct: false

  - description: "Which Spring annotation is used to inject property values into private fields?"
    answers:
      - option: "@Value"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@PropertySource"
        correct: false
      - option: "@Resource"
        correct: false

  - description: "How does Spring handle the injection of a bean when @Autowired is used without specifying @Qualifier in a scenario with multiple implementation?"
    answers:
      - option: "Throws a NoUniqueBeanDefinitionException"
        correct: true
      - option: "Selects a bean randomly"
        correct: false
      - option: "Injects all matching beans"
        correct: false
      - option: "Falls back to using the primary bean"
        correct: false

  - description: "What is the primary purpose of using @MockBean in tests?"
    answers:
      - option: "To provide mock implementations for beans during testing"
        correct: true
      - option: "To scan for beans automatically"
        correct: false
      - option: "To create new bean instances for each test case"
        correct: false
      - option: "To override existing bean definitions with test doubles"
        correct: false

  - description: "In Spring, what effect does setting 'required=false' on @Autowired have?"
    answers:
      - option: "Allows the application context to load without the bean"
        correct: true
      - option: "Forces the injection of a default bean"
        correct: false
      - option: "Makes the dependency mandatory"
        correct: false
      - option: "Injects a null value if the bean is not available"
        correct: false
  - description: "What are the main purposes of using @Qualifier annotation with @Autowired? (select 2)"
    answers:
      - option: "To specify which bean to inject when there are multiple candidates"
        correct: true
      - option: "To inject all available beans of the specified type into a collection"
        correct: false
      - option: "To provide additional control over the beans that are injected"
        correct: true
      - option: "To automatically generate new bean definitions"
        correct: false
      - option: "To exclude certain beans from being autowired"
        correct: false

  - description: "How can @Autowired and @Qualifier be used together for dependency injection? (select 2)"
    answers:
      - option: "Autowired before Qualifier with the bean name as parameter"
        correct: true
      - option: "Qualifier alone with a custom bean name"
        correct: false
      - option: "Autowired with Qualifier specifying the custom bean name"
        correct: true
      - option: "Qualifier specifying the bean's type instead of its name"
        correct: false
      - option: "Autowired without Qualifier when injecting unique bean types"
        correct: false

  - description: "What scenarios require the use of @Qualifier annotation? (select 2)"
    answers:
      - option: "When multiple beans of the same type exist and one needs to be selected"
        correct: true
      - option: "For injecting primitive or String values directly"
        correct: false
      - option: "When injecting collections of a certain bean type"
        correct: false
      - option: "To specify the exact bean to use by its name or custom qualifier value"
        correct: true
      - option: "When there is only one bean of a type and it is automatically selected"
        correct: false

  - description: "What does the combination of @Autowired and @Qualifier achieve in Spring? (select 2)"
    answers:
      - option: "It clarifies which bean should be injected in case of ambiguity"
        correct: true
      - option: "It prevents Spring from injecting any beans if not specified"
        correct: false
      - option: "Allows specific bean selection without affecting global bean naming"
        correct: true
      - option: "Forces Spring to create a new bean instance for each injection"
        correct: false
      - option: "It designates the primary bean to be used across the application"
        correct: false

  - description: "In which ways can @Qualifier be used to assist @Autowired? (select 2)"
    answers:
      - option: "By directing Spring to inject a bean by its specific name"
        correct: true
      - option: "Allowing Spring to decide on the primary bean when @Primary is not used"
        correct: false
      - option: "Helping to resolve the exact bean to inject when type alone is not enough"
        correct: true
      - option: "By creating a default bean name when none is provided"
        correct: false
      - option: "Enabling automatic conversion of type mismatches during injection"
        correct: false
  - description: "What problem does the @Qualifier annotation solve?"
    answers:
      - option: "It resolves the issue of which bean to inject when multiple implementations exist"
        correct: true
      - option: "It injects all beans of a certain type into an array or collection"
        correct: false
      - option: "It identifies the primary bean to be used throughout the application"
        correct: false
      - option: "It automatically generates bean names based on their types"
        correct: false

  - description: "Where should the @Qualifier annotation be placed in relation to @Autowired?"
    answers:
      - option: "Immediately after @Autowired"
        correct: true
      - option: "Before the declaration of the class"
        correct: false
      - option: "As a parameter to @Autowired"
        correct: false
      - option: "It does not matter as long as both are on the same field or method"
        correct: false

  - description: "What exception is avoided by correctly using @Autowired and @Qualifier together?"
    answers:
      - option: "NoUniqueBeanDefinitionException"
        correct: true
      - option: "NoSuchBeanDefinitionException"
        correct: false
      - option: "BeanCreationException"
        correct: false
      - option: "BeanCurrentlyInCreationException"
        correct: false

  - description: "Can @Qualifier annotation be used without @Autowired in Spring?"
    answers:
      - option: "No, @Qualifier is used in conjunction with @Autowired to specify the bean"
        correct: true
      - option: "Yes, @Qualifier can independently select beans"
        correct: false
      - option: "Yes, but only when used with @Resource annotation"
        correct: false
      - option: "Yes, it replaces the functionality of @Autowired"
        correct: false

  - description: "How does @Qualifier affect the selection of beans for autowiring?"
    answers:
      - option: "It allows specifying a particular bean by name, overriding type-based selection"
        correct: true
      - option: "It makes all beans of the specified type eligible for autowiring"
        correct: false
      - option: "It automatically selects the bean marked as @Primary"
        correct: false
      - option: "It disables autowiring for the specified bean type"
        correct: false
  - description: "Which annotations are essential for autowiring beans in Spring? (select 2)"
    answers:
      - option: "@Autowired"
        correct: true
      - option: "@Qualifier"
        correct: true
      - option: "@Bean"
        correct: false
      - option: "@Component"
        correct: false
      - option: "@Service"
        correct: false

  - description: "What functionalities do @Autowired and @Qualifier provide when used together? (select 2)"
    answers:
      - option: "Resolving exact beans when multiple candidates are present"
        correct: true
      - option: "Injecting properties from application.properties"
        correct: false
      - option: "Specifying the name of the bean to be wired"
        correct: true
      - option: "Creating new bean definitions on the fly"
        correct: false
      - option: "Automatically marking a bean as primary"
        correct: false

  - description: "In what scenarios is the @Qualifier annotation particularly useful? (select 2)"
    answers:
      - option: "When multiple beans of the same type are available"
        correct: true
      - option: "When injecting collection types"
        correct: false
      - option: "To distinguish between beans by specifying a name"
        correct: true
      - option: "For injecting values from external properties files"
        correct: false
      - option: "When there is only one bean of a required type"
        correct: false

  - description: "What are the correct uses of @Autowired in Spring? (select 2)"
    answers:
      - option: "For constructor injection"
        correct: true
      - option: "For field injection"
        correct: true
      - option: "To directly inject property files"
        correct: false
      - option: "To annotate configuration classes"
        correct: false
      - option: "For creating bean definitions"
        correct: false

  - description: "How can you modify the behavior of @Autowired dependencies? (select 2)"
    answers:
      - option: "Using @Qualifier to specify which bean to inject"
        correct: true
      - option: "Setting required=false to make dependency injection optional"
        correct: true
      - option: "Applying @Primary on the dependency class"
        correct: false
      - option: "Using @Value to inject property values"
        correct: false
      - option: "Applying @Profile to select beans based on the active profile"
        correct: false
  - description: "What is the primary purpose of the @Autowired annotation in Spring?"
    answers:
      - option: "To automatically wire bean dependencies by type"
        correct: true
      - option: "To define new bean definitions within application context"
        correct: false
      - option: "To mark a class as a Spring component"
        correct: false
      - option: "To specify active profiles within the application"
        correct: false

  - description: "Which attribute of @Autowired makes a bean injection mandatory by default?"
    answers:
      - option: "required attribute set to true"
        correct: true
      - option: "The value attribute"
        correct: false
      - option: "The name attribute"
        correct: false
      - option: "It has no such attribute; injections are always optional"
        correct: false

  - description: "How does Spring Framework resolve a bean when @Autowired is used without @Qualifier?"
    answers:
      - option: "By type"
        correct: true
      - option: "By bean id or name"
        correct: false
      - option: "By constructor parameters"
        correct: false
      - option: "By order of definition"
        correct: false

  - description: "What exception may occur when @Autowired cannot find a required bean?"
    answers:
      - option: "NoSuchBeanDefinitionException"
        correct: true
      - option: "BeanInstantiationException"
        correct: false
      - option: "NoUniqueBeanDefinitionException"
        correct: false
      - option: "BeanCreationException"
        correct: false

  - description: "When using @Qualifier, what type of value does it typically specify?"
    answers:
      - option: "The name of the bean to be injected"
        correct: true
      - option: "The class type of the bean"
        correct: false
      - option: "The scope of the bean"
        correct: false
      - option: "The profile under which the bean is active"
        correct: false

  - description: "What happens if @Autowired is used on a private field without a setter method?"
    answers:
      - option: "Spring still injects the bean using reflection"
        correct: true
      - option: "The application fails to start"
        correct: false
      - option: "The field remains null"
        correct: false
      - option: "A setter method is automatically generated"
        correct: false

  - description: "Can the annotation @Autowired be used on static fields?"
    answers:
      - option: "No, @Autowired cannot be used on static fields"
        correct: true
      - option: "Yes, but it requires @Qualifier to specify the bean"
        correct: false
      - option: "Yes, Spring treats static and non-static fields the same"
        correct: false
      - option: "Yes, if the static field is marked as @Primary"
        correct: false

  - description: "Which best describes the behavior of @Autowired when used on multiple constructors?"
    answers:
      - option: "Spring uses the constructor with the most parameters that can be autowired"
        correct: true
      - option: "Only the default constructor is used"
        correct: false
      - option: "All constructors are called in sequence"
        correct: false
      - option: "The application context fails to load"
        correct: false

  - description: "What is the role of @Autowired in the context of method injection?"
    answers:
      - option: "It allows Spring to inject dependencies into any method parameters"
        correct: true
      - option: "It defines a method to be automatically called after bean instantiation"
        correct: false
      - option: "It is used to select one of multiple methods for injection"
        correct: false
      - option: "It injects values from properties files into methods"
        correct: false
  - description: "What is the purpose of using @ContextConfiguration with SpringRunner for testing?"
    answers:
      - option: "To configure the Spring application context used in tests"
        correct: true
      - option: "To directly instantiate test classes without a Spring context"
        correct: false
      - option: "To mark methods within a test class as transactional"
        correct: false
      - option: "To provide mock implementations of beans not relevant to the test"
        correct: false

  - description: "How does @MockBean enhance unit testing in Spring?"
    answers:
      - option: "By adding mock versions of beans into the Spring application context"
        correct: true
      - option: "It automatically generates test cases for each bean"
        correct: false
      - option: "By starting a full web environment for integration testing"
        correct: false
      - option: "It validates the Spring context without loading it"
        correct: false

  - description: "What functionality does ReflectionTestUtils provide in Spring testing?"
    answers:
      - option: "It allows setting private fields in test objects without a setter method"
        correct: true
      - option: "It creates a proxy for the class under test for isolation"
        correct: false
      - option: "Generates a mock Spring application context"
        correct: false
      - option: "Automatically injects @MockBean into the test context"
        correct: false

  - description: "How is Mockito utilized in Spring tests?"
    answers:
      - option: "To create and inject mock objects into the test context"
        correct: true
      - option: "For generating Spring application contexts"
        correct: false
      - option: "To configure Spring-specific annotations in unit tests"
        correct: false
      - option: "It is used to define beans in the application context"
        correct: false

  - description: "What is the role of @TestPropertySource in Spring tests?"
    answers:
      - option: "To specify properties for use in tests"
        correct: true
      - option: "To override Spring Boot's application.properties in tests"
        correct: true
      - option: "To inject mock beans into the application context"
        correct: false
      - option: "To automatically generate test properties"
        correct: false
  - description: "What is the primary purpose of the @Qualifier annotation in Spring? (select 2)"
    answers:
      - option: "To specify which bean to inject when there are multiple candidates"
        correct: true
      - option: "To define a custom name for a bean"
        correct: true
      - option: "To create a new bean instance"
        correct: false
      - option: "To automatically configure beans"
        correct: false
      - option: "To inject property values into beans"
        correct: false

  - description: "How can @Qualifier be used effectively with @Autowired? (select 2)"
    answers:
      - option: "Specifying the bean name directly after @Autowired"
        correct: true
      - option: "Using a custom qualifier annotation for more complex scenarios"
        correct: true
      - option: "To prioritize primary beans over others"
        correct: false
      - option: "Injecting multiple beans of the same type into a single field"
        correct: false
      - option: "Automatically injecting beans by their type"
        correct: false

  - description: "In which scenarios is using @Qualifier necessary? (select 2)"
    answers:
      - option: "When the application context contains multiple beans of the same type"
        correct: true
      - option: "When injecting beans into a collection or map"
        correct: false
      - option: "To distinguish between beans when autowiring by type is not sufficient"
        correct: true
      - option: "When @Autowired is used on constructor injection"
        correct: false
      - option: "For injecting property values into fields"
        correct: false

  - description: "What are the methods to use @Qualifier annotation? (select 2)"
    answers:
      - option: "By providing the bean name as a parameter to @Qualifier"
        correct: true
      - option: "Creating a custom qualifier annotation"
        correct: true
      - option: "Using @Qualifier without @Autowired for field injection"
        correct: false
      - option: "Applying @Qualifier on bean definition methods"
        correct: false
      - option: "Using @Qualifier to directly inject property values"
        correct: false

  - description: "What are the benefits of using @Qualifier with @Autowired in Spring? (select 2)"
    answers:
      - option: "Helps avoid NoUniqueBeanDefinitionException by specifying the correct bean"
        correct: true
      - option: "Facilitates the injection of specific bean instances into fields or methods"
        correct: true
      - option: "Increases application performance by reducing bean lookup time"
        correct: false
      - option: "Automatically marks a bean as primary within its context"
        correct: false
      - option: "Enables the injection of primitive values into beans"
        correct: false
  - description: "What does @Autowired do when used without @Qualifier in the presence of multiple beans of the same type?"
    answers:
      - option: "Throws NoUniqueBeanDefinitionException"
        correct: true
      - option: "Automatically selects the primary bean"
        correct: false
      - option: "Injects all beans into a collection"
        correct: false
      - option: "Selects a bean randomly"
        correct: false

  - description: "Can @Qualifier be used on methods other than setters or constructors?"
    answers:
      - option: "Yes, it can be used on any injection point"
        correct: true
      - option: "No, it's only applicable to setters and constructors"
        correct: false
      - option: "Yes, but only on configuration methods"
        correct: false
      - option: "No, it is exclusively for field injection"
        correct: false

  - description: "What exception is thrown if a required bean is not found during autowiring?"
    answers:
      - option: "NoSuchBeanDefinitionException"
        correct: true
      - option: "BeanCreationException"
        correct: false
      - option: "NoUniqueBeanDefinitionException"
        correct: false
      - option: "BeanInstantiationException"
        correct: false

  - description: "Is it possible to create a custom @Qualifier annotation?"
    answers:
      - option: "Yes, by annotating an interface with @Qualifier"
        correct: true
      - option: "No, @Qualifier cannot be customized"
        correct: false
      - option: "Yes, but only for method parameters"
        correct: false
      - option: "No, it can only be used as provided by Spring"
        correct: false

  - description: "What annotation should be used to specify a bean to be injected when using @Autowired?"
    answers:
      - option: "@Qualifier"
        correct: true
      - option: "@Primary"
        correct: false
      - option: "@Bean"
        correct: false
      - option: "@Inject"
        correct: false

  - description: "What is a common use case for applying @Qualifier?"
    answers:
      - option: "To resolve the correct bean when multiple implementations are present"
        correct: true
      - option: "To inject all beans of a certain type into an array"
        correct: false
      - option: "To define a new bean in the application context"
        correct: false
      - option: "To automatically convert bean types during injection"
        correct: false

  - description: "Which Spring annotation is used to inject values into beans?"
    answers:
      - option: "@Value"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Resource"
        correct: false
      - option: "@Inject"
        correct: false

  - description: "What does the @Autowired annotation primarily aim to achieve?"
    answers:
      - option: "Dependency injection by type"
        correct: true
      - option: "Bean instantiation"
        correct: false
      - option: "Property value injection"
        correct: false
      - option: "Method invocation"
        correct: false

  - description: "In what way can @Qualifier alter the behavior of @Autowired?"
    answers:
      - option: "By specifying which bean to inject when autowiring"
        correct: true
      - option: "It changes the scope of the bean being injected"
        correct: false
      - option: "It makes the injection optional"
        correct: false
      - option: "It injects all beans of the specified type into the target."
        correct: false

  - description: "Which Spring annotation is not directly related to dependency injection?"
    answers:
      - option: "@Value"
        correct: false
      - option: "@Autowired"
        correct: false
      - option: "@Qualifier"
        correct: false
      - option: "@TestPropertySource"
        correct: true

  - description: "What is the effect of combining @Autowired with @Qualifier in a Spring application?"
    answers:
      - option: "Precisely controls the bean that is injected into an autowired field or parameter"
        correct: true
      - option: "Automatically qualifies all beans of a given type as autowire candidates"
        correct: false
      - option: "Creates a new qualifier annotation for bean identification"
        correct: false
      - option: "Marks the autowired bean as primary within its context"
        correct: false

  - description: "How does @TestPropertySource enhance Spring tests?"
    answers:
      - option: "By overriding properties for the test environment"
        correct: true
      - option: "It specifies which properties file to ignore during testing"
        correct: false
      - option: "Enables dynamic property injection into tested beans"
        correct: false
      - option: "Automatically generates test properties based on the active profiles"
        correct: false

  - description: "Which annotation is used with SpringRunner to define the configuration for a test's application context?"
    answers:
      - option: "@ContextConfiguration"
        correct: true
      - option: "@RunWith"
        correct: false
      - option: "@MockBean"
        correct: false
      - option: "@Autowired"
        correct: false

  - description: "What is the main use of ReflectionTestUtils in Spring testing?"
    answers:
      - option: "For setting private fields in the class under test without needing setter methods"
        correct: true
      - option: "Reflecting the current state of the application context into the test context"
        correct: false
      - option: "Generating reflection-based proxies for tested beans"
        correct: false
      - option: "Injecting mock beans into private fields annotated with @Autowired"
        correct: false

  - description: "When is it necessary to use @MockBean in Spring testing?"
    answers:
      - option: "To replace or add beans in the Spring application context with mock objects"
        correct: true
      - option: "When the application context requires all beans to be mocked by default"
        correct: false
      - option: "To create a mock bean for each test method in the class"
        correct: false
      - option: "Mocking is required only for integration tests, not unit tests"
        correct: false

  - description: "What functionality does Mockito provide in Spring tests?"
    answers:
      - option: "Creating and injecting mock objects for testing purposes"
        correct: true
      - option: "Automating the generation of Spring application contexts"
        correct: false
      - option: "Compiling and running the application in a test environment"
        correct: false
      - option: "Injecting real bean instances instead of mocks"
        correct: false
  - description: "What are the essential annotations for Spring beans in Java configuration? (select 2)"
    answers:
      - option: "@Configuration"
        correct: true
      - option: "@Bean"
        correct: true
      - option: "@Entity"
        correct: false
      - option: "@Inject"
        correct: false
      - option: "@Service"
        correct: false

  - description: "Which annotations allow you to perform dependency injection in Spring? (select 2)"
    answers:
      - option: "@Autowired"
        correct: true
      - option: "@Inject"
        correct: true
      - option: "@Component"
        correct: false
      - option: "@Bean"
        correct: false
      - option: "@Qualifier"
        correct: true

  - description: "In Spring, which annotations are used to define a Spring bean directly in the application context? (select 2)"
    answers:
      - option: "@Component"
        correct: true
      - option: "@Service"
        correct: true
      - option: "@Entity"
        correct: false
      - option: "@Repository"
        correct: true
      - option: "@Controller"
        correct: true

  - description: "What are the benefits of using @ComponentScan in Spring? (select 2)"
    answers:
      - option: "It automatically detects Spring beans in the specified package"
        correct: true
      - option: "It configures beans using Java configuration"
        correct: false
      - option: "Enables auto-detection and registration of beans"
        correct: true
      - option: "Directly injects dependencies into components"
        correct: false
      - option: "Specifies custom bean naming strategies"
        correct: false

  - description: "Which of the following are true about the application context lifecycle in Spring? (select 2)"
    answers:
      - option: "The context is initialized with configuration metadata"
        correct: true
      - option: "Beans are instantiated and dependencies are injected"
        correct: true
      - option: "The context is automatically closed when the JVM shuts down"
        correct: false
      - option: "All beans are destroyed immediately after being used"
        correct: false
      - option: "The context provides support for resource loading"
        correct: true

  - description: "How can a Spring application context be closed? (select 2)"
    answers:
      - option: "By calling the close() method on the ConfigurableApplicationContext"
        correct: true
      - option: "Automatically upon JVM shutdown if registerShutdownHook() is called"
        correct: true
      - option: "Spring automatically closes the context in web applications"
        correct: true
      - option: "Using the @PreDestroy annotation on any bean"
        correct: false
      - option: "The context remains open until manually closed in non-web applications"
        correct: true

  - description: "What are valid ways to define beans in a Spring application? (select 2)"
    answers:
      - option: "Using the @Bean annotation in a @Configuration class"
        correct: true
      - option: "Annotating service classes with @Component"
        correct: true
      - option: "Declaring bean mappings in web.xml"
        correct: false
      - option: "Implementing the BeanFactory interface in bean classes"
        correct: false
      - option: "Using the @Autowired annotation on class fields"
        correct: false

  - description: "Which annotations are commonly used for dependency injection in Spring? (select 2)"
    answers:
      - option: "@Autowired"
        correct: true
      - option: "@Inject"
        correct: true
      - option: "@Configuration"
        correct: false
      - option: "@Qualifier"
        correct: true
      - option: "@Bean"
        correct: false

  - description: "What are the key steps in the lifecycle of a Spring bean? (select 2)"
    answers:
      - option: "Initialization of the bean"
        correct: true
      - option: "Dependency injection"
        correct: true
      - option: "Compilation of the bean class"
        correct: false
      - option: "Serialization of the bean"
        correct: false
  - description: "What are the two types of proxies that Spring can create? (select 2)"
    answers:
      - option: "JDK dynamic proxies"
        correct: true
      - option: "CGLIB proxies"
        correct: true
      - option: "Java dynamic proxies"
        correct: false
      - option: "ASM proxies"
        correct: false
      - option: "ByteBuddy proxies"
        correct: false

  - description: "What are the limitations of using JDK dynamic proxies in Spring? (select 2)"
    answers:
      - option: "Can only proxy interfaces"
        correct: true
      - option: "Requires CGLIB on the classpath"
        correct: false
      - option: "Cannot proxy final classes"
        correct: true
      - option: "Does not work with classes that don't implement interfaces"
        correct: true
      - option: "Only works with Spring-managed beans"
        correct: false

  - description: "What are the advantages of using CGLIB proxies over JDK dynamic proxies? (select 2)"
    answers:
      - option: "Can proxy classes without interfaces"
        correct: true
      - option: "Can proxy final methods"
        correct: false
      - option: "Doesn't require CGLIB on the classpath as it's bundled with Spring"
        correct: true
      - option: "Can intercept calls to static methods"
        correct: false
      - option: "Better performance for method invocation"
        correct: false

  - description: "For which scenario is it mandatory to use CGLIB proxies? (select 2)"
    answers:
      - option: "When proxying classes that don't implement any interfaces"
        correct: true
      - option: "When the class to be proxied is final"
        correct: false
      - option: "When proxying interfaces directly"
        correct: false
      - option: "When the proxied bean has no zero-arg constructor"
        correct: true
      - option: "When optimizing proxy creation for startup time"
        correct: false

  - description: "What are the disadvantages of using proxies in Spring? (select 2)"
    answers:
      - option: "Increased complexity in debugging"
        correct: true
      - option: "Potential overhead in memory usage"
        correct: true
      - option: "Incompatibility with newer Java versions"
        correct: false
      - option: "Automatic dependency injection is disabled"
        correct: false
      - option: "Proxies can only be used with Spring beans"
        correct: false
  - description: "Which proxy type does Spring prefer to use when both interfaces and class-based proxying are possible?"
    answers:
      - option: "JDK dynamic proxies"
        correct: true
      - option: "CGLIB proxies"
        correct: false
      - option: "Java dynamic proxies"
        correct: false
      - option: "Direct class proxies"
        correct: false

  - description: "What is required to force Spring to use CGLIB proxies even when interface-based proxying is possible?"
    answers:
      - option: "Annotate the class with @Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)"
        correct: true
      - option: "Set the proxyTargetClass attribute to true in @EnableAspectJAutoProxy"
        correct: false
      - option: "Use the @CGLIBProxy annotation"
        correct: false
      - option: "Spring automatically decides the proxy type"
        correct: false

  - description: "What is a common application of proxies in Spring applications?"
    answers:
      - option: "To add behavior to method calls such as transaction management"
        correct: true
      - option: "To enhance application security by proxying service calls"
        correct: false
      - option: "To dynamically generate bean implementations at runtime"
        correct: false
      - option: "To reduce memory footprint by lazily initializing beans"
        correct: false

  - description: "Which of the following is a disadvantage of CGLIB proxies?"
    answers:
      - option: "Cannot proxy final classes"
        correct: true
      - option: "Requires interfaces to be present"
        correct: false
      - option: "Not included with Spring, requires separate library"
        correct: false
      - option: "Limited to proxying public methods only"
        correct: false

  - description: "What mechanism does Spring use to decide whether to create a JDK dynamic proxy or a CGLIB proxy by default?"
    answers:
      - option: "Whether the proxied bean implements at least one interface"
        correct: true
      - option: "The presence of the CGLIB library on the classpath"
        correct: false
      - option: "The size of the proxied bean's class file"
        correct: false
      - option: "The JDK version running the application"
        correct: false
  - description: "What annotation enables CGLIB proxying in Spring configuration?"
    answers:
      - option: "@EnableAspectJAutoProxy(proxyTargetClass = true)"
        correct: true
      - option: "@EnableCGLIBProxies"
        correct: false
      - option: "@ProxyMode(CGLIB)"
        correct: false
      - option: "@CGLIBProxy"
        correct: false

  - description: "Which of the following is true about proxy objects in Spring?"
    answers:
      - option: "They allow for aspect-oriented programming features like transactions"
        correct: true
      - option: "They are created for every bean in the Spring context by default"
        correct: false
      - option: "Proxy objects directly extend the class they proxy"
        correct: false
      - option: "JDK dynamic proxies can proxy classes as well as interfaces"
        correct: false

  - description: "What is a limitation of JDK dynamic proxies in Spring?"
    answers:
      - option: "They cannot proxy classes that do not implement interfaces"
        correct: true
      - option: "They are incompatible with AspectJ"
        correct: false
      - option: "They can only proxy public methods"
        correct: false
      - option: "They significantly slow down the application startup time"
        correct: false

  - description: "What advantage does proxying provide in Spring?"
    answers:
      - option: "Enables declarative middleware services like transactions and security"
        correct: true
      - option: "Reduces the amount of boilerplate code required for cross-cutting concerns"
        correct: false
      - option: "Automatically generates interface implementations"
        correct: false
      - option: "Improves the performance of the application"
        correct: false

  - description: "Why might developers prefer using JDK dynamic proxies over CGLIB proxies?"
    answers:
      - option: "Less memory overhead compared to CGLIB proxies"
        correct: true
      - option: "Ability to proxy final methods and classes"
        correct: false
      - option: "Simpler to use due to no additional configuration"
        correct: false
      - option: "Better performance and speed during runtime"
        correct: false

  - description: "Which statement accurately describes the proxying mechanism used by Spring for transaction management?"
    answers:
      - option: "Uses JDK dynamic proxies for beans with interfaces and CGLIB for classes without interfaces"
        correct: true
      - option: "Exclusively uses CGLIB proxies for all beans regardless of interfaces"
        correct: false
      - option: "Transaction management in Spring does not utilize proxies"
        correct: false
      - option: "Always prefers using JDK dynamic proxies to avoid CGLIB dependency"
        correct: false

  - description: "What does setting proxyTargetClass to true in @EnableAspectJAutoProxy annotation effectuate?"
    answers:
      - option: "Forces Spring to use CGLIB proxies regardless of interface implementation"
        correct: true
      - option: "Disables proxying altogether, relying on direct bean injection"
        correct: false
      - option: "Makes all proxies implement the JDK dynamic proxy mechanism"
        correct: false
      - option: "Enables automatic detection of proxy strategy based on classpath dependencies"
        correct: false

  - description: "What is an advantage of aspect-oriented programming (AOP) with Spring proxies?"
    answers:
      - option: "Separates concerns by allowing cross-cutting concerns to be modularized"
        correct: true
      - option: "Increases the tight coupling between different parts of the application"
        correct: false
      - option: "Eliminates the need for interface-based design"
        correct: false
      - option: "Directly increases the application's throughput and efficiency"
        correct: false

  - description: "Which aspect of Spring's AOP support is facilitated by the use of proxies?"
    answers:
      - option: "Intercepting method calls to add additional behavior"
        correct: true
      - option: "Automatically persisting objects to a database"
        correct: false
      - option: "Validating method parameters and return types"
        correct: false
      - option: "Injecting dependencies into beans without configuration"
        correct: false

  - description: "How does Spring's AOP proxy mechanism relate to interface-based and class-based proxying?"
    answers:
      - option: "Chooses proxy strategy based on the presence of interfaces and configuration"
        correct: true
      - option: "Only supports interface-based proxying for AOP aspects"
        correct: false
      - option: "Relies exclusively on class-based proxying for applying aspects"
        correct: false
      - option: "Ignores proxy preferences and always uses JDK dynamic proxies"
        correct: false
  - description: "What is the primary disadvantage of using CGLIB proxies in Spring?"
    answers:
      - option: "They cannot proxy final classes or methods"
        correct: true
      - option: "Requires explicit configuration for each proxied bean"
        correct: false
      - option: "Significantly slower than JDK dynamic proxies"
        correct: false
      - option: "Incompatible with Java's native reflection"
        correct: false

  - description: "Which statement best describes a proxy object in the context of Spring?"
    answers:
      - option: "A proxy object acts as an intermediary for method calls to a target object, enabling additional behaviors like transactions."
        correct: true
      - option: "A proxy object replaces the original bean in the Spring context, modifying its core functionality."
        correct: false
      - option: "Proxy objects are used to directly access database entities without going through the service layer."
        correct: false
      - option: "Proxies are standalone objects that do not require Spring context for their functionality."
        correct: false

  - description: "How does Spring handle AOP proxy creation when both interfaces and class inheritance are available?"
    answers:
      - option: "Prefers JDK dynamic proxies for beans with interfaces, CGLIB for those without"
        correct: true
      - option: "Exclusively uses JDK dynamic proxies for consistency"
        correct: false
      - option: "CGLIB proxies are the default choice due to their flexibility"
        correct: false
      - option: "The choice between JDK and CGLIB proxies must be manually configured"
        correct: false

  - description: "What configuration ensures Spring uses CGLIB proxies even when interfaces are present?"
    answers:
      - option: "Setting proxyTargetClass=true in @EnableAspectJAutoProxy"
        correct: true
      - option: "Annotating the class with @CGLIBProxy"
        correct: false
      - option: "Using @Scope with proxyMode=ScopedProxyMode.TARGET_CLASS on the bean definition"
        correct: false
      - option: "There is no way to force CGLIB usage if interfaces are present"
        correct: false

  - description: "What advantage does Spring's AOP have over traditional middleware services?"
    answers:
      - option: "It allows for non-invasive addition of cross-cutting concerns without modifying the target object's code."
        correct: true
      - option: "It eliminates the need for any proxy mechanism, simplifying the application architecture."
        correct: false
      - option: "Spring AOP directly improves the performance of the application by optimizing bytecode."
        correct: false
      - option: "AOP in Spring automatically manages transactions without any configuration."
        correct: false

  - description: "Why are final methods and classes problematic for CGLIB proxies?"
    answers:
      - option: "CGLIB cannot override final methods or extend final classes, limiting proxy capabilities."
        correct: true
      - option: "Final methods and classes conflict with Spring's proxy mechanism, causing runtime errors."
        correct: false
      - option: "CGLIB uses a subclassing mechanism that is incompatible with Java's final keyword."
        correct: false
      - option: "Final classes and methods are automatically ignored by Spring, leading to potential bugs."
        correct: false
  - description: "What conditions must be met for Spring to create a JDK dynamic proxy? (select 2)"
    answers:
      - option: "The bean must implement at least one interface"
        correct: true
      - option: "The bean class must not be final"
        correct: true
      - option: "All methods in the bean must be declared as final"
        correct: false
      - option: "The application context must explicitly be configured to use JDK proxies"
        correct: false
      - option: "CGLIB is not available on the classpath"
        correct: false

  - description: "What are the key advantages of using Spring's proxy-based AOP support? (select 2)"
    answers:
      - option: "Allows for declarative transaction management"
        correct: true
      - option: "Enables centralized exception handling"
        correct: true
      - option: "Reduces the need for programming to interfaces"
        correct: false
      - option: "Eliminates the performance cost associated with aspect-oriented programming"
        correct: false
      - option: "Automatically applies proxying to all beans without needing configuration"
        correct: false

  - description: "Which are true regarding the limitations of proxy usage in Spring? (select 2)"
    answers:
      - option: "JDK dynamic proxies cannot intercept calls to static methods"
        correct: true
      - option: "CGLIB proxies can lead to increased memory footprint due to class generation"
        correct: true
      - option: "Proxies can significantly reduce the startup time of the Spring application"
        correct: false
      - option: "Dynamic proxies entirely prevent reflection usage on the proxied classes"
        correct: false
      - option: "CGLIB proxies are incompatible with beans that require constructor injection"
        correct: false

  - description: "Under what circumstances might CGLIB proxies be preferred over JDK dynamic proxies in Spring? (select 2)"
    answers:
      - option: "When the proxied class does not implement any interfaces"
        correct: true
      - option: "For optimizing the performance of method invocation through proxies"
        correct: false
      - option: "When needing to proxy methods of a concrete class rather than an interface"
        correct: true
      - option: "If the application requires proxies to be serializable"
        correct: false
      - option: "When the proxied bean has a final class definition"
        correct: false
  - description: "What are the disadvantages of proxy?"
    answers:
      - option: "Code might be hard to debug"
        correct: false
      - option: "All the declared exceptions needs to be unchecked"
        correct: false
      - option: "Might create performance issues in case the before and after method is use IO"
        correct: false
      - option: "Might create unexpected results if is used with equal to compere two objects"
        correct: false
      - option: "All from above"
        correct: true
  - description: "What is the primary purpose of a proxy object in Spring?"
    answers:
      - option: "To add additional logic to a class without changing its business logic"
        correct: true
      - option: "To directly implement business logic within the class"
        correct: false
      - option: "To reduce the memory footprint of an application"
        correct: false
      - option: "To manage the lifecycle of bean objects"
        correct: false

  - description: "Which of the following is NOT a correct use of proxy objects?"
    answers:
      - option: "Injecting dependencies"
        correct: false
      - option: "Implementing logging methods"
        correct: false
      - option: "Directly managing database transactions"
        correct: true
      - option: "Adding pre and post method execution logic"
        correct: false

  - description: "What types of proxies can Spring create?"
    answers:
      - option: "CGLIB and JDK Dynamic Proxies"
        correct: true
      - option: "Static and Dynamic Proxies"
        correct: false
      - option: "Bean and Component Proxies"
        correct: false
      - option: "AOP and AspectJ Proxies"
        correct: false

  - description: "What is a limitation of using JDK Dynamic Proxies in Spring?"
    answers:
      - option: "They can only proxy interfaces, not classes"
        correct: true
      - option: "They are significantly slower than CGLIB proxies"
        correct: false
      - option: "They cannot be used with bean objects"
        correct: false
      - option: "They do not support annotation-based configuration"
        correct: false

  - description: "Which of the following is an advantage of using proxy objects?"
    answers:
      - option: "They allow for aspect-oriented programming"
        correct: true
      - option: "They automatically handle all exceptions"
        correct: false
      - option: "They increase the performance of the application"
        correct: false
      - option: "They simplify the codebase by removing the need for interfaces"
        correct: false

  - description: "Can CGLIB proxies in Spring proxy classes without interfaces?"
    answers:
      - option: "Yes"
        correct: true
      - option: "No"
        correct: false

  - description: "Do JDK Dynamic Proxies support proxying classes directly?"
    answers:
      - option: "No"
        correct: true
      - option: "Yes"
        correct: false

  - description: "Is adding logging logic before and after method execution a common use case for proxy objects?"
    answers:
      - option: "Yes"
        correct: true
      - option: "No"
        correct: false

  - description: "Can proxy objects in Spring be used to manage transaction boundaries?"
    answers:
      - option: "Yes"
        correct: true
      - option: "No"
        correct: false

  - description: "Are proxy objects in Spring capable of injecting dependencies?"
    answers:
      - option: "No"
        correct: true
      - option: "Yes"
        correct: false

  - description: "Do proxy objects in Spring directly implement business logic?"
    answers:
      - option: "No"
        correct: true
      - option: "Yes"
        correct: false

  - description: "Can proxy objects in Spring reduce the memory footprint of an application?"
    answers:
      - option: "No"
        correct: true
      - option: "Yes"
        correct: false

  - description: "Are CGLIB proxies in Spring slower than JDK Dynamic Proxies?"
    answers:
      - option: "No"
        correct: true
      - option: "Yes"
        correct: false

  - description: "Can proxy objects manage the lifecycle of bean objects in Spring?"
    answers:
      - option: "No"
        correct: true
      - option: "Yes"
        correct: false

  - description: "Do proxy objects in Spring simplify the codebase by removing the need for interfaces?"
    answers:
      - option: "No"
        correct: true
      - option: "Yes"
        correct: false
  - description: "What is the primary disadvantage of using CGLIB proxies over JDK Dynamic Proxies in Spring?"
    answers:
      - option: "They cannot proxy final methods"
        correct: true
      - option: "They are not supported in Spring"
        correct: false
      - option: "They require classes to implement interfaces"
        correct: false
      - option: "They significantly decrease application performance"
        correct: false

  - description: "In Spring, which proxy type is preferred when the proxied bean implements an interface?"
    answers:
      - option: "JDK Dynamic Proxies"
        correct: true
      - option: "CGLIB Proxies"
        correct: false
      - option: "Static Proxies"
        correct: false
      - option: "No proxy is preferred in this scenario"
        correct: false

  - description: "Can Spring automatically choose the proxy mechanism (CGLIB or JDK Dynamic Proxies) based on the bean's characteristics?"
    answers:
      - option: "Yes"
        correct: true
      - option: "No"
        correct: false

  - description: "Is it possible to force Spring to use CGLIB proxies even if the bean implements an interface?"
    answers:
      - option: "Yes"
        correct: true
      - option: "No"
        correct: false

  - description: "What annotation can be used in Spring to ensure CGLIB proxies are used?"
    answers:
      - option: "@EnableAspectJAutoProxy(proxyTargetClass = true)"
        correct: true
      - option: "@ForceCGLIBProxy"
        correct: false
      - option: "@UseCGLIB"
        correct: false
      - option: "@ProxyMode(CGLIB)"
        correct: false

  - description: "Which Spring framework module is primarily responsible for managing aspects and proxies?"
    answers:
      - option: "Spring AOP"
        correct: true
      - option: "Spring Core"
        correct: false
      - option: "Spring MVC"
        correct: false
      - option: "Spring Security"
        correct: false

  - description: "In Spring AOP, which advice is NOT directly related to the proxy mechanism?"
    answers:
      - option: "@Transactional"
        correct: false
      - option: "@Before"
        correct: false
      - option: "@AfterReturning"
        correct: false
      - option: "@Repository"
        correct: true

  - description: "Are proxies in Spring used to facilitate the implementation of cross-cutting concerns?"
    answers:
      - option: "Yes"
        correct: true
      - option: "No"
        correct: false

  - description: "Can Spring's proxy objects be used to implement custom security checks before method execution?"
    answers:
      - option: "Yes"
        correct: true
      - option: "No"
        correct: false

  - description: "Is dynamic method matching at runtime a capability of Spring's proxy-based AOP?"
    answers:
      - option: "Yes"
        correct: true
      - option: "No"
        correct: false
  - description: "What does the `@Autowired` annotation do in Spring?"
    answers:
      - option: "It enables dependency injection in Spring."
        correct: true
      - option: "It is used to configure beans in XML files."
        correct: false
      - option: "It marks a class as a Spring bean."
        correct: false
      - option: "It creates a new bean instance for every injection."
        correct: false

  - description: "Which annotation is used along with `@Autowired` to specify a bean by name?"
    answers:
      - option: "`@Qualifier`"
        correct: true
      - option: "`@Primary`"
        correct: false
      - option: "`@Bean`"
        correct: false
      - option: "`@Component`"
        correct: false

  - description: "How can you resolve a NoUniqueBeanDefinitionException?"
    answers:
      - option: "By using the `@Qualifier` annotation to specify the bean to inject."
        correct: true
      - option: "By marking all conflicting beans as primary."
        correct: false
      - option: "By using the `@Primary` annotation on multiple beans."
        correct: false
      - option: "By renaming one of the beans."
        correct: false

  - description: "What does `@Component` annotation indicate in Spring?"
    answers:
      - option: "It marks a class as a candidate for auto-detection when using annotation-based configuration."
        correct: true
      - option: "It explicitly declares a method as a bean provider."
        correct: false
      - option: "It is used to inject properties from a properties file."
        correct: false
      - option: "It is used to create AOP proxies."
        correct: false

  - description: "What is the purpose of the `@Qualifier` annotation?"
    answers:
      - option: "It specifies which bean to inject when multiple beans qualify for autowiring."
        correct: true
      - option: "It marks a bean as the primary bean to be used for autowiring."
        correct: false
      - option: "It indicates that a bean should be lazily initialized."
        correct: false
      - option: "It declares that a bean is to be autowired by Spring's dependency injection facilities."
        correct: false

  - description: "Can `@Autowired` and `@Qualifier` annotations be used together?"
    answers:
      - option: "Yes"
        correct: true
      - option: "No"
        correct: false

  - description: "Is `@Autowired` capable of injecting bean dependencies by specifying the bean's name?"
    answers:
      - option: "No, `@Autowired` relies on type checking, and `@Qualifier` is used to specify the bean's name."
        correct: true
      - option: "Yes, `@Autowired` can directly specify the bean's name."
        correct: false
  - description: "What is a primary advantage of using Java Config over XML configuration in Spring?"
    answers:
      - option: "Provides compile-time feedback and type checking."
        correct: true
      - option: "Simplifies the syntax for bean definition."
        correct: false
      - option: "Eliminates the need for setters or constructors for dependency injection."
        correct: false
      - option: "Reduces the overall memory footprint of the application."
        correct: false

  - description: "Which of the following is NOT an advantage of Java Config in Spring?"
    answers:
      - option: "Eliminates runtime errors."
        correct: false
      - option: "Enables better refactoring support in IDEs."
        correct: false
      - option: "Automatically generates XML configuration files."
        correct: true
      - option: "Allows for immediate feedback on configuration errors during compilation."
        correct: false

  - description: "What does compile-time feedback in Java Config refer to?"
    answers:
      - option: "The ability to detect configuration errors before running the application."
        correct: true
      - option: "Feedback provided during the application runtime about performance."
        correct: false
      - option: "Notifications about successful bean creations during the application startup."
        correct: false
      - option: "The process of generating reports about bean dependencies post-compilation."
        correct: false

  - description: "Why is Java Config preferred for type-checking in Spring?"
    answers:
      - option: "It ensures that beans are correctly wired at compile time, preventing type mismatch errors."
        correct: true
      - option: "It dynamically changes bean types at runtime to prevent errors."
        correct: false
      - option: "Java Config uses special annotations that automatically adjust types."
        correct: false
      - option: "Type-checking is only possible through XML configuration, not Java Config."
        correct: false

  - description: "Which of the following is a limitation of XML configuration compared to Java Config in Spring?"
    answers:
      - option: "Lacks compile-time feedback, leading to potential runtime errors."
        correct: true
      - option: "Cannot define beans."
        correct: false
      - option: "XML configuration does not support dependency injection."
        correct: false
      - option: "XML files are automatically deleted after the application starts."
        correct: false

  - description: "Is refactoring easier with Java Config compared to XML configuration?"
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Does Java Config eliminate the need for XML configuration files in Spring?"
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false
  - description: "What is a proxy object in Spring?"
    answers:
      - option: "An object that is used to add additional logic to a class without modifying its source code."
        correct: true
      - option: "A direct reference to a bean that Spring manages."
        correct: false
      - option: "A special type of bean that Spring uses for configuration purposes."
        correct: false
      - option: "A core component of the Spring AOP framework for handling transactions."
        correct: false
      - option: "An annotation used to define transactional methods."
        correct: false

  - description: "Which of the following are types of proxies Spring can create?"
    answers:
      - option: "JDK dynamic proxies and CGLIB proxies"
        correct: true
      - option: "BeanFactory proxies and ApplicationContext proxies"
        correct: false
      - option: "Singleton proxies and Prototype proxies"
        correct: false
      - option: "HTTP proxies and TCP proxies"
        correct: false
      - option: "AspectJ proxies and Annotation proxies"
        correct: false

  - description: "All exceptions thrown by proxy methods must be unchecked exceptions."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Proxy objects can lead to unexpected results when using the equals method for comparison."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "What is one advantage of using proxy objects in Spring?"
    answers:
      - option: "They allow modifying the behavior of a bean without altering its source code."
        correct: true
      - option: "They improve the performance of the application by optimizing method calls."
        correct: false
      - option: "They automatically convert all exceptions to checked exceptions for better error handling."
        correct: false
      - option: "They enable direct access to the ApplicationContext from within the proxied object."
        correct: false

  - description: "What is a disadvantage of using proxy objects in Spring?"
    answers:
      - option: "Debugging can become more challenging due to the indirection added by proxies."
        correct: true
      - option: "Proxy objects significantly increase the memory footprint of the application."
        correct: false
      - option: "Spring does not support transaction management when using proxy objects."
        correct: false
      - option: "Proxies prevent the application from running in a multi-threaded environment."
        correct: false

  - description: "Can proxy objects in Spring lead to performance issues?"
    answers:
      - option: "Yes, especially if before and after methods involve I/O operations."
        correct: true
      - option: "No, proxy objects have no impact on the performance of the application."
        correct: false
      - option: "Only if the application uses more than 100 proxy objects."
        correct: false
      - option: "Performance issues only occur in web applications using proxy objects."
        correct: false
  - description: "What does the @Autowired annotation do in Spring?"
    answers:
      - option: "It enables dependency injection by type."
        correct: true
      - option: "It defines a bean in the Spring application context."
        correct: false
      - option: "It marks a class for component scanning."
        correct: false
      - option: "It configures the scope of a bean."
        correct: false

  - description: "Which annotation is used to resolve a specific bean when multiple candidates qualify for autowiring?"
    answers:
      - option: "@Qualifier"
        correct: true
      - option: "@Primary"
        correct: false
      - option: "@Bean"
        correct: false
      - option: "@Component"
        correct: false

  - description: "How can you specify a custom bean name when using @Component annotation?"
    answers:
      - option: "By providing a value to the @Component annotation."
        correct: true
      - option: "By using the @Bean annotation with a name attribute."
        correct: false
      - option: "By renaming the class to the desired bean name."
        correct: false
      - option: "By using the @Qualifier annotation on the class."
        correct: false

  - description: "Is it possible to use @Autowired on a constructor?"
    answers:
      - option: "Yes, to inject dependencies by constructor."
        correct: true
      - option: "No, @Autowired is only for fields and setter methods."
        correct: false
      - option: "Yes, but only if there is a single constructor."
        correct: false
      - option: "No, constructors cannot be autowired in Spring."
        correct: false

  - description: "What happens if Spring finds multiple beans of the same type for autowiring without any indication of which one to use?"
    answers:
      - option: "It throws a NoUniqueBeanDefinitionException."
        correct: true
      - option: "It injects all of them in a list."
        correct: false
      - option: "It chooses one randomly."
        correct: false
      - option: "It creates a new bean instance."
        correct: false
      - option: "It injects the primary bean."
        correct: false

  - description: "Can @Autowired be used with static fields?"
    answers:
      - option: "False, @Autowired cannot be used with static fields."
        correct: true
      - option: "True, @Autowired can be used with static fields."
        correct: false

  - description: "Does Spring's @Autowired annotation require explicit beans to be defined for all dependencies?"
    answers:
      - option: "False, Spring can auto-detect and configure beans."
        correct: true
      - option: "True, all dependencies must be explicitly defined."
        correct: false

  - description: "Is the @Qualifier annotation optional when there's only one bean of the required type?"
    answers:
      - option: "True, @Qualifier is not needed if only one bean of the type exists."
        correct: true
      - option: "False, @Qualifier is always required for autowiring."
        correct: false

  - description: "Can you use the @Autowired annotation on private fields?"
    answers:
      - option: "True, Spring can inject dependencies into private fields."
        correct: true
      - option: "False, only public fields can be autowired."
        correct: false

  - description: "Is the @Autowired annotation mandatory for constructor injection in Spring?"
    answers:
      - option: "False, as of Spring 4.3, if the class has only one constructor, @Autowired is not required."
        correct: true
      - option: "True, every constructor used for injection must be annotated with @Autowired."
        correct: false

  - description: "What is the default mode of autowiring in Spring?"
    answers:
      - option: "By type"
        correct: true
      - option: "By name"
        correct: false
      - option: "Constructor"
        correct: false
      - option: "No autowiring"
        correct: false

  - description: "What does the @Primary annotation do?"
    answers:
      - option: "It indicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency."
        correct: true
      - option: "It marks a bean as the primary source of configuration."
        correct: false
      - option: "It sets the bean to be injected by default if no @Qualifier is specified."
        correct: false
      - option: "It specifies the primary data source in a multi-database configuration."
        correct: false

  - description: "Can @Qualifier annotation be used together with @Autowired?"
    answers:
      - option: "Yes, to specify which bean to autowire when there are multiple candidates."
        correct: true
      - option: "No, @Qualifier is a standalone annotation."
        correct: false
      - option: "Yes, but only on setter methods."
        correct: false
      - option: "No, @Qualifier can only be used with @Resource."
        correct: false

  - description: "What does @Autowired(required=false) mean?"
    answers:
      - option: "It marks the dependency as optional, allowing Spring to skip autowiring if the bean is not available."
        correct: true
      - option: "It disables autowiring for the field or method."
        correct: false
      - option: "It makes the autowiring mandatory."
        correct: false
      - option: "It's an invalid use of the @Autowired annotation."
        correct: false

  - description: "What exception is thrown if a required bean for autowiring is not found and 'required' attribute of @Autowired is true?"
    answers:
      - option: "NoSuchBeanDefinitionException"
        correct: true
      - option: "BeanCreationException"
        correct: false
      - option: "BeanInstantiationException"
        correct: false
      - option: "NoUniqueBeanDefinitionException"
        correct: false

  - description: "Which types of autowiring does Spring support?"
    answers:
      - option: "Constructor, setter, and field injection"
        correct: true
      - option: "XML configuration and annotation-based only"
        correct: false
      - option: "Manual wiring only"
        correct: false
      - option: "Profile-driven and conditional only"
        correct: false
  - description: "What is a major advantage of using Java Config in Spring?"
    answers:
      - option: "It allows for type-safe configuration, improving code maintainability."
        correct: true
      - option: "It automatically generates bean definitions without developer input."
        correct: false
      - option: "Java Config eliminates the need for setter and constructor injection."
        correct: false
      - option: "It significantly reduces the startup time of Spring applications."
        correct: false

  - description: "Which of the following is a limitation of Java Config in Spring?"
    answers:
      - option: "Requires recompilation for changes, making it less flexible than XML."
        correct: true
      - option: "It does not support bean autowiring."
        correct: false
      - option: "Java Config cannot be used for AOP configuration."
        correct: false
      - option: "It is not supported in Spring Boot applications."
        correct: false

  - description: "Java Config in Spring supports externalized properties."
    answers:
      - option: "True, Java Config supports integrating externalized properties for configuration."
        correct: true
      - option: "False, externalized properties can only be used with XML configuration."
        correct: false

  - description: "Can Java Config in Spring coexist with XML configuration?"
    answers:
      - option: "True, Java Config and XML configurations can be mixed and matched as needed."
        correct: true
      - option: "False, Spring applications must use either Java Config or XML configuration exclusively."
        correct: false

  - description: "Is it possible to define multiple @Configuration classes in Spring?"
    answers:
      - option: "True, multiple @Configuration classes can be organized to modularize configuration."
        correct: true
      - option: "False, only one @Configuration class is allowed per Spring application."
        correct: false

  - description: "Does Java Config in Spring require more boilerplate code compared to annotations?"
    answers:
      - option: "False, Java Config uses annotations to reduce boilerplate code."
        correct: true
      - option: "True, Java Config significantly increases the amount of boilerplate code."
        correct: false

  - description: "Java Config is the preferred method for Spring Boot applications."
    answers:
      - option: "True, Java Config is commonly used in Spring Boot for its simplicity and integration features."
        correct: true
      - option: "False, Spring Boot applications primarily use XML configuration."
        correct: false

  - description: "Can Java Config be used to define bean profiles?"
    answers:
      - option: "Yes, @Profile annotation in Java Config allows for conditional bean registration."
        correct: true
      - option: "No, bean profiles can only be defined using XML configuration."
        correct: false

  - description: "Is annotation-based dependency injection supported by Java Config?"
    answers:
      - option: "Yes, Java Config supports annotation-based dependency injection using @Autowired and similar annotations."
        correct: true
      - option: "No, annotation-based dependency injection is not compatible with Java Config."
        correct: false

  - description: "Does Java Config support method injection in Spring?"
    answers:
      - option: "Yes, Java Config supports method injection using @Bean method definitions."
        correct: true
      - option: "No, method injection can only be achieved through XML configuration."
        correct: false

  - description: "A limitation of Java Config is its inability to be dynamically reloaded at runtime."
    answers:
      - option: "True, changes in Java Config require recompilation and application restart."
        correct: true
      - option: "False, Java Config can be dynamically reloaded without restarting the application."
        correct: false

  - description: "Java Config improves application performance by reducing runtime overhead."
    answers:
      - option: "False, while Java Config improves maintainability, it does not have a significant impact on performance."
        correct: true
      - option: "True, Java Config directly enhances the application's runtime performance."
        correct: false

  - description: "Java Config allows for better IDE support compared to XML configuration."
    answers:
      - option: "True, Java Config benefits from type checking and refactoring support in IDEs."
        correct: true
      - option: "False, XML configuration provides superior IDE support."
        correct: false

  - description: "Is explicit wiring required in Java Config?"
    answers:
      - option: "True, Java Config often requires more explicit wiring than annotation-based configuration."
        correct: true
      - option: "False, Java Config eliminates the need for explicit wiring."
        correct: false

  - description: "Java Config can integrate with JNDI data sources."
    answers:
      - option: "True, Java Config can be used to define and integrate JNDI data sources."
        correct: true
      - option: "False, JNDI data sources integration is not supported by Java Config."
        correct: false
  - description: "Which of the following are advantages of Java Config in Spring?"
    answers:
      - option: "Type-safe configuration."
        correct: true
      - option: "Support for externalized properties."
        correct: true
      - option: "Automatic detection of bean dependencies."
        correct: false
      - option: "Decreases the need for recompilation."
        correct: false
      - option: "Improves application performance."
        correct: false

  - description: "What are true statements about Java Config and XML Configuration coexistence?"
    answers:
      - option: "Java Config can be mixed with XML configurations."
        correct: true
      - option: "Java Config can import XML configuration files using the @ImportResource annotation."
        correct: true
      - option: "XML configuration can reference beans defined in Java Config."
        correct: true
      - option: "Using both requires manual wiring exclusively."
        correct: false
      - option: "Java Config always takes precedence over XML Configuration."
        correct: false

  - description: "Which features are supported by Java Config in Spring?"
    answers:
      - option: "Defining bean profiles with @Profile annotation."
        correct: true
      - option: "Method injection using @Bean methods."
        correct: true
      - option: "Annotation-based dependency injection."
        correct: true
      - option: "Dynamic reloading of configurations without restarting the application."
        correct: false
      - option: "Elimination of setter and constructor injection."
        correct: false

  - description: "What are limitations of Java Config in Spring?"
    answers:
      - option: "Requires recompilation for configuration changes."
        correct: true
      - option: "Cannot define beans dynamically at runtime."
        correct: true
      - option: "Limited IDE support compared to XML configuration."
        correct: false
      - option: "Inability to use with Spring Boot."
        correct: false
      - option: "Does not support externalized properties."
        correct: false

  - description: "Select the correct statements about @Autowired annotation with Java Config."
    answers:
      - option: "Can be used on constructor for dependency injection."
        correct: true
      - option: "Supports optional dependencies with (required=false)."
        correct: true
      - option: "Only applicable to bean methods defined in @Configuration classes."
        correct: false
      - option: "Can inject static fields."
        correct: false
      - option: "Requires explicit bean definitions for all dependencies."
        correct: false

  - description: "Java Config is the preferred method of configuration in Spring Boot."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Spring's Java Config allows for dynamic reloading of configurations at runtime."
    answers:
      - option: "False"
        correct: true
      - option: "True"
        correct: false

  - description: "@Autowired annotation is mandatory for constructor injection in Spring's Java Config."
    answers:
      - option: "False"
        correct: true
      - option: "True"
        correct: false

  - description: "Java Config supports method injection in Spring."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Using Java Config requires more explicit wiring compared to using annotations alone."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which annotation indicates a primary bean when multiple beans qualify for autowiring?"
    answers:
      - option: "@Primary"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Bean"
        correct: false
      - option: "@Qualifier"
        correct: false

  - description: "Is explicit bean definition required in Java Config for autowiring to work?"
    answers:
      - option: "Yes, beans must be defined in @Configuration classes."
        correct: true
      - option: "No, Spring automatically detects and configures beans."
        correct: false
      - option: "Yes, but only for @Service and @Repository beans."
        correct: false
      - option: "No, beans defined in XML configuration are sufficient."
        correct: false

  - description: "Can Java Config and XML configurations be used together in a Spring application?"
    answers:
      - option: "Yes, they can be integrated seamlessly."
        correct: true
      - option: "No, a Spring application must use one configuration method exclusively."
        correct: false
      - option: "Yes, but only if Java Config is used to import XML configurations."
        correct: false
      - option: "No, XML configurations cannot reference beans defined in Java Config."
        correct: false

  - description: "What does the @Configuration annotation do in Spring?"
    answers:
      - option: "Indicates that a class declares one or more @Bean methods."
        correct: true
      - option: "Marks a class as a source of bean definitions."
        correct: false
      - option: "Automatically scans for bean definitions in the classpath."
        correct: false
      - option: "Specifies the primary bean to be used for autowiring."
        correct: false

  - description: "Is the @Qualifier annotation necessary when there's only one bean candidate for autowiring?"
    answers:
      - option: "No, it is not necessary if there is only one candidate."
        correct: true
      - option: "Yes, it must be used for all autowired beans."
        correct: false
      - option: "No, but it's recommended for clearer configuration."
        correct: false
      - option: "Yes, to specify the bean name explicitly."
        correct: false
  - description: "Which of the following is an advantage of using Java Config in Spring?"
    answers:
      - option: "Allows for centralized and type-safe configuration."
        correct: true
      - option: "Automatically resolves circular dependencies."
        correct: false
      - option: "Reduces the startup time of Spring applications."
        correct: false
      - option: "Eliminates the need for any form of configuration."
        correct: false

  - description: "Java Config in Spring:"
    answers:
      - option: "Supports @Profile annotation for environment-based configuration."
        correct: true
      - option: "Can only be used for MVC applications."
        correct: false
      - option: "Does not allow for bean definition overriding."
        correct: false
      - option: "Requires XML files for bean definition."
        correct: false

  - description: "Which statements are true regarding Java Config in Spring?"
    answers:
      - option: "Enables the integration of Java-based configuration alongside XML configuration."
        correct: true
      - option: "Improves the clarity and maintainability of configuration."
        correct: true
      - option: "Java Config cannot be combined with component scanning."
        correct: false
      - option: "It is less powerful than XML configuration."
        correct: false
      - option: "Supports conditional bean registration using @Conditional."
        correct: true

  - description: "What limitations does Java Config have in Spring?"
    answers:
      - option: "Changes require recompilation and application restart."
        correct: true
      - option: "Cannot define dynamic beans at runtime."
        correct: true
      - option: "Limited support for legacy Spring projects."
        correct: false
      - option: "Incompatible with Spring Boot applications."
        correct: false
      - option: "Does not support externalized property configuration."
        correct: false

  - description: "In Spring's Java Config, @Autowired can be used for:"
    answers:
      - option: "Constructor injection."
        correct: true
      - option: "Field injection."
        correct: true
      - option: "Method injection."
        correct: true
      - option: "Static method injection."
        correct: false
      - option: "Directly injecting properties from properties files without @Value."
        correct: false

  - description: "Is @Configuration annotation necessary for defining beans in Java Config?"
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Java Config requires manual wiring of beans."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Java Config supports autowiring by type and by name."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "@Value annotation is used in Java Config to inject property values."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Java Config can only be used within Spring Boot applications."
    answers:
      - option: "False"
        correct: true
      - option: "True"
        correct: false

  - description: "What does the @Bean annotation do in Java Config?"
    answers:
      - option: "Indicates a method that produces a bean to be managed by the Spring container."
        correct: true
      - option: "Marks a class as capable of producing beans autonomously."
        correct: false
      - option: "Specifies that a method should be autowired."
        correct: false
      - option: "Designates a class as a configuration class."
        correct: false

  - description: "Which of the following is a limitation of Java Config?"
    answers:
      - option: "It cannot wire beans across different application contexts."
        correct: true
      - option: "It does not support injection of primitive types."
        correct: false
      - option: "It only works with Spring MVC applications."
        correct: false
      - option: "It requires an XML file to define beans."
        correct: false

  - description: "Can you use @Autowired in combination with @Qualifier in Java Config?"
    answers:
      - option: "Yes, to specify which bean to autowire when there are multiple candidates."
        correct: true
      - option: "No, @Qualifier can only be used with XML configuration."
        correct: false
      - option: "Yes, but only within @Configuration annotated classes."
        correct: false
      - option: "No, @Autowired alone is sufficient for all types of autowiring."
        correct: false

  - description: "What is required to use Java Config in a Spring application?"
    answers:
      - option: "Annotated classes with @Configuration or @Component."
        correct: true
      - option: "A complete absence of XML configuration files."
        correct: false
      - option: "Exclusive use of constructor injection."
        correct: false
      - option: "A dependency on Spring AOP."
        correct: false

  - description: "Java Config makes it easier to:"
    answers:
      - option: "Refactor and navigate the codebase using IDEs."
        correct: true
      - option: "Eliminate the need for any form of explicit configuration."
        correct: false
      - option: "Avoid using annotations for configuration purposes."
        correct: false
      - option: "Configure Spring security without any additional setup."
        correct: false
  - description: "Which of the following are advantages of using Java Config in Spring?"
    answers:
      - option: "Allows for centralized and type-safe configuration."
        correct: true
      - option: "Supports integration of Java-based and XML-based configurations."
        correct: true
      - option: "Automatically generates XML configuration files."
        correct: false
      - option: "Reduces application startup time significantly."
        correct: false
      - option: "Eliminates the need for annotation-based configuration."
        correct: false

  - description: "What features are supported by Java Config in Spring?"
    answers:
      - option: "Defining bean profiles with @Profile annotation."
        correct: true
      - option: "Externalized configuration through @PropertySource."
        correct: true
      - option: "Dynamic reloading of bean definitions at runtime without restarting the application."
        correct: false
      - option: "Automatic conversion of Java Config to XML format."
        correct: false
      - option: "In-built support for microservice architecture patterns."
        correct: false

  - description: "Which statements accurately describe the use of @Autowired in Spring's Java Config?"
    answers:
      - option: "Can be used on constructors to inject dependencies."
        correct: true
      - option: "Supports field injection without requiring setters."
        correct: true
      - option: "It's mandatory for all beans, regardless of the number of constructors."
        correct: false
      - option: "Only applicable for beans defined in XML configuration files."
        correct: false
      - option: "Requires explicit bean name specification in every use."
        correct: false

  - description: "Regarding Spring's Java Config, select the true statements."
    answers:
      - option: "Enables conditional bean registration with @Conditional."
        correct: true
      - option: "Facilitates method injection through @Bean annotated methods."
        correct: true
      - option: "Java Config-based beans are prioritized over XML-defined beans by default."
        correct: false
      - option: "Dependent beans are automatically re-instantiated when a @Bean method's implementation changes."
        correct: false
      - option: "Configuration classes are automatically discovered without being specified in any way."
        correct: false

  - description: "Select the correct applications of annotations in Spring's Java Config."
    answers:
      - option: "@Qualifier can be used to specify which bean to autowire among several types."
        correct: true
      - option: "@Primary can be used to give a bean precedence when multiple beans match a given dependency."
        correct: true
      - option: "@Autowired is necessary on only one constructor in a bean class, regardless of the number of constructors."
        correct: false
      - option: "@Configuration is required on every class in the application context."
        correct: false
      - option: "@Bean methods can only be defined in classes annotated with @Repository."
        correct: false

  - description: "Which are true about the @Bean annotation?"
    answers:
      - option: "It can be used only within classes annotated with @Configuration."
        correct: true
      - option: "Beans defined with @Bean can participate in Spring's dependency injection."
        correct: true
      - option: "@Bean annotated methods can only return void."
        correct: false
      - option: "It supports only singleton scope."
        correct: false
      - option: "It is used to specify URL mappings in a web application."
        correct: false

  - description: "What is required for a @Bean annotated method to be processed by Spring?"
    answers:
      - option: "The containing class must be annotated with @Configuration."
        correct: true
      - option: "The method must be public."
        correct: false
      - option: "The application context must be manually refreshed after defining beans."
        correct: false
      - option: "The method must have a void return type."
        correct: false

  - description: "Can @Bean annotated methods be declared in any Spring-managed component?"
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Is it possible to define multiple beans of the same type with different methods annotated with @Bean?"
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false
  - description: "What scope do beans have by default when defined using the @Bean annotation?"
    answers:
      - option: "Singleton"
        correct: true
      - option: "Prototype"
        correct: false
      - option: "Request"
        correct: false
      - option: "Session"
        correct: false

  - description: "In which scenario is it beneficial to use @Bean annotated methods within @Configuration annotated classes?"
    answers:
      - option: "When you need to perform additional configuration not supported by component-scanning."
        correct: true
      - option: "Only when defining MVC controllers."
        correct: false
      - option: "When the beans have no dependencies on other beans within the application context."
        correct: false
      - option: "It is never beneficial; component-scanning should always be used instead."
        correct: false

  - description: "Can beans defined with @Bean annotation depend on other beans in the Spring application context?"
    answers:
      - option: "True, they can depend on other beans and Spring will resolve these dependencies."
        correct: true
      - option: "False, beans defined with @Bean must be completely independent."
        correct: false

  - description: "Is it possible to override a bean definition by defining another @Bean method with the same name in the same @Configuration class?"
    answers:
      - option: "False, Spring does not allow overriding beans within the same configuration class."
        correct: true
      - option: "True, the last @Bean definition for the same name will override the others."
        correct: false

  - description: "Can the @Bean annotation be used together with @Profile to conditionally define beans?"
    answers:
      - option: "Yes, combining @Bean with @Profile allows conditional bean registration based on the active profiles."
        correct: true
      - option: "No, @Bean cannot be used in conjunction with @Profile."
        correct: false

  - description: "Which of the following is a correct way to define a bean with a custom name using @Bean?"
    answers:
      - option: "@Bean(name = \"customBeanName\")"
        correct: true
      - option: "@Bean(value = \"customBeanName\")"
        correct: false
      - option: "@Bean(beanName = \"customBeanName\")"
        correct: false
      - option: "@Bean(id = \"customBeanName\")"
        correct: false

  - description: "What does the @Bean annotation utilize to provide dependency injection capabilities?"
    answers:
      - option: "Method parameters for constructor-based injection."
        correct: true
      - option: "Direct field access without using constructors or setters."
        correct: false
      - option: "Java reflection API to instantiate bean properties directly."
        correct: false
      - option: "Static methods exclusively to create bean instances."
        correct: false

  - description: "How does Spring Framework treat a method annotated with @Bean in terms of bean lifecycle callbacks (such as @PostConstruct and @PreDestroy)?"
    answers:
      - option: "Spring manages the lifecycle callbacks for beans created with @Bean, including calling @PostConstruct and @PreDestroy methods."
        correct: true
      - option: "Beans created with @Bean do not support lifecycle callbacks."
        correct: false
      - option: "Lifecycle callbacks must be manually invoked for beans defined using @Bean."
        correct: false
      - option: "Only @PostConstruct is supported for beans created with @Bean, while @PreDestroy is not."
        correct: false

  - description: "Is it mandatory to use the @Configuration annotation on a class containing methods annotated with @Bean?"
    answers:
      - option: "True, the class must be annotated with @Configuration to process @Bean annotations."
        correct: false
      - option: "False, while it's common to use @Configuration, it's not strictly required."
        correct: true

  - description: "Can you use @Autowired on methods annotated with @Bean to inject dependencies?"
    answers:
      - option: "Yes, @Autowired can be used on @Bean methods to inject required dependencies into the method parameters."
        correct: true
      - option: "No, @Autowired is not compatible with @Bean annotated methods."
        correct: false
  - description: "Why can't classes annotated with @Configuration be final?"
    answers:
      - option: "Spring uses CGLIB to create a proxy of the configuration class, which requires the class to be non-final."
        correct: true
      - option: "Final classes enhance performance by allowing faster instantiation."
        correct: false
      - option: "Spring cannot inject dependencies into final classes."
        correct: false
      - option: "Final classes are not supported in Java."
        correct: false

  - description: "How do @Configuration annotated classes support singleton beans?"
    answers:
      - option: "By using CGLIB proxies to intercept bean method calls and ensure only one instance is created."
        correct: true
      - option: "Singleton beans are not supported by @Configuration classes."
        correct: false
      - option: "Through manual instantiation of beans inside the configuration class."
        correct: false
      - option: "By marking the beans as @Singleton alongside @Bean."
        correct: false

  - description: "Why can't methods annotated with @Bean be final?"
    answers:
      - option: "Because Spring needs to override these methods in the CGLIB proxy to control bean instantiation."
        correct: true
      - option: "@Bean methods can be final as long as they are static."
        correct: false
      - option: "Final methods improve the application's security by preventing bean modifications."
        correct: false
      - option: "Final methods are automatically considered beans without needing annotations."
        correct: false

  - description: "What exception does Spring throw if it cannot create a proxy for a @Configuration class?"
    answers:
      - option: "BeanDefinitionParsingException"
        correct: true
      - option: "NoSuchBeanDefinitionException"
        correct: false
      - option: "BeanCreationException"
        correct: false
      - option: "NoUniqueBeanDefinitionException"
        correct: false

  - description: "Are @Scope(\"Prototype\") annotated beans also proxied in the same way as singleton beans?"
    answers:
      - option: "Yes, but since each request creates a new instance, the proxy behavior differs."
        correct: true
      - option: "No, prototype beans are not proxied because they are not singletons."
        correct: false
      - option: "Yes, all beans regardless of their scope are proxied in the same manner."
        correct: false
      - option: "No, prototype beans use a different mechanism for instantiation."
        correct: false

  - description: "True or False: Final classes annotated with @Configuration can still be used by Spring if no proxying is required."
    answers:
      - option: "False, Spring requires non-final classes for proxy creation regardless of the necessity."
        correct: true
      - option: "True, Spring can use final @Configuration classes without proxying."
        correct: false

  - description: "True or False: Methods within a @Configuration annotated class can be final if they do not return a bean."
    answers:
      - option: "False, methods should not be final to allow proxying."
        correct: true
      - option: "True, non-bean-returning methods can be final."
        correct: false

  - description: "Can @Configuration annotated classes be abstract?"
    answers:
      - option: "Yes, abstract classes can be annotated with @Configuration."
        correct: true
      - option: "No, abstract classes cannot be used with @Configuration."
        correct: false
      - option: "Yes, but only if they do not contain any @Bean annotated methods."
        correct: false
      - option: "No, because Spring cannot instantiate abstract classes directly."
        correct: false

  - description: "What role does CGLIB play in the context of @Configuration annotated classes?"
    answers:
      - option: "CGLIB is used to create a subclass proxy to manage bean creation and ensure the singleton property."
        correct: true
      - option: "CGLIB directly instantiates beans bypassing the Spring container."
        correct: false
      - option: "CGLIB validates the configuration before Spring processes it."
        correct: false
      - option: "CGLIB optimizes the performance of bean instantiation."
        correct: false

  - description: "What happens if a @Bean annotated method in a @Configuration class is static?"
    answers:
      - option: "Spring does not create a CGLIB proxy for static @Bean methods."
        correct: true
      - option: "Static @Bean methods are ignored by Spring."
        correct: false
      - option: "A BeanInstantiationException is thrown."
        correct: false
      - option: "The bean is registered as a prototype regardless of its actual scope."
        correct: false
  - description: "What does the @Bean annotation do in Spring?"
    answers:
      - option: "Indicates that a method produces a bean to be managed by the Spring container."
        correct: true
      - option: "Automatically injects dependencies into Spring beans."
        correct: false
      - option: "Specifies URL mappings for Spring MVC controllers."
        correct: false
      - option: "Marks a class as a Spring component."
        correct: false

  - description: "Which annotations are necessary for dependency injection in Spring?"
    answers:
      - option: "@Autowired"
        correct: true
      - option: "@Inject"
        correct: true
      - option: "@Service"
        correct: false
      - option: "@Entity"
        correct: false
      - option: "@Repository"
        correct: false

  - description: "Is it possible to use @Autowired on private fields?"
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "What is the purpose of the @ComponentScan annotation?"
    answers:
      - option: "It enables Spring to scan for components, configurations, and services in the specified packages."
        correct: true
      - option: "It directly configures bean definitions."
        correct: false
      - option: "It is used to define URL mappings for a Spring MVC application."
        correct: false
      - option: "It specifies the scope of a bean."
        correct: false

  - description: "Can @Bean annotated methods have parameters in Spring?"
    answers:
      - option: "Yes, parameters can be used for dependency injection."
        correct: true
      - option: "No, @Bean methods must not have any parameters."
        correct: false
      - option: "Yes, but parameters must be annotated with @Value."
        correct: false
      - option: "No, all dependencies must be set using setter injection."
        correct: false

  - description: "Does Spring support method injection with @Autowired annotation?"
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "What is the default scope of Spring beans defined with @Bean annotation?"
    answers:
      - option: "Singleton"
        correct: true
      - option: "Prototype"
        correct: false
      - option: "Request"
        correct: false
      - option: "Session"
        correct: false

  - description: "Can a Spring bean defined with @Bean annotation be overridden in the same configuration class?"
    answers:
      - option: "No, Spring does not allow overriding beans within the same configuration class."
        correct: true
      - option: "Yes, the last @Bean definition for the same name will override the others."
        correct: false
      - option: "Yes, but only if both beans are annotated with @Primary."
        correct: false
      - option: "No, bean definitions are immutable once created."
        correct: false

  - description: "Are beans defined with the @Bean annotation in a @Configuration annotated class singleton by default?"
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which of the following is true about the use of @Qualifier annotation?"
    answers:
      - option: "It is used to specify which bean to autowire when there are multiple candidates."
        correct: true
      - option: "It defines a new bean in the Spring application context."
        correct: false
      - option: "It changes the default scope of a bean to prototype."
        correct: false
      - option: "It is used to mark a method as a factory for creating beans."
        correct: false

  - description: "Can @Profile annotation be used with @Bean methods?"
    answers:
      - option: "Yes, to conditionally load beans based on the active Spring profiles."
        correct: true
      - option: "No, @Profile can only be used at the class level."
        correct: false
      - option: "Yes, but only if the @Bean method is static."
        correct: false
      - option: "No, @Profile is not compatible with @Bean annotation."
        correct: false

  - description: "Is it necessary to explicitly call the ApplicationContext.close() method in a Spring application?"
    answers:
      - option: "Yes, to ensure all the beans are properly disposed and @PreDestroy methods are called."
        correct: true
      - option: "No, Spring automatically closes the ApplicationContext on JVM shutdown."
        correct: false
      - option: "Yes, but only for web applications running in a standalone container."
        correct: false
      - option: "No, closing the ApplicationContext is optional and only recommended for large applications."
        correct: false

  - description: "What is the purpose of the @Primary annotation in Spring?"
    answers:
      - option: "It indicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency."
        correct: true
      - option: "It specifies that a bean is only available during the primary stage of the application."
        correct: false
      - option: "It marks the primary constructor to be used for autowiring."
        correct: false
      - option: "It designates the main class of a Spring Boot application."
        correct: false

  - description: "Can @Autowired be used on static fields?"
    answers:
      - option: "False, @Autowired cannot be used with static fields."
        correct: true
      - option: "True, @Autowired can be used with static fields."
        correct: false

  - description: "What is the primary function of the @Bean annotation in Spring?"
    answers:
      - option: "It declares a method to return an object that should be registered as a bean in the Spring application context."
        correct: true
      - option: "It automatically detects and registers beans without explicit declarations."
        correct: false
      - option: "It marks a class as a Spring component that can be auto-detected through classpath scanning."
        correct: false
      - option: "It is used to inject dependencies into Spring beans."
        correct: false

  - description: "In which type of classes is the @Bean annotation usually used?"
    answers:
      - option: "In classes annotated with @Configuration to indicate that a method instantiates, configures, and initializes a new object to be managed by the Spring IoC container."
        correct: true
      - option: "Inside classes annotated with @Service to define service beans explicitly."
        correct: false
      - option: "On field declarations within @Component classes to specify bean injection."
        correct: false
      - option: "Within @Repository annotated classes to create data access object beans."
        correct: false

  - description: "Which of the following statements are true regarding the @Bean annotation?"
    answers:
      - option: "The method annotated with @Bean can have any visibility (public, protected, private)."
        correct: true
      - option: "The @Bean annotation supports specifying initialization and destruction callback methods."
        correct: true
      - option: "@Bean annotated methods must always return the same instance type."
        correct: false
      - option: "Beans defined with @Bean annotation are always singleton scoped unless explicitly specified."
        correct: true
      - option: "The @Bean annotation can be used on methods in any class, not just those annotated with @Configuration."
        correct: false

  - description: "True or False: The @Bean annotation can only be used within classes annotated with @Configuration."
    answers:
      - option: "False"
        correct: true
      - option: "True"
        correct: false

  - description: "True or False: Methods annotated with @Bean can only return one specific type of bean."
    answers:
      - option: "False"
        correct: true
      - option: "True"
        correct: false

  - description: "What is required for a method annotated with @Bean to be recognized by the Spring container?"
    answers:
      - option: "The method must be declared in a class annotated with @Configuration or in a configuration class registered with the Spring container."
        correct: true
      - option: "The return type of the method must be annotated with @Component."
        correct: false
      - option: "The method must be static."
        correct: false
      - option: "The method must be public."
        correct: false

  - description: "Can a @Bean annotated method specify a custom initialization method for the bean?"
    answers:
      - option: "Yes, by using the initMethod attribute of the @Bean annotation."
        correct: true
      - option: "No, beans instantiated by @Bean annotated methods cannot have custom initialization methods."
        correct: false
      - option: "Yes, but only if the bean class is annotated with @PostConstruct."
        correct: false
      - option: "No, custom initialization methods are only supported for beans defined in XML configuration."
        correct: false

  - description: "Is it possible to define multiple beans of the same type but with different names using the @Bean annotation?"
    answers:
      - option: "Yes, by specifying different names using the name attribute of the @Bean annotation."
        correct: true
      - option: "No, the Spring container does not allow multiple beans of the same type with different names."
        correct: false
      - option: "Yes, but only if the beans are defined in separate configuration classes."
        correct: false
      - option: "No, all beans of the same type must be defined with the same name."
        correct: false

  - description: "What happens if a @Bean annotated method is invoked directly?"
    answers:
      - option: "The method executes like any other Java method, but Spring does not manage the bean lifecycle for the returned object."
        correct: true
      - option: "Spring throws an exception because @Bean methods cannot be invoked directly."
        correct: false
      - option: "The returned object is automatically registered in the Spring application context."
        correct: false
      - option: "The invocation is redirected to the Spring container to ensure the bean is properly managed."
        correct: false

  - description: "Can beans defined with the @Bean annotation be injected into other beans in the Spring context?"
    answers:
      - option: "Yes, beans defined with @Bean can be injected into other beans using standard Spring dependency injection techniques."
        correct: true
      - option: "No, @Bean defined beans cannot be injected into other beans."
        correct: false
      - option: "Yes, but only if they are defined within the same @Configuration class."
        correct: false
      - option: "No, beans must be defined in XML to be injected into other beans."
        correct: false

  - description: "Does the @Bean annotation support specifying custom destroy methods for beans?"
    answers:
      - option: "Yes, by using the destroyMethod attribute of the @Bean annotation."
        correct: true
      - option: "No, custom destroy methods are not supported for @Bean annotated beans."
        correct: false
      - option: "Yes, but the method must also be annotated with @PreDestroy."
        correct: false
      - option: "No, beans created with @Bean are always destroyed by the garbage collector without any custom logic."
        correct: false

  - description: "True or False: @Bean annotated methods can have parameters, which will be autowired by Spring."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "True or False: @Bean methods must be non-static."
    answers:
      - option: "False, @Bean methods can be static, and it's recommended for certain cases."
        correct: true
      - option: "True, static methods are not supported with @Bean annotation."
        correct: false

  - description: "Which of the following is true about defining beans with the @Bean annotation in a non-@Configuration annotated class?"
    answers:
      - option: "The beans are still managed by Spring, but such configuration classes are not enhanced with CGLIB proxies."
        correct: true
      - option: "Spring ignores @Bean annotations in non-@Configuration annotated classes."
        correct: false
      - option: "Beans defined this way are automatically considered prototype scoped."
        correct: false
      - option: "It's not possible; @Bean annotations are strictly limited to @Configuration classes."
        correct: false

  - description: "What is the effect of declaring a @Bean annotated method as static?"
    answers:
      - option: "Static @Bean methods do not require the containing @Configuration class to be instantiated, which can improve performance."
        correct: true
      - option: "Static @Bean methods are ignored by Spring and not processed."
        correct: false
      - option: "Beans created from static methods are automatically scoped as singletons."
        correct: false
      - option: "It forces the bean to be lazily initialized, regardless of the lazy attribute setting."
        correct: false

  - description: "How can you specify the scope of a bean defined with the @Bean annotation?"
    answers:
      - option: "By using the @Scope annotation alongside @Bean."
        correct: true
      - option: "Scope is determined automatically by Spring and cannot be set manually."
        correct: false
      - option: "By including the scope in the method name, like singletonMyBean()."
        correct: false
      - option: "Scopes are only configurable for beans defined in XML."
        correct: false

  - description: "Are beans defined with @Bean in a @Configuration class subject to AOP aspects?"
    answers:
      - option: "Yes, beans defined this way can be intercepted by aspects."
        correct: true
      - option: "No, AOP aspects do not apply to beans created with @Bean."
        correct: false
      - option: "Yes, but only if the @EnableAspectJAutoProxy annotation is present on the configuration class."
        correct: true
      - option: "No, aspect-oriented programming only works with beans defined through component scanning."
        correct: false

  - description: "True or False: It is possible to define a bean without a name, in which case Spring generates a default name."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false
  - description: "Which Spring framework annotation is used to autowire bean on setter methods?"
    answers:
      - option: "@Autowired"
        correct: true
      - option: "@Bean"
        correct: false
      - option: "@Inject"
        correct: false
      - option: "@Resource"
        correct: false

  - description: "What does the @Qualifier annotation do when used with @Autowired?"
    answers:
      - option: "It helps fine-tune annotation-based autowiring with more control."
        correct: true
      - option: "It replaces the functionality of @Autowired."
        correct: false
      - option: "It marks a bean as primary when multiple beans qualify for autowiring."
        correct: false
      - option: "It is used to create asynchronous methods."
        correct: false
      - option: "It specifies the name of the bean to be autowired."
        correct: true

  - description: "True or False: The @Primary annotation allows you to give higher preference to a bean when multiple beans qualify for autowiring."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "True or False: @Autowired can be used on fields, setter methods, and constructors."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "What is the purpose of the @Profile annotation in Spring?"
    answers:
      - option: "It indicates that a component is only eligible for registration when one or more specified profiles are active."
        correct: true
      - option: "It defines a method that should be autowired."
        correct: false
      - option: "It specifies a default bean to be used when no profile is active."
        correct: false
      - option: "It is used to annotate primary beans."
        correct: false

  - description: "Can the @Autowired annotation be used on private fields?"
    answers:
      - option: "Yes, but it's not recommended due to encapsulation principles."
        correct: true
      - option: "No, access modifiers prevent @Autowired from working on private fields."
        correct: false
      - option: "Yes, and it is the preferred approach for autowiring in Spring."
        correct: false
      - option: "No, Spring Security policies restrict this usage."
        correct: false

  - description: "Which annotation should be used to autowire beans by type if more than one bean of the same type exists in the Spring container?"
    answers:
      - option: "@Qualifier"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Inject"
        correct: false
      - option: "@Primary"
        correct: false
      - option: "@Resource"
        correct: false

  - description: "What mechanism does Spring use to resolve the bean to be injected when using @Autowired without @Qualifier?"
    answers:
      - option: "By type"
        correct: true
      - option: "By name"
        correct: false
      - option: "By qualifier value"
        correct: false
      - option: "By bean definition order"
        correct: false
      - option: "By accessing the primary bean"
        correct: false

  - description: "How can you declare a bean to be lazily initialized in Spring?"
    answers:
      - option: "By annotating the bean method with @Lazy"
        correct: true
      - option: "Using the 'lazy-init=true' attribute in bean definition XML"
        correct: true
      - option: "By setting @Autowired(required=false)"
        correct: false
      - option: "Marking the bean with @Component only"
        correct: false
      - option: "Using @Qualifier without specifying a bean name"
        correct: false

  - description: "Which annotations are considered part of the Spring Stereotype annotations?"
    answers:
      - option: "@Component"
        correct: true
      - option: "@Service"
        correct: true
      - option: "@Repository"
        correct: true
      - option: "@Configuration"
        correct: false
      - option: "@Bean"
        correct: false
  - description: "What is the default bean ID when using the @Bean annotation?"
    answers:
      - option: "The method name where @Bean is used."
        correct: true
      - option: "The class name of the returned bean."
        correct: false
      - option: "A UUID generated by Spring."
        correct: false
      - option: "The package name followed by the class name."
        correct: false

  - description: "How can you override the default bean ID specified by the @Bean annotation?"
    answers:
      - option: "By specifying a name attribute within the @Bean annotation."
        correct: true
      - option: "Using the @Qualifier annotation on the bean method."
        correct: false
      - option: "Renaming the method annotated with @Bean."
        correct: true
      - option: "Annotating the method with @Primary."
        correct: false
      - option: "Through XML configuration."
        correct: false

  - description: "True or False: The default scope of a bean defined with @Bean is singleton."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which annotation is used to define a bean that requires a unique instance for each use?"
    answers:
      - option: "@Scope(\"prototype\")"
        correct: true
      - option: "@Prototype"
        correct: false
      - option: "@Singleton"
        correct: false
      - option: "@RequestScope"
        correct: false

  - description: "True or False: Beans defined with @Bean in a @Configuration class can depend on other beans in the Spring context."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which annotations are used to automatically detect Spring components through classpath scanning?"
    answers:
      - option: "@Component"
        correct: true
      - option: "@Service"
        correct: true
      - option: "@Repository"
        correct: true
      - option: "@Entity"
        correct: false
      - option: "@Configuration"
        correct: false

  - description: "How can you specify a bean to be lazily initialized in Spring?"
    answers:
      - option: "By annotating the bean method with @Lazy."
        correct: true
      - option: "By setting the lazyInit property to true in XML configuration."
        correct: false
      - option: "Using the @Autowired annotation with a required=false parameter."
        correct: false
      - option: "Marking the bean class with @Lazy at the class level."
        correct: false

  - description: "What does the @Primary annotation indicate when used with beans in Spring?"
    answers:
      - option: "It designates a bean as the primary candidate for autowiring when multiple candidates are present."
        correct: true
      - option: "It sets the bean as the first to be initialized within its scope."
        correct: false
      - option: "It marks the bean's ID as primary, overriding any names set with @Bean."
        correct: false
      - option: "It specifies that the bean should be used in primary configuration files only."
        correct: false

  - description: "In Spring, how can you define a bean that is scoped to an HTTP request?"
    answers:
      - option: "@RequestScope"
        correct: true
      - option: "@Scope(\"request\")"
        correct: true
      - option: "@SessionScope"
        correct: false
      - option: "@Bean(scope = \"request\")"
        correct: false

  - description: "Can a @Configuration class be abstract in Spring?"
    answers:
      - option: "Yes, and it can contain bean definitions that are inherited by subclasses."
        correct: true
      - option: "No, @Configuration classes must be concrete to be processed by Spring."
        correct: false
      - option: "Yes, but it cannot include any @Bean annotated methods."
        correct: false
      - option: "No, Spring does not support inheritance for configuration classes."
        correct: false
  - description: "What is the purpose of using an alias for a bean in Spring?"
    answers:
      - option: "To define additional names for a bean, making it accessible with multiple identifiers."
        correct: true
      - option: "To change the default bean ID to a more descriptive name."
        correct: false
      - option: "To mark a bean as primary when multiple beans of the same type exist."
        correct: false
      - option: "To specify parent-child relationships between beans."
        correct: false

  - description: "How can you define an alias for a bean in Spring Java Config?"
    answers:
      - option: "By using the @AliasFor annotation on @Bean methods."
        correct: true
      - option: "Directly within the @Bean annotation using the 'alias' attribute."
        correct: false
      - option: "Aliases are not supported in Java Config, only in XML configuration."
        correct: false
      - option: "By calling the setAlias method on the BeanDefinition object."
        correct: false

  - description: "How can a bean be retrieved using its alias in Spring?"
    answers:
      - option: "By passing the alias name to the getBean method of the ApplicationContext."
        correct: true
      - option: "Using @Autowired annotation with the alias as its value."
        correct: false
      - option: "Aliases cannot be used to retrieve beans; only the primary bean ID is valid."
        correct: false
      - option: "By annotating the bean method with @AliasFor(annotation = @Bean)."
        correct: false

  - description: "True or False: In Spring, a bean can have multiple aliases, but only one primary bean ID."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which method is used to obtain the name of a bean including its aliases in the Spring context?"
    answers:
      - option: "getBeanDefinitionName"
        correct: true
      - option: "getAliases"
        correct: false
      - option: "getBeanNamesForType"
        correct: false
      - option: "getBeanName"
        correct: false
  - description: "Why can't you annotate a final class with @Configuration?"
    answers:
      - option: "Spring needs to create a CGLIB proxy of the class, which isn't possible with final classes."
        correct: true
      - option: "Final classes are not supported by the Java language specification."
        correct: false
      - option: "@Configuration classes need to be extendable by other configuration classes."
        correct: false
      - option: "Final classes are automatically considered as beans without needing annotations."
        correct: false

  - description: "How do the annotation @Configuration annotated classes support singleton beans?"
    answers:
      - option: "By intercepting bean method calls and ensuring a single instance per Spring Context."
        correct: true
      - option: "Using Java's native singleton pattern within the method body."
        correct: false
      - option: "By declaring beans as static methods."
        correct: false
      - option: "Spring does not support singleton beans in @Configuration classes."
        correct: false
      - option: "Through explicit singleton pattern implementations in each bean method."
        correct: false

  - description: "Why can't a method annotated with @Bean be final?"
    answers:
      - option: "Spring needs to override the method in the CGLIB proxy."
        correct: true
      - option: "Final methods cannot return objects in Java."
        correct: false
      - option: "@Bean methods are inherently static and cannot be final."
        correct: false
      - option: "Final methods can only be used in final classes."
        correct: false
      - option: "The @Bean annotation implicitly makes any method abstract."
        correct: false

  - description: "True or False: CGLIB proxies are used to enforce scope semantics for beans defined in @Configuration annotated classes."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "True or False: An abstract @Configuration class cannot contain @Bean annotated methods."
    answers:
      - option: "False"
        correct: true
      - option: "True"
        correct: false

  - description: "What happens if a bean method in a @Configuration class is called directly?"
    answers:
      - option: "It bypasses the bean lifecycle management of Spring and returns a new instance each time."
        correct: true
      - option: "Spring throws an exception to prevent incorrect usage."
        correct: false
      - option: "The method will return null to indicate a misconfiguration."
        correct: false
      - option: "It automatically redirects the call through the Spring context to ensure proper management."
        correct: false

  - description: "Can @Configuration annotated classes be nested within each other?"
    answers:
      - option: "Yes, and nested configuration classes can be used to organize configuration logically."
        correct: true
      - option: "No, nested @Configuration classes are not supported by Spring."
        correct: false
      - option: "Yes, but only if the outer class is abstract."
        correct: false
      - option: "No, each @Configuration class must be top-level and public."
        correct: false

  - description: "Which annotation should be used to create a CGLIB proxy of a @Configuration annotated class?"
    answers:
      - option: "No specific annotation is required; Spring automatically creates a CGLIB proxy if needed."
        correct: true
      - option: "@EnableCGLIBProxy"
        correct: false
      - option: "@ProxyMode"
        correct: false
      - option: "@Aspect"
        correct: false
      - option: "@EnableAspectJAutoProxy"
        correct: false

  - description: "How does Spring ensure that a @Configuration class supports bean overriding?"
    answers:
      - option: "By checking for method overrides in the CGLIB proxy at runtime."
        correct: true
      - option: "Bean overriding is not supported; each bean must have a unique name."
        correct: false
      - option: "Using the @Primary annotation on one of the conflicting beans."
        correct: false
      - option: "By requiring all bean methods to be annotated with @Override."
        correct: false

  - description: "What is the significance of @Bean method parameters in a @Configuration class?"
    answers:
      - option: "Parameters allow for dependency injection into @Bean methods, facilitating complex configurations."
        correct: true
      - option: "@Bean methods should not have parameters; all dependencies must be fields."
        correct: false
      - option: "Parameters are used to pass values from properties files directly into beans."
        correct: false
      - option: "Method parameters in @Bean methods are ignored by Spring."
        correct: false
  - description: "How do you activate a Spring profile?"
    answers:
      - option: "Using the spring.profiles.active property in application.properties"
        correct: true
      - option: "With the @ActiveProfiles annotation in test classes"
        correct: true
      - option: "By calling ProfileManager.activateProfile in your code"
        correct: false
      - option: "Through the @Profile annotation on beans"
        correct: false
      - option: "Setting the JAVA_HOME environment variable to the profile name"
        correct: false

  - description: "What are the possible use cases for Spring profiles?"
    answers:
      - option: "To configure beans differently based on deployment environments"
        correct: true
      - option: "For enabling or disabling features in the application"
        correct: true
      - option: "To manage bean life cycle"
        correct: false
      - option: "To inject dependencies conditionally"
        correct: false
      - option: "To increase the security level of an application"
        correct: false

  - description: "True or False: A Spring profile can be activated programmatically."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which Spring annotation is used to specify a bean is only available in specific profiles?"
    answers:
      - option: "@Profile"
        correct: true
      - option: "@ActiveProfiles"
        correct: false
      - option: "@Bean"
        correct: false
      - option: "@Component"
        correct: false

  - description: "True or False: Profiles can be used to load specific property files."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Can multiple profiles be active at the same time in a Spring application?"
    answers:
      - option: "Yes, multiple profiles can be activated simultaneously."
        correct: true
      - option: "No, only one profile can be active at any given time."
        correct: false

  - description: "How are Spring profiles beneficial in microservices architecture?"
    answers:
      - option: "They allow for environment-specific configurations without changing the code."
        correct: true
      - option: "Profiles enable service discovery and registration."
        correct: false
      - option: "They provide versioning of microservices."
        correct: false
      - option: "Profiles automate the deployment process."
        correct: false

  - description: "True or False: @Profile annotation can be used on @Configuration classes."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "What is the effect of not specifying a profile for a bean?"
    answers:
      - option: "The bean is always registered, regardless of the active profiles."
        correct: true
      - option: "The bean is only registered if the default profile is active."
        correct: false
      - option: "The bean is never registered until a profile is explicitly specified."
        correct: false
      - option: "Spring throws an exception due to the missing profile specification."
        correct: false

  - description: "Can the @Profile annotation be combined with other stereotypes like @Service or @Component?"
    answers:
      - option: "Yes, @Profile can be used in combination with stereotypes to conditionally declare beans."
        correct: true
      - option: "No, @Profile must be used exclusively with @Configuration classes."
        correct: false
      - option: "Yes, but only if the @ComponentScan annotation is configured to include profiled beans."
        correct: false
      - option: "No, beans with @Profile cannot be scanned by Spring."
        correct: false

  - description: "How to define default behavior for beans without an active profile?"
    answers:
      - option: "Use the @Profile(\"default\") annotation"
        correct: true
      - option: "Beans without a specified profile automatically apply to the default profile."
        correct: true
      - option: "Specify default behavior in application.properties."
        correct: false
      - option: "Use the default-profile attribute in the @Profile annotation."
        correct: false
      - option: "Annotate beans with @DefaultProfile."
        correct: false

  - description: "True or False: Profiles can be nested to create hierarchical configurations."
    answers:
      - option: "False, profiles cannot be nested but can be combined."
        correct: true
      - option: "True, profiles support nesting for complex configurations."
        correct: false

  - description: "Which application property is used to specify active profiles in a Spring Boot application?"
    answers:
      - option: "spring.profiles.active"
        correct: true
      - option: "spring.active.profiles"
        correct: false
      - option: "spring.boot.profiles.active"
        correct: false
      - option: "profiles.active"
        correct: false

  - description: "True or False: Changing active profiles at runtime requires restarting the Spring application context."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which tool can be used alongside Spring profiles to manage and switch configurations across different environments?"
    answers:
      - option: "Spring Cloud Config"
        correct: true
      - option: "Spring Boot Actuator"
        correct: false
      - option: "Spring MVC"
        correct: false
      - option: "Spring Security"
        correct: false
  - description: "Which file is commonly used to define properties for specific profiles in Spring Boot?"
    answers:
      - option: "application-{profile}.properties"
        correct: true
      - option: "config-{profile}.properties"
        correct: false
      - option: "spring-{profile}.properties"
        correct: false
      - option: "profile-{profile}.properties"
        correct: false

  - description: "True or False: Environment-specific properties override the properties defined in the application.properties file when the corresponding profile is active."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "How can a developer specify that a bean belongs to multiple profiles in Spring?"
    answers:
      - option: "Using the @Profile annotation with profile names separated by commas"
        correct: true
      - option: "By repeating the @Profile annotation on the bean definition"
        correct: true
      - option: "Assigning multiple @Profile annotations to different methods within the configuration class"
        correct: false
      - option: "Profiles cannot be combined; a bean must belong to a single profile only."
        correct: false

  - description: "True or False: Activating a profile in Spring can deactivate another profile."
    answers:
      - option: "False, activating a profile does not deactivate others unless explicitly configured to do so."
        correct: true
      - option: "True, activating one profile automatically deactivates all others."
        correct: false

  - description: "Which Spring Boot feature allows for easy application property management across different environments?"
    answers:
      - option: "Spring Profiles"
        correct: true
      - option: "Spring Cloud Config"
        correct: true
      - option: "Spring Boot Actuator"
        correct: false
      - option: "Spring MVC Interceptors"
        correct: false

  - description: "True or False: @Profile annotations can be used at the method level within a @Configuration class."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "In a Spring application, where is the 'spring.profiles.active' property typically specified?"
    answers:
      - option: "application.properties or application.yml"
        correct: true
      - option: "web.xml"
        correct: false
      - option: "pom.xml"
        correct: false
      - option: "spring-config.xml"
        correct: false

  - description: "How does Spring handle beans without an associated profile when a specific profile is active?"
    answers:
      - option: "Beans without an associated profile are always registered, regardless of which profile is active."
        correct: true
      - option: "Such beans are only registered if no profile is active."
        correct: false
      - option: "They are registered only if the 'default' profile is active."
        correct: false
      - option: "Spring ignores these beans if any profile is activated."
        correct: false

  - description: "Which component is responsible for activating profiles within the Spring Framework?"
    answers:
      - option: "Environment abstraction"
        correct: true
      - option: "ApplicationContext"
        correct: false
      - option: "BeanFactory"
        correct: false
      - option: "ProfileManager"
        correct: false

  - description: "True or False: Profiles can be specified within the @SpringBootApplication annotation using the 'profiles' attribute."
    answers:
      - option: "False, profiles are specified using the 'spring.profiles.active' property or @ActiveProfiles for tests."
        correct: true
      - option: "True, the 'profiles' attribute in @SpringBootApplication is used to define active profiles."
        correct: false

  - description: "What is the primary purpose of using profiles in Spring?"
    answers:
      - option: "To separate bean configurations for different environments without changing the code."
        correct: true
      - option: "To enhance the security of Spring applications by segregating bean definitions."
        correct: false
      - option: "To increase the performance of the application by loading only necessary beans."
        correct: false
      - option: "To provide versioning of beans for rollback purposes."
        correct: false

  - description: "Which annotation is used to activate profiles in test environments?"
    answers:
      - option: "@ActiveProfiles"
        correct: true
      - option: "@TestProfile"
        correct: false
      - option: "@Profile"
        correct: false
      - option: "@EnableProfiles"
        correct: false

  - description: "True or False: @Profile can be used to annotate entire classes as well as individual methods within a class."
    answers:
      - option: "True, @Profile can be applied at both class and method levels for conditional bean registration."
        correct: true
      - option: "False, @Profile can only annotate entire classes."
        correct: false

  - description: "How do profiles interact with Spring Boot's externalized configuration system?"
    answers:
      - option: "Profiles determine which properties files are loaded based on the active profiles."
        correct: true
      - option: "Profiles and externalized configuration are independent features and do not interact."
        correct: false
      - option: "Externalized configurations override profile-specific properties."
        correct: false
      - option: "Profile activation is exclusively managed through externalized configuration."
        correct: false

  - description: "Can environment variables be used to activate Spring profiles?"
    answers:
      - option: "Yes, by setting the SPRING_PROFILES_ACTIVE environment variable."
        correct: true
      - option: "No, profiles can only be activated through properties files or annotations."
        correct: false
      - option: "Yes, but only when deploying a Spring Boot application in a cloud environment."
        correct: false
      - option: "No, environment variables are ignored by the Spring Framework."
        correct: false
  - description: "Can you use @Bean together with @Profile in Spring?"
    answers:
      - option: "Yes, by annotating a @Bean method with @Profile to conditionally load the bean."
        correct: true
      - option: "No, @Bean and @Profile annotations are mutually exclusive."
        correct: false
      - option: "Yes, but the @Bean annotation must be used inside a @Profile-annotated class."
        correct: false
      - option: "No, @Profile can only be used at the class level, not on methods."
        correct: false

  - description: "What is the purpose of using @Profile on a @Bean method?"
    answers:
      - option: "To conditionally include the bean in the Spring context based on the active profiles."
        correct: true
      - option: "To specify the bean should be treated as a primary bean when multiple candidates are present."
        correct: false
      - option: "To increase the precedence of the bean over others of the same type."
        correct: false
      - option: "To exclude the bean from the Spring context entirely."
        correct: false
      - option: "To categorize the bean for easier scanning and autowiring."
        correct: false

  - description: "True or False: @Bean methods can be annotated with multiple @Profile annotations to specify complex profile conditions."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which of the following is a correct way to use @Profile with @Bean?"
    answers:
      - option: "@Bean @Profile('dev') public DataSource devDataSource() { ... }"
        correct: true
      - option: "@Profile('dev') @Bean public DataSource dataSource() { ... }"
        correct: true
      - option: "@Bean(profiles = 'dev') public DataSource dataSource() { ... }"
        correct: false
      - option: "@Profile @Bean('dev') public DataSource devDataSource() { ... }"
        correct: false

  - description: "True or False: A @Bean annotated method without a specified @Profile will be included in the Spring context regardless of the active profile."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "How does Spring handle beans defined with @Bean and @Profile when the specified profile is not active?"
    answers:
      - option: "The bean is not created or included in the application context."
        correct: true
      - option: "Spring creates a proxy bean that is lazily initialized when the profile becomes active."
        correct: false
      - option: "The bean is marked as inactive but still included in the context for dependency resolution."
        correct: false
      - option: "The bean is instantiated but marked as 'pending' until the profile is activated."
        correct: false

  - description: "Can @Profile be used to define exclusive beans for different environments within the same configuration class?"
    answers:
      - option: "Yes, by annotating @Bean methods with different @Profile annotations."
        correct: true
      - option: "No, @Profile can only be applied at the class level for exclusive environment configuration."
        correct: false
      - option: "Yes, but only if the configuration class is also annotated with @EnvironmentAware."
        correct: false
      - option: "No, exclusive beans for different environments require separate configuration classes."
        correct: false

  - description: "What happens if multiple @Bean methods in the same @Configuration class are annotated with the same @Profile?"
    answers:
      - option: "All beans under the same profile are conditionally loaded based on the profile's activation."
        correct: true
      - option: "Only the first @Bean method encountered by Spring under the specified profile is loaded."
        correct: false
      - option: "Spring throws a conflict exception due to multiple beans under the same profile."
        correct: false
      - option: "The @Bean methods override each other, and only the last one is used."
        correct: false

  - description: "In a Spring application, how can developers activate profiles for integration testing?"
    answers:
      - option: "Using the @ActiveProfiles annotation in test classes."
        correct: true
      - option: "By setting the active profile in the application.properties file."
        correct: false
      - option: "Through command-line arguments when starting the application."
        correct: true
      - option: "By manually activating profiles in the setUp method of tests."
        correct: false

  - description: "True or False: The @Profile annotation can only be combined with @Bean in XML-based Spring configuration."
    answers:
      - option: "False, @Profile and @Bean can be used together in both Java and XML-based configurations."
        correct: true
      - option: "True, combining @Profile with @Bean is exclusively supported in XML configuration."
        correct: false
  - description: "Can you use @Component together with @Profile in Spring?"
    answers:
      - option: "Yes, to conditionally include the component based on the active profile."
        correct: true
      - option: "No, @Component and @Profile annotations cannot be used together."
        correct: false
      - option: "Yes, but the component will ignore the @Profile annotation."
        correct: false
      - option: "No, only @Service classes can be annotated with @Profile."
        correct: false

  - description: "What happens when a Spring component is annotated with @Profile?"
    answers:
      - option: "The component is only created if the specified profile is active."
        correct: true
      - option: "The @Profile annotation is ignored by Spring."
        correct: false
      - option: "Spring creates a proxy for the component, regardless of the profile."
        correct: false
      - option: "The application fails to start if the profile is not active."
        correct: false
      - option: "It becomes the default component for its type, regardless of profile activation."
        correct: false

  - description: "True or False: @Profile can be applied to any Spring-managed bean, not just components."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which Spring annotation allows specifying a bean should be available in certain profiles?"
    answers:
      - option: "@Profile"
        correct: true
      - option: "@Conditional"
        correct: false
      - option: "@Bean"
        correct: false
      - option: "@ActiveProfiles"
        correct: false

  - description: "True or False: A component annotated with @Profile('dev') will be instantiated in production environment unless explicitly configured."
    answers:
      - option: "False"
        correct: true
      - option: "True"
        correct: false

  - description: "How can you define multiple profiles for a single component in Spring?"
    answers:
      - option: "Using @Profile and specifying the profiles as a comma-separated list"
        correct: true
      - option: "By repeating the @Profile annotation for each profile"
        correct: false
      - option: "By creating separate component classes for each profile"
        correct: false
      - option: "Using @Profiles annotation with a list of profile names"
        correct: false

  - description: "What is a typical use case for combining @Component with @Profile?"
    answers:
      - option: "To load specific beans only in certain environments, like development, testing, or production."
        correct: true
      - option: "To enhance the performance of the application by loading fewer beans."
        correct: false
      - option: "To secure components by only loading them under secure profiles."
        correct: false
      - option: "To create a component that can dynamically switch profiles at runtime."
        correct: false

  - description: "Can @Profile be used together with stereotypes such as @Service, @Repository, and @Controller?"
    answers:
      - option: "Yes, @Profile can be combined with these stereotypes to conditionally register beans."
        correct: true
      - option: "No, @Profile is only applicable to @Component annotated beans."
        correct: false
      - option: "Yes, but only @Repository can be used with @Profile."
        correct: false
      - option: "No, using @Profile with any stereotype other than @Component disables the stereotype's functionality."
        correct: false

  - description: "In what file are active profiles specified in a Spring Boot application?"
    answers:
      - option: "application.properties or application.yml"
        correct: true
      - option: "boot.properties"
        correct: false
      - option: "profiles.yml"
        correct: false
      - option: "config.properties"
        correct: false

  - description: "True or False: Removing the @Profile annotation from a component makes it available regardless of the active profile."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false
  - description: "How many profiles can be active at the same time in a Spring application?"
    answers:
      - option: "There is no limit to the number of active profiles."
        correct: true
      - option: "Only one profile can be active at a time."
        correct: false
      - option: "Up to three profiles can be active simultaneously."
        correct: false
      - option: "A maximum of five profiles due to performance constraints."
        correct: false

  - description: "What is required to activate multiple profiles in Spring?"
    answers:
      - option: "Specify them as a comma-separated list under the spring.profiles.active property."
        correct: true
      - option: "Use the @ActiveProfiles annotation with multiple profile names."
        correct: true
      - option: "Manually register each profile with the ApplicationContext before startup."
        correct: false
      - option: "Profiles cannot be activated simultaneously; they must be switched dynamically at runtime."
        correct: false
      - option: "Invoke the setActiveProfiles method on the Environment with profile names."
        correct: true

  - description: "True or False: Activating multiple profiles can lead to bean definition conflicts if not managed carefully."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which Spring Boot property is used to activate profiles?"
    answers:
      - option: "spring.profiles.active"
        correct: true
      - option: "spring.active.profiles"
        correct: false
      - option: "spring.boot.profiles"
        correct: false
      - option: "profiles.active"
        correct: false

  - description: "True or False: Profiles in Spring are mutually exclusive and cannot share beans across them."
    answers:
      - option: "False, beans can be shared across profiles unless specifically confined to a single profile."
        correct: true
      - option: "True, each profile is an isolated environment without any overlap."
        correct: false

  - description: "How can profiles be specified for a Spring Boot application in an IDE?"
    answers:
      - option: "As VM options in the run configuration."
        correct: true
      - option: "In the application.properties file located in the src/main/resources directory."
        correct: true
      - option: "Directly in the @SpringBootApplication annotation using the profiles attribute."
        correct: false
      - option: "By setting an environment variable in the operating system."
        correct: true
      - option: "Using the @Profile annotation in the main application class."
        correct: false

  - description: "What is a benefit of using multiple active profiles in Spring?"
    answers:
      - option: "To customize application behavior under different environments without changing the codebase."
        correct: true
      - option: "To increase the application's startup time by loading only relevant beans."
        correct: false
      - option: "To enforce strict bean overriding rules in the application context."
        correct: false
      - option: "Profiles have no benefits; they are merely a way to organize configuration."
        correct: false

  - description: "Can environment variables be used to activate profiles in Spring Boot?"
    answers:
      - option: "Yes, by setting the SPRING_PROFILES_ACTIVE variable."
        correct: true
      - option: "No, environment variables are not supported for profile activation."
        correct: false
      - option: "Yes, but only when deploying to a cloud environment."
        correct: false
      - option: "No, profiles can only be activated through the application.properties file."
        correct: false

  - description: "What is the impact of having no active profiles in a Spring application?"
    answers:
      - option: "Beans not associated with a specific profile are always registered."
        correct: true
      - option: "The application uses the default profile."
        correct: true
      - option: "The application fails to start due to a lack of active profiles."
        correct: false
      - option: "Spring automatically activates the dev profile."
        correct: false

  - description: "How does Spring handle beans defined in multiple active profiles?"
    answers:
      - option: "Beans from all active profiles are registered in the application context."
        correct: true
      - option: "Only beans from the first listed active profile are registered."
        correct: false
      - option: "Beans from multiple profiles result in conflicts and cause the application to fail."
        correct: false
      - option: "Spring merges bean definitions from active profiles, with later profiles overriding earlier ones."
        correct: false
  - description: "Which annotation is used to inject scalar values into Spring beans?"
    answers:
      - option: "@Value"
        correct: true
      - option: "@Autowired"
        correct: false
      - option: "@Inject"
        correct: false
      - option: "@Resource"
        correct: false
      - option: "@PropertySource"
        correct: false

  - description: "How can you inject a property value from a properties file into a Spring bean?"
    answers:
      - option: "Using the @Value annotation with a property placeholder"
        correct: true
      - option: "Directly assigning the property value in the @Component annotation"
        correct: false
      - option: "Utilizing the @Autowired annotation on a properties field"
        correct: false
      - option: "Through the use of the @PropertySource annotation on the class"
        correct: true
      - option: "By defining a public setter method for the property"
        correct: false

  - description: "True or False: The @Value annotation supports SpEL (Spring Expression Language) for dynamic value injection."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "What is required to use the @Value annotation for injecting values from a properties file?"
    answers:
      - option: "The properties file must be specified using the @PropertySource annotation."
        correct: true
      - option: "No additional configuration is needed if application.properties or application.yml is used."
        correct: true
      - option: "A custom PropertyPlaceholderConfigurer bean must be defined."
        correct: false
      - option: "Values can only be injected from application.properties without extra configuration."
        correct: false

  - description: "True or False: You can inject system properties into Spring beans using the @Value annotation."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which of the following is a correct usage of the @Value annotation to inject a literal value?"
    answers:
      - option: "@Value('literalValue')"
        correct: true
      - option: "@Value('#{literalValue}')"
        correct: false
      - option: "@Value('${property.key}')"
        correct: false
      - option: "@Autowired('literalValue')"
        correct: false

  - description: "Can the @Value annotation be used on constructor parameters for value injection?"
    answers:
      - option: "Yes, it can be used to inject values directly into constructor parameters."
        correct: true
      - option: "No, @Value can only be used on fields and setter methods."
        correct: false
      - option: "Yes, but only if the constructor is also annotated with @Autowired."
        correct: true
      - option: "No, constructor injection requires the use of @Inject or @Autowired only."
        correct: false

  - description: "How do you specify a default value for a property when using the @Value annotation?"
    answers:
      - option: "@Value('${property.key:defaultValue}')"
        correct: true
      - option: "@Value(defaultValue='${property.key}')"
        correct: false
      - option: "@Value('${property.key}' || 'defaultValue')"
        correct: false
      - option: "Default values are not supported with @Value."
        correct: false

  - description: "Which of the following is true regarding the @Value annotation?"
    answers:
      - option: "It can be used to inject values from property files, system properties, and environment variables."
        correct: true
      - option: "It automatically converts injected string values to the appropriate type."
        correct: true
      - option: "@Value injection is processed before @Autowired injection."
        correct: false
      - option: "Using @Value to inject collections like Lists or Sets requires custom converters."
        correct: true

  - description: "True or False: The @Value annotation can inject values into private fields without requiring a setter method."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false
  - description: "What role does the @PropertySource annotation play in conjunction with the @Value annotation?"
    answers:
      - option: "It specifies the location of the properties file to be used for resolving ${...} placeholders within @Value."
        correct: true
      - option: "It directly injects property values into beans without needing @Value."
        correct: false
      - option: "@PropertySource is an alternative to @Value and does not work in conjunction with it."
        correct: false
      - option: "It defines default values for @Value annotations that cannot resolve a placeholder."
        correct: false

  - description: "Can you use the @Value annotation to inject a value into a static field?"
    answers:
      - option: "No, @Value cannot be used to inject values into static fields."
        correct: true
      - option: "Yes, @Value supports injection into both static and non-static fields equally."
        correct: false
      - option: "Yes, but only if the static field is annotated with @Autowired as well."
        correct: false
      - option: "No, static fields are not managed by the Spring container and thus cannot have injected values."
        correct: true

  - description: "Which expression language is supported by the @Value annotation for dynamic expressions?"
    answers:
      - option: "Spring Expression Language (SpEL)"
        correct: true
      - option: "Java Expression Language (JEXL)"
        correct: false
      - option: "Unified Expression Language (UEL)"
        correct: false
      - option: "Expression Language for Java (ELJ)"
        correct: false

  - description: "True or False: The @Value annotation can be used in combination with @Profile to conditionally inject values."
    answers:
      - option: "True, but the conditional injection depends on the active profiles and property sources."
        correct: true
      - option: "False, @Value does not interact with @Profile for conditional value injection."
        correct: false

  - description: "What is required to enable property resolution with @Value annotation in a non-Spring Boot application?"
    answers:
      - option: "Defining a PropertySourcesPlaceholderConfigurer bean in the configuration."
        correct: true
      - option: "Including spring-context-support dependency in the project."
        correct: false
      - option: "Annotating the main class with @EnableValueInjection."
        correct: false
      - option: "Using @PropertySource at the class level and @Value at the field or method parameter level."
        correct: true
  - description: "What is Spring Expression Language (SpEL)?"
    answers:
      - option: "A powerful expression language that allows querying and manipulating an object graph at runtime."
        correct: true
      - option: "A database query language integrated with Spring."
        correct: false
      - option: "A template engine for processing HTML views in Spring MVC."
        correct: false
      - option: "A scripting language for bean validation in Spring."
        correct: false

  - description: "Which of the following are true about SpEL?"
    answers:
      - option: "SpEL can be used for querying and manipulating an object graph at runtime."
        correct: true
      - option: "SpEL supports array and list selection and projection."
        correct: true
      - option: "SpEL is only available within Spring Boot applications."
        correct: false
      - option: "SpEL can directly execute SQL queries against a database."
        correct: false
      - option: "SpEL expressions are statically typed."
        correct: false

  - description: "True or False: SpEL can be used in @Value annotations for dynamic value injection."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "What types of operators does SpEL support?"
    answers:
      - option: "Relational operators"
        correct: true
      - option: "Logical operators"
        correct: true
      - option: "Mathematical operators"
        correct: true
      - option: "Bitwise operators"
        correct: false

  - description: "True or False: SpEL expressions are evaluated against a specific context that provides data for the expression."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "How can SpEL be utilized in XML-based Spring configuration?"
    answers:
      - option: "By using the #{...} syntax within bean definitions."
        correct: true
      - option: "SpEL cannot be used in XML configuration; it is only for Java-based configuration."
        correct: false
      - option: "Through special XML tags dedicated to SpEL expressions."
        correct: false
      - option: "By declaring SpEL variables at the top of the XML file."
        correct: false

  - description: "Can SpEL be used to reference beans in the Spring application context?"
    answers:
      - option: "Yes, by using @Bean's name within SpEL expressions."
        correct: true
      - option: "No, SpEL can only manipulate data and cannot reference Spring beans."
        correct: false
      - option: "Yes, but only if the beans are annotated with @SpEL."
        correct: false
      - option: "No, bean references are exclusively managed through @Autowired and @Inject annotations."
        correct: false

  - description: "What is a common use case for SpEL in a Spring application?"
    answers:
      - option: "To dynamically resolve bean property values from external configuration."
        correct: true
      - option: "As the primary language for developing web controllers in Spring MVC."
        correct: false
      - option: "To compile Java code at runtime within the application."
        correct: false
      - option: "To generate SQL queries for Spring Data repositories."
        correct: false

  - description: "How does SpEL handle type conversion within expressions?"
    answers:
      - option: "SpEL performs automatic type conversion between the expression result and the destination field value."
        correct: true
      - option: "Type conversion in SpEL requires manual intervention using specific SpEL functions."
        correct: false
      - option: "SpEL does not support type conversion; types must match exactly."
        correct: false
      - option: "Type conversion is handled externally by implementing custom converters."
        correct: false

  - description: "True or False: SpEL supports the definition of variables within expressions that can be reused."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false
  - description: "What is the Spring Expression Language (SpEL)?"
    answers:
      - option: "A powerful expression language that enables querying and manipulating an object graph at runtime."
        correct: true
      - option: "A specialized language for SQL queries within Spring applications."
        correct: false
      - option: "A configuration language for Spring Security."
        correct: false
      - option: "A Java-based scripting language exclusively for Spring Boot applications."
        correct: false

  - description: "Which of the following can SpEL be used for?"
    answers:
      - option: "Manipulating object graphs at runtime."
        correct: true
      - option: "Performing type conversions."
        correct: true
      - option: "Interacting with databases directly without using a repository."
        correct: false
      - option: "Compiling Java code dynamically."
        correct: false
      - option: "Automatically generating Spring bean definitions."
        correct: false

  - description: "True or False: SpEL expressions are only evaluated at application startup."
    answers:
      - option: "False"
        correct: true
      - option: "True"
        correct: false

  - description: "Which SpEL feature allows accessing properties and calling methods of objects?"
    answers:
      - option: "Dot notation"
        correct: true
      - option: "Lambda expressions"
        correct: false
      - option: "SQL-like queries"
        correct: false
      - option: "Annotation processing"
        correct: false

  - description: "True or False: SpEL supports logical operations within expressions."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "How can SpEL be utilized within annotations in Spring?"
    answers:
      - option: "With the @Value annotation to dynamically inject values."
        correct: true
      - option: "As a parameter to the @Autowired annotation for dynamic autowiring."
        correct: false
      - option: "Directly inside the @Component annotation for dynamic bean naming."
        correct: false
      - option: "In the @RequestMapping annotation for dynamic URL mapping."
        correct: false

  - description: "Can SpEL be used for collection projection and selection?"
    answers:
      - option: "Yes, to filter and transform collections and arrays."
        correct: true
      - option: "No, SpEL does not have capabilities for handling collections."
        correct: false
      - option: "Yes, but only for XML-based Spring configuration."
        correct: false
      - option: "No, collection operations must be performed in Java code outside of SpEL."
        correct: false

  - description: "What is a common use case for SpEL in Spring Security?"
    answers:
      - option: "For authorizing access to methods based on expression-based access control."
        correct: true
      - option: "SpEL is not used in Spring Security."
        correct: false
      - option: "To encrypt and decrypt property values."
        correct: false
      - option: "For configuring default user roles and permissions."
        correct: false

  - description: "True or False: SpEL can evaluate expressions against the context of a specific bean."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which of the following is NOT a feature of SpEL?"
    answers:
      - option: "Direct execution of native SQL queries."
        correct: true
      - option: "Evaluating expressions against objects."
        correct: false
      - option: "Support for regular expressions."
        correct: false
      - option: "Conditional expressions evaluation."
        correct: false
  - description: "How do you reference environment properties in SpEL?"
    answers:
      - option: "Using the #{environment['property.name']} syntax."
        correct: true
      - option: "SpEL does not allow direct reference to environment properties."
        correct: false
      - option: "@Environment('property.name')"
        correct: false
      - option: "#{systemProperties['property.name']}"
        correct: false

  - description: "What SpEL syntax is used to access system properties?"
    answers:
      - option: "#{systemProperties['property.name']}"
        correct: true
      - option: "#{environment['system.property.name']}"
        correct: false
      - option: "@SystemProperty('property.name')"
        correct: false
      - option: "#{systemEnvironment['property.name']}"
        correct: false

  - description: "True or False: SpEL expressions can be used in XML and Java-based Spring configurations alike."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which of the following correctly demonstrates using SpEL for a conditional expression?"
    answers:
      - option: "#{someBean.someProperty == 'someValue' ? 'trueOutcome' : 'falseOutcome'}"
        correct: true
      - option: "@If(someBean.someProperty == 'someValue', 'trueOutcome', 'falseOutcome')"
        correct: false
      - option: "#{someBean.someProperty ? 'trueOutcome' : 'falseOutcome'}"
        correct: false
      - option: "SpEL does not support conditional expressions."
        correct: false

  - description: "Can SpEL be used to instantiate new objects within expressions?"
    answers:
      - option: "Yes, using the 'new' operator within SpEL expressions."
        correct: true
      - option: "No, SpEL expressions are limited to operations on existing beans and properties."
        correct: false
      - option: "Yes, but only for classes that are annotated with @Component."
        correct: false
      - option: "No, new instances should be created using Java configuration or XML beans definition."
        correct: false
  - description: "What does the Environment abstraction in Spring represent?"
    answers:
      - option: "It represents classes that implement the Environment interface, allowing for property resolution and profile listing."
        correct: true
      - option: "A configuration management tool specific to Spring Boot applications."
        correct: false
      - option: "A database query language integrated within the Spring framework."
        correct: false
      - option: "A component scanning directive for automatically detecting beans."
        correct: false

  - description: "How can the Environment interface be accessed within a Spring application?"
    answers:
      - option: "Through the ApplicationContext using the getEnvironment() method."
        correct: true
      - option: "By annotating a class with @EnvironmentAware."
        correct: false
      - option: "Directly, by creating a new instance of the StandardEnvironment class."
        correct: false
      - option: "Using the @Autowired annotation on an Environment class property."
        correct: false
      - option: "By declaring an Environment bean in the Spring configuration."
        correct: false

  - description: "True or False: The Environment abstraction is used only for managing application profiles."
    answers:
      - option: "False"
        correct: true
      - option: "True"
        correct: false

  - description: "Which method on the Environment interface is used to obtain the active profiles?"
    answers:
      - option: "getActiveProfiles()"
        correct: true
      - option: "getCurrentProfiles()"
        correct: false
      - option: "listActiveProfiles()"
        correct: false
      - option: "getProfiles()"
        correct: false

  - description: "True or False: Properties can be resolved using the Environment interface and the @Value annotation."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Where can properties be obtained from according to the Environment abstraction?"
    answers:
      - option: "System environment variables"
        correct: true
      - option: "JVM system properties"
        correct: true
      - option: "Property files"
        correct: true
      - option: "Directly from database tables"
        correct: false
      - option: "Through external web services"
        correct: false

  - description: "How are additional property sources added to the Spring environment?"
    answers:
      - option: "Using the @PropertySource annotation in a configuration class."
        correct: true
      - option: "By manually editing the ApplicationContext’s properties file."
        correct: false
      - option: "Invoking the addPropertySource method on the Environment instance."
        correct: false
      - option: "Automatically, when a new bean is created."
        correct: false

  - description: "What is the role of the Environment abstraction in a Spring context?"
    answers:
      - option: "To assist in property resolution and defining property sources."
        correct: true
      - option: "To manage the lifecycle of Spring beans exclusively."
        correct: false
      - option: "To configure the application’s security settings."
        correct: false
      - option: "To provide network configuration for Spring applications."
        correct: false

  - description: "Which of the following is NOT a source of properties according to the Environment abstraction?"
    answers:
      - option: "External hardware devices"
        correct: true
      - option: "System environment variables"
        correct: false
      - option: "JVM system properties"
        correct: false
      - option: "Property files"
        correct: false

  - description: "Can the Environment interface be used to dynamically change profiles at runtime?"
    answers:
      - option: "No, profiles are determined at startup and cannot be changed dynamically."
        correct: true
      - option: "Yes, by calling the setActiveProfiles method on the Environment instance."
        correct: false
      - option: "Yes, through the use of special annotations on runtime."
        correct: false
      - option: "No, because profiles are hardcoded and cannot be modified."
        correct: false
  - description: "Which sources can properties in a standalone Spring application come from?"
    answers:
      - option: "System environment variables"
        correct: true
      - option: "JVM parameters"
        correct: true
      - option: "Property files using the @PropertySource annotation in a configuration class"
        correct: true
      - option: "Direct database queries"
        correct: false

  - description: "True or False: In applications with a Servlet container, property sources include ServletConfig and ServletContext parameters."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "How are property files specified as a source in a Spring application?"
    answers:
      - option: "Using the @PropertySource annotation"
        correct: true
      - option: "By declaring them in the main method of the application"
        correct: false
      - option: "Through XML configuration files"
        correct: false
      - option: "Automatically detected without any specific declaration"
        correct: false

  - description: "What is the role of the @Value annotation in utilizing property sources?"
    answers:
      - option: "Injecting values from property sources into Spring beans"
        correct: true
      - option: "Defining new property sources"
        correct: false
      - option: "Creating new properties files"
        correct: false
      - option: "Encrypting property values for security"
        correct: false
      - option: "Directly querying databases for properties"
        correct: false

  - description: "True or False: Property sources for Spring applications running with a Servlet container do not include JNDI attributes."
    answers:
      - option: "False, JNDI attributes are included as property sources."
        correct: true
      - option: "True, JNDI attributes are not considered property sources."
        correct: false

  - description: "Which additional property sources are available to Spring applications running with Spring Boot?"
    answers:
      - option: "Properties defined in YAML files within the JAR"
        correct: true
      - option: "Properties defined in external YAML files outside the JAR"
        correct: true
      - option: "Properties from profiles specified in property files"
        correct: true
      - option: "Directly from linked cloud service configurations"
        correct: false

  - description: "How can command line arguments be specified as property sources in Spring applications?"
    answers:
      - option: "By adding them to the Program arguments section in the IDE run configuration"
        correct: true
      - option: "Automatically without any specific configuration"
        correct: false
      - option: "Using the @CommandLineSource annotation"
        correct: false
      - option: "By manually parsing arguments in the main method"
        correct: false

  - description: "What method is used to set default properties in a Spring Boot application?"
    answers:
      - option: "SpringApplication.setDefaultProperties"
        correct: true
      - option: "Environment.setDefaultProperties"
        correct: false
      - option: "@DefaultProperties annotation"
        correct: false
      - option: "Default properties cannot be set in Spring Boot."
        correct: false

  - description: "True or False: Properties defined in JSON format can be set as environment variables using the SPRING_APPLICATION_JSON key."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which of the following is not a valid property source in Spring applications?"
    answers:
      - option: "Properties hard-coded in Java classes"
        correct: true
      - option: "JVM system properties"
        correct: false
      - option: "System environment variables"
        correct: false
      - option: "Property files annotated with @PropertySource"
        correct: false
  - description: "What can SpEL be used for in Spring applications?"
    answers:
      - option: "Running static methods from a class."
        correct: true
      - option: "Injecting dependencies."
        correct: false
      - option: "Automatically configuring Spring Security."
        correct: false
      - option: "Direct database manipulation."
        correct: false

  - description: "How do you access a static method using SpEL?"
    answers:
      - option: "By prefixing the class name with T and then calling the method."
        correct: true
      - option: "Using the @StaticMethod annotation."
        correct: false
      - option: "Directly invoking the method without any special syntax."
        correct: false
      - option: "SpEL cannot access static methods."
        correct: false
      - option: "With a special static method operator."
        correct: false

  - description: "True or False: SpEL can be used to obtain the value of a static property from a class."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "What syntax is used to obtain a bean property's value using SpEL?"
    answers:
      - option: "Using the @ symbol followed by the bean name and property."
        correct: true
      - option: "SpEL does not allow accessing bean properties."
        correct: false
      - option: "Directly accessing the property without any special syntax."
        correct: false
      - option: "Using the # symbol followed by the bean name and property."
        correct: false

  - description: "True or False: SpEL can evaluate expressions and assign the result to a property using the @Value annotation."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which SpEL syntax is used to execute a bean method and use the return value?"
    answers:
      - option: "Using the @ symbol followed by the bean name and method to be executed."
        correct: true
      - option: "SpEL does not support executing bean methods."
        correct: false
      - option: "Using the # symbol followed by the method name."
        correct: false
      - option: "Invoking the method directly without any special syntax."
        correct: false

  - description: "How do you reference a SpEL variable within an expression?"
    answers:
      - option: "By prefixing the variable name with the # symbol."
        correct: true
      - option: "@ symbol followed by the variable name."
        correct: false
      - option: "Variables cannot be referenced directly in SpEL."
        correct: false
      - option: "Using the variable name without any prefix."
        correct: false

  - description: "What is required to add custom properties or variables to the SpEL evaluation context?"
    answers:
      - option: "Using StandardEvaluationContext and ExpressionParser."
        correct: true
      - option: "No special configuration is required; SpEL handles this automatically."
        correct: false
      - option: "Custom properties cannot be added to SpEL context."
        correct: false
      - option: "Using the @SpelVariable annotation."
        correct: false

  - description: "True or False: SpEL allows accessing application environment properties using the environment variable."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which of the following is not a feature of SpEL?"
    answers:
      - option: "Direct execution of SQL queries."
        correct: true
      - option: "Accessing static method results."
        correct: false
      - option: "Fetching static property values."
        correct: false
      - option: "Running bean methods and attaching the results to properties."
        correct: false
  - description: "What is the difference between $ and # in @Value expressions?"
    answers:
      - option: "$ is used for evaluating property sources, while # is used for evaluating Spring Expression Language (SpEL) expressions."
        correct: true
      - option: "$ is used for SpEL expressions, and # is used for property sources."
        correct: false
      - option: "There is no difference; both can be used interchangeably."
        correct: false
      - option: "$ is for direct database queries, while # is for accessing bean properties."
        correct: false

  - description: "True or False: The $ operator in @Value expressions is used to access environment properties."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "Which operator allows you to run methods on beans in @Value expressions?"
    answers:
      - option: "#"
        correct: true
      - option: "$"
        correct: false
      - option: "@"
        correct: false
      - option: "%"
        correct: false
      - option: "!"
        correct: false

  - description: "True or False: You can use the # operator in @Value expressions to reference static methods."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "What does the $ operator in @Value expressions primarily reference?"
    answers:
      - option: "Property files, JVM properties, and environment variables"
        correct: true
      - option: "Bean methods and properties"
        correct: false
      - option: "Database records"
        correct: false
      - option: "External web services"
        correct: false

  - description: "How do you access a property of a bean using SpEL in @Value expressions?"
    answers:
      - option: "Using the # operator followed by the bean name and property"
        correct: true
      - option: "Directly accessing the property without any special syntax"
        correct: false
      - option: "Using the $ operator followed by the property name"
        correct: false
      - option: "SpEL does not support accessing bean properties"
        correct: false

  - description: "Can the $ operator in @Value expressions be used to evaluate expressions dynamically?"
    answers:
      - option: "No, it's used for referencing existing properties or variables"
        correct: true
      - option: "Yes, it can evaluate dynamic expressions"
        correct: false
      - option: "Only in combination with the # operator"
        correct: false
      - option: "Yes, but only for bean properties"
        correct: false

  - description: "Which of the following is true regarding the use of $ and # in @Value expressions?"
    answers:
      - option: "$ is used for property resolution, and # for evaluating SpEL expressions"
        correct: true
      - option: "Both can be used interchangeably for accessing bean properties"
        correct: false
      - option: "$ is for dynamic expression evaluation, while # is for static property access"
        correct: false
      - option: "Neither can be used for accessing static properties or methods"
        correct: false

  - description: "True or False: The # operator in @Value expressions can reference other beans."
    answers:
      - option: "True"
        correct: true
      - option: "False"
        correct: false

  - description: "What operator would you use in @Value to inject a property from a properties file?"
    answers:
      - option: "$"
        correct: true
      - option: "#"
        correct: false
      - option: "@"
        correct: false
      - option: "%"
        correct: false